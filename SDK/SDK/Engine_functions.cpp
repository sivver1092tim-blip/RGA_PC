
#include "../SDK.h"

// Name: , Version: 1.0.0

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

namespace SDK
{
//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------

// Function Engine.Actor.WasRecentlyRendered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::WasRecentlyRendered(float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.WasRecentlyRendered");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.WasRecentlyRendered");

	AEngine_Actor_WasRecentlyRendered_Params params;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.UserConstructionScript
// (Event, Public, BlueprintEvent)

void AEngine_Actor::UserConstructionScript()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.UserConstructionScript");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.UserConstructionScript");

	AEngine_Actor_UserConstructionScript_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.TearOff
// (Native, Public, BlueprintCallable)

void AEngine_Actor::TearOff()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.TearOff");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.TearOff");

	AEngine_Actor_TearOff_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SnapRootComponentTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           InParentActor                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SnapRootComponentTo(class AEngine_Actor* InParentActor, const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SnapRootComponentTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SnapRootComponentTo");

	AEngine_Actor_SnapRootComponentTo_Params params;
	params.InParentActor = InParentActor;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetTickGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ETickingGroup> NewTickGroup                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetTickGroup(TEnumAsByte<FEngine_Engine_ETickingGroup> NewTickGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickGroup");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickGroup");

	AEngine_Actor_SetTickGroup_Params params;
	params.NewTickGroup = NewTickGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bTickableWhenPaused            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickableWhenPaused");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickableWhenPaused");

	AEngine_Actor_SetTickableWhenPaused_Params params;
	params.bTickableWhenPaused = bTickableWhenPaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetReplicates
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInReplicates                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetReplicates(bool bInReplicates)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicates");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicates");

	AEngine_Actor_SetReplicates_Params params;
	params.bInReplicates = bInReplicates;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetReplicateMovement
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInReplicateMovement           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetReplicateMovement(bool bInReplicateMovement)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicateMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicateMovement");

	AEngine_Actor_SetReplicateMovement_Params params;
	params.bInReplicateMovement = bInReplicateMovement;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetOwner
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           NewOwner                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetOwner(class AEngine_Actor* NewOwner)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetOwner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetOwner");

	AEngine_Actor_SetOwner_Params params;
	params.NewOwner = NewOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetNetDormancy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ENetDormancy> NewDormancy                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetNetDormancy(TEnumAsByte<FEngine_Engine_ENetDormancy> NewDormancy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetNetDormancy");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetNetDormancy");

	AEngine_Actor_SetNetDormancy_Params params;
	params.NewDormancy = NewDormancy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetLifeSpan
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          InLifespan                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetLifeSpan(float InLifespan)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetLifeSpan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetLifeSpan");

	AEngine_Actor_SetLifeSpan_Params params;
	params.InLifespan = InLifespan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetActorTickInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          TickInterval                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetActorTickInterval(float TickInterval)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTickInterval");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTickInterval");

	AEngine_Actor_SetActorTickInterval_Params params;
	params.TickInterval = TickInterval;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetActorTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetActorTickEnabled(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTickEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTickEnabled");

	AEngine_Actor_SetActorTickEnabled_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetActorScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewScale3D                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetActorScale3D(const struct FVector& NewScale3D)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorScale3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorScale3D");

	AEngine_Actor_SetActorScale3D_Params params;
	params.NewScale3D = NewScale3D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetActorRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewRelativeScale               (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetActorRelativeScale3D(const struct FVector& NewRelativeScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeScale3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeScale3D");

	AEngine_Actor_SetActorRelativeScale3D_Params params;
	params.NewRelativeScale = NewRelativeScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetActorHiddenInGame
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewHidden                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetActorHiddenInGame(bool bNewHidden)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorHiddenInGame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorHiddenInGame");

	AEngine_Actor_SetActorHiddenInGame_Params params;
	params.bNewHidden = bNewHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.SetActorEnableCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewActorEnableCollision       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::SetActorEnableCollision(bool bNewActorEnableCollision)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorEnableCollision");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorEnableCollision");

	AEngine_Actor_SetActorEnableCollision_Params params;
	params.bNewActorEnableCollision = bNewActorEnableCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.RemoveTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ActorComponent*  PrerequisiteComponent          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void AEngine_Actor::RemoveTickPrerequisiteComponent(class UEngine_ActorComponent* PrerequisiteComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteComponent");

	AEngine_Actor_RemoveTickPrerequisiteComponent_Params params;
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.RemoveTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           PrerequisiteActor              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::RemoveTickPrerequisiteActor(class AEngine_Actor* PrerequisiteActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteActor");

	AEngine_Actor_RemoveTickPrerequisiteActor_Params params;
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          DeltaSeconds                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveTick(float DeltaSeconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveTick");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveTick");

	AEngine_Actor_ReceiveTick_Params params;
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveRadialDamage
// (BlueprintAuthorityOnly, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// float                          DamageReceived                 (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DamageType*      DamageType                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitInfo                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// class AEngine_Controller*      InstigatedBy                   (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveRadialDamage(float DamageReceived, class UEngine_DamageType* DamageType, const struct FVector& Origin, const struct FEngine_HitResult& HitInfo, class AEngine_Controller* InstigatedBy, class AEngine_Actor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveRadialDamage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveRadialDamage");

	AEngine_Actor_ReceiveRadialDamage_Params params;
	params.DamageReceived = DamageReceived;
	params.DamageType = DamageType;
	params.Origin = Origin;
	params.HitInfo = HitInfo;
	params.InstigatedBy = InstigatedBy;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceivePointDamage
// (BlueprintAuthorityOnly, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// float                          Damage                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DamageType*      DamageType                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitNormal                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* HitComponent                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ShotFromDirection              (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Controller*      InstigatedBy                   (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitInfo                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void AEngine_Actor::ReceivePointDamage(float Damage, class UEngine_DamageType* DamageType, const struct FVector& HitLocation, const struct FVector& HitNormal, class UEngine_PrimitiveComponent* HitComponent, const struct FName& BoneName, const struct FVector& ShotFromDirection, class AEngine_Controller* InstigatedBy, class AEngine_Actor* DamageCauser, const struct FEngine_HitResult& HitInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceivePointDamage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceivePointDamage");

	AEngine_Actor_ReceivePointDamage_Params params;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;
	params.HitComponent = HitComponent;
	params.BoneName = BoneName;
	params.ShotFromDirection = ShotFromDirection;
	params.InstigatedBy = InstigatedBy;
	params.DamageCauser = DamageCauser;
	params.HitInfo = HitInfo;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveHit
// (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// class UEngine_PrimitiveComponent* MyComp                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AEngine_Actor*           Other                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* OtherComp                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           bSelfMoved                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitNormal                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NormalImpulse                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void AEngine_Actor::ReceiveHit(class UEngine_PrimitiveComponent* MyComp, class AEngine_Actor* Other, class UEngine_PrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FEngine_HitResult& Hit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveHit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveHit");

	AEngine_Actor_ReceiveHit_Params params;
	params.MyComp = MyComp;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.bSelfMoved = bSelfMoved;
	params.HitLocation = HitLocation;
	params.HitNormal = HitNormal;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveEndPlay
// (Event, Protected, BlueprintEvent)
// Parameters:
// TEnumAsByte<FEngine_Engine_EEndPlayReason> EndPlayReason                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveEndPlay(TEnumAsByte<FEngine_Engine_EEndPlayReason> EndPlayReason)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveEndPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveEndPlay");

	AEngine_Actor_ReceiveEndPlay_Params params;
	params.EndPlayReason = EndPlayReason;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveDestroyed
// (Event, Public, BlueprintEvent)

void AEngine_Actor::ReceiveDestroyed()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveDestroyed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveDestroyed");

	AEngine_Actor_ReceiveDestroyed_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AEngine_Actor::ReceiveBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveBeginPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveBeginPlay");

	AEngine_Actor_ReceiveBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveAnyDamage
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// float                          Damage                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DamageType*      DamageType                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Controller*      InstigatedBy                   (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveAnyDamage(float Damage, class UEngine_DamageType* DamageType, class AEngine_Controller* InstigatedBy, class AEngine_Actor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveAnyDamage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveAnyDamage");

	AEngine_Actor_ReceiveAnyDamage_Params params;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.InstigatedBy = InstigatedBy;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorOnReleased
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FInputCore_Key          ButtonReleased                 (Parm)

void AEngine_Actor::ReceiveActorOnReleased(const struct FInputCore_Key& ButtonReleased)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnReleased");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnReleased");

	AEngine_Actor_ReceiveActorOnReleased_Params params;
	params.ButtonReleased = ButtonReleased;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorOnInputTouchLeave
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveActorOnInputTouchLeave(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchLeave");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchLeave");

	AEngine_Actor_ReceiveActorOnInputTouchLeave_Params params;
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorOnInputTouchEnter
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveActorOnInputTouchEnter(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnter");

	AEngine_Actor_ReceiveActorOnInputTouchEnter_Params params;
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorOnInputTouchEnd
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveActorOnInputTouchEnd(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnd");

	AEngine_Actor_ReceiveActorOnInputTouchEnd_Params params;
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorOnInputTouchBegin
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveActorOnInputTouchBegin(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchBegin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchBegin");

	AEngine_Actor_ReceiveActorOnInputTouchBegin_Params params;
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorOnClicked
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FInputCore_Key          ButtonPressed                  (Parm)

void AEngine_Actor::ReceiveActorOnClicked(const struct FInputCore_Key& ButtonPressed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnClicked");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnClicked");

	AEngine_Actor_ReceiveActorOnClicked_Params params;
	params.ButtonPressed = ButtonPressed;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorEndOverlap
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Actor*           OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveActorEndOverlap(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndOverlap");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndOverlap");

	AEngine_Actor_ReceiveActorEndOverlap_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorEndCursorOver
// (Event, Public, BlueprintEvent)

void AEngine_Actor::ReceiveActorEndCursorOver()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndCursorOver");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndCursorOver");

	AEngine_Actor_ReceiveActorEndCursorOver_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorBeginOverlap
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Actor*           OtherActor                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::ReceiveActorBeginOverlap(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginOverlap");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginOverlap");

	AEngine_Actor_ReceiveActorBeginOverlap_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.ReceiveActorBeginCursorOver
// (Event, Public, BlueprintEvent)

void AEngine_Actor::ReceiveActorBeginCursorOver()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginCursorOver");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginCursorOver");

	AEngine_Actor_ReceiveActorBeginCursorOver_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.PrestreamTextures
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Seconds                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableStreaming               (Parm, ZeroConstructor, IsPlainOldData)
// int                            CinematicTextureGroups         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::PrestreamTextures(float Seconds, bool bEnableStreaming, int CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.PrestreamTextures");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.PrestreamTextures");

	AEngine_Actor_PrestreamTextures_Params params;
	params.Seconds = Seconds;
	params.bEnableStreaming = bEnableStreaming;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnRep_ReplicateMovement
// (Native, Public)

void AEngine_Actor::OnRep_ReplicateMovement()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicateMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicateMovement");

	AEngine_Actor_OnRep_ReplicateMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnRep_ReplicatedMovement
// (Native, Public)

void AEngine_Actor::OnRep_ReplicatedMovement()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicatedMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicatedMovement");

	AEngine_Actor_OnRep_ReplicatedMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnRep_Owner
// (Native, Protected)

void AEngine_Actor::OnRep_Owner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Owner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Owner");

	AEngine_Actor_OnRep_Owner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnRep_Instigator
// (Native, Public)

void AEngine_Actor::OnRep_Instigator()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Instigator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Instigator");

	AEngine_Actor_OnRep_Instigator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.OnRep_AttachmentReplication
// (Native, Public)

void AEngine_Actor::OnRep_AttachmentReplication()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_AttachmentReplication");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_AttachmentReplication");

	AEngine_Actor_OnRep_AttachmentReplication_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.MakeNoise
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                          Loudness                       (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Pawn*            NoiseInstigator                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NoiseLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxRange                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::MakeNoise(float Loudness, class AEngine_Pawn* NoiseInstigator, const struct FVector& NoiseLocation, float MaxRange, const struct FName& Tag)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeNoise");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeNoise");

	AEngine_Actor_MakeNoise_Params params;
	params.Loudness = Loudness;
	params.NoiseInstigator = NoiseInstigator;
	params.NoiseLocation = NoiseLocation;
	params.MaxRange = MaxRange;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.MakeMIDForMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Parent                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* AEngine_Actor::MakeMIDForMaterial(class UEngine_MaterialInterface* Parent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeMIDForMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeMIDForMaterial");

	AEngine_Actor_MakeMIDForMaterial_Params params;
	params.Parent = Parent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_TeleportTo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 DestLocation                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                DestRotation                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::K2_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_TeleportTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_TeleportTo");

	AEngine_Actor_K2_TeleportTo_Params params;
	params.DestLocation = DestLocation;
	params.DestRotation = DestRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_SetActorTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              NewTransform                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::K2_SetActorTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorTransform");

	AEngine_Actor_K2_SetActorTransform_Params params;
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_SetActorRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTeleportPhysics               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::K2_SetActorRotation(const struct FRotator& NewRotation, bool bTeleportPhysics)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRotation");

	AEngine_Actor_K2_SetActorRotation_Params params;
	params.NewRotation = NewRotation;
	params.bTeleportPhysics = bTeleportPhysics;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_SetActorRelativeTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              NewRelativeTransform           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_SetActorRelativeTransform(const struct FTransform& NewRelativeTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeTransform");

	AEngine_Actor_K2_SetActorRelativeTransform_Params params;
	params.NewRelativeTransform = NewRelativeTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_SetActorRelativeRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                NewRelativeRotation            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_SetActorRelativeRotation(const struct FRotator& NewRelativeRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeRotation");

	AEngine_Actor_K2_SetActorRelativeRotation_Params params;
	params.NewRelativeRotation = NewRelativeRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_SetActorRelativeLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewRelativeLocation            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_SetActorRelativeLocation(const struct FVector& NewRelativeLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorRelativeLocation");

	AEngine_Actor_K2_SetActorRelativeLocation_Params params;
	params.NewRelativeLocation = NewRelativeLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_SetActorLocationAndRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::K2_SetActorLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocationAndRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocationAndRotation");

	AEngine_Actor_K2_SetActorLocationAndRotation_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_SetActorLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::K2_SetActorLocation(const struct FVector& NewLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocation");

	AEngine_Actor_K2_SetActorLocation_Params params;
	params.NewLocation = NewLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_OnReset
// (Event, Public, BlueprintEvent)

void AEngine_Actor::K2_OnReset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnReset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnReset");

	AEngine_Actor_K2_OnReset_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_OnEndViewTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* PC                             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_OnEndViewTarget(class AEngine_PlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnEndViewTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnEndViewTarget");

	AEngine_Actor_K2_OnEndViewTarget_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_OnBecomeViewTarget
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* PC                             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_OnBecomeViewTarget(class AEngine_PlayerController* PC)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnBecomeViewTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnBecomeViewTarget");

	AEngine_Actor_K2_OnBecomeViewTarget_Params params;
	params.PC = PC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_GetRootComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_SceneComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_SceneComponent* AEngine_Actor::K2_GetRootComponent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetRootComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetRootComponent");

	AEngine_Actor_K2_GetRootComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_GetComponentsByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ComponentClass                 (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UEngine_ActorComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UEngine_ActorComponent*> AEngine_Actor::K2_GetComponentsByClass(class UClass* ComponentClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetComponentsByClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetComponentsByClass");

	AEngine_Actor_K2_GetComponentsByClass_Params params;
	params.ComponentClass = ComponentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_GetActorRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator AEngine_Actor::K2_GetActorRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorRotation");

	AEngine_Actor_K2_GetActorRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_GetActorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::K2_GetActorLocation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorLocation");

	AEngine_Actor_K2_GetActorLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.K2_DetachFromActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_EDetachmentRule LocationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EDetachmentRule RotationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EDetachmentRule ScaleRule                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_DetachFromActor(FEngine_Engine_EDetachmentRule LocationRule, FEngine_Engine_EDetachmentRule RotationRule, FEngine_Engine_EDetachmentRule ScaleRule)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DetachFromActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DetachFromActor");

	AEngine_Actor_K2_DetachFromActor_Params params;
	params.LocationRule = LocationRule;
	params.RotationRule = RotationRule;
	params.ScaleRule = ScaleRule;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_DestroyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ActorComponent*  Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void AEngine_Actor::K2_DestroyComponent(class UEngine_ActorComponent* Component)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyComponent");

	AEngine_Actor_K2_DestroyComponent_Params params;
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_DestroyActor
// (Native, Public, BlueprintCallable)

void AEngine_Actor::K2_DestroyActor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyActor");

	AEngine_Actor_K2_DestroyActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_AttachToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  Parent                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   SocketName                     (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule LocationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule RotationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule ScaleRule                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWeldSimulatedBodies           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AttachToComponent(class UEngine_SceneComponent* Parent, const struct FName& SocketName, FEngine_Engine_EAttachmentRule LocationRule, FEngine_Engine_EAttachmentRule RotationRule, FEngine_Engine_EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachToComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachToComponent");

	AEngine_Actor_K2_AttachToComponent_Params params;
	params.Parent = Parent;
	params.SocketName = SocketName;
	params.LocationRule = LocationRule;
	params.RotationRule = RotationRule;
	params.ScaleRule = ScaleRule;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_AttachToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           ParentActor                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   SocketName                     (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule LocationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule RotationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule ScaleRule                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWeldSimulatedBodies           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AttachToActor(class AEngine_Actor* ParentActor, const struct FName& SocketName, FEngine_Engine_EAttachmentRule LocationRule, FEngine_Engine_EAttachmentRule RotationRule, FEngine_Engine_EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachToActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachToActor");

	AEngine_Actor_K2_AttachToActor_Params params;
	params.ParentActor = ParentActor;
	params.SocketName = SocketName;
	params.LocationRule = LocationRule;
	params.RotationRule = RotationRule;
	params.ScaleRule = ScaleRule;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_AttachRootComponentToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           InParentActor                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> AttachLocationType             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWeldSimulatedBodies           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AttachRootComponentToActor(class AEngine_Actor* InParentActor, const struct FName& InSocketName, TEnumAsByte<FEngine_Engine_EAttachLocation> AttachLocationType, bool bWeldSimulatedBodies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentToActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentToActor");

	AEngine_Actor_K2_AttachRootComponentToActor_Params params;
	params.InParentActor = InParentActor;
	params.InSocketName = InSocketName;
	params.AttachLocationType = AttachLocationType;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_AttachRootComponentTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  InParent                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> AttachLocationType             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWeldSimulatedBodies           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AttachRootComponentTo(class UEngine_SceneComponent* InParent, const struct FName& InSocketName, TEnumAsByte<FEngine_Engine_EAttachLocation> AttachLocationType, bool bWeldSimulatedBodies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentTo");

	AEngine_Actor_K2_AttachRootComponentTo_Params params;
	params.InParent = InParent;
	params.InSocketName = InSocketName;
	params.AttachLocationType = AttachLocationType;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.K2_AddActorWorldTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              DeltaTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AddActorWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldTransform");

	AEngine_Actor_K2_AddActorWorldTransform_Params params;
	params.DeltaTransform = DeltaTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_AddActorWorldRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                DeltaRotation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AddActorWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldRotation");

	AEngine_Actor_K2_AddActorWorldRotation_Params params;
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_AddActorWorldOffset
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 DeltaLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AddActorWorldOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorWorldOffset");

	AEngine_Actor_K2_AddActorWorldOffset_Params params;
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_AddActorLocalTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              NewTransform                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AddActorLocalTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalTransform");

	AEngine_Actor_K2_AddActorLocalTransform_Params params;
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_AddActorLocalRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                DeltaRotation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AddActorLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalRotation");

	AEngine_Actor_K2_AddActorLocalRotation_Params params;
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.K2_AddActorLocalOffset
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 DeltaLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::K2_AddActorLocalOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AddActorLocalOffset");

	AEngine_Actor_K2_AddActorLocalOffset_Params params;
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.Actor.IsOverlappingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           Other                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::IsOverlappingActor(class AEngine_Actor* Other)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsOverlappingActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsOverlappingActor");

	AEngine_Actor_IsOverlappingActor_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsChildActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::IsChildActor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsChildActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsChildActor");

	AEngine_Actor_IsChildActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsActorTickEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::IsActorTickEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsActorTickEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsActorTickEnabled");

	AEngine_Actor_IsActorTickEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.IsActorBeingDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::IsActorBeingDestroyed()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsActorBeingDestroyed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsActorBeingDestroyed");

	AEngine_Actor_IsActorBeingDestroyed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.HasAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::HasAuthority()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.HasAuthority");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.HasAuthority");

	AEngine_Actor_HasAuthority_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetVerticalDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           OtherActor                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetVerticalDistanceTo(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVerticalDistanceTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVerticalDistanceTo");

	AEngine_Actor_GetVerticalDistanceTo_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::GetVelocity()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVelocity");

	AEngine_Actor_GetVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData)

struct FTransform AEngine_Actor::GetTransform()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTransform");

	AEngine_Actor_GetTransform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::GetTickableWhenPaused()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTickableWhenPaused");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTickableWhenPaused");

	AEngine_Actor_GetTickableWhenPaused_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetSquaredDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           OtherActor                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetSquaredDistanceTo(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetSquaredDistanceTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetSquaredDistanceTo");

	AEngine_Actor_GetSquaredDistanceTo_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetRemoteRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ENetRole> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_ENetRole> AEngine_Actor::GetRemoteRole()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetRemoteRole");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetRemoteRole");

	AEngine_Actor_GetRemoteRole_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetParentComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_ChildActorComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_ChildActorComponent* AEngine_Actor::GetParentComponent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetParentComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetParentComponent");

	AEngine_Actor_GetParentComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_Actor::GetParentActor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetParentActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetParentActor");

	AEngine_Actor_GetParentActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_Actor::GetOwner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOwner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOwner");

	AEngine_Actor_GetOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetOverlappingComponents
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UEngine_PrimitiveComponent*> OverlappingComponents          (Parm, OutParm, ZeroConstructor)

void AEngine_Actor::GetOverlappingComponents(TArray<class UEngine_PrimitiveComponent*>* OverlappingComponents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingComponents");

	AEngine_Actor_GetOverlappingComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OverlappingComponents != nullptr)
		*OverlappingComponents = params.OverlappingComponents;
}


// Function Engine.Actor.GetOverlappingActors
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AEngine_Actor*>   OverlappingActors              (Parm, OutParm, ZeroConstructor)
// class UClass*                  ClassFilter                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::GetOverlappingActors(class UClass* ClassFilter, TArray<class AEngine_Actor*>* OverlappingActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingActors");

	AEngine_Actor_GetOverlappingActors_Params params;
	params.ClassFilter = ClassFilter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OverlappingActors != nullptr)
		*OverlappingActors = params.OverlappingActors;
}


// Function Engine.Actor.GetLocalRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ENetRole> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_ENetRole> AEngine_Actor::GetLocalRole()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetLocalRole");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetLocalRole");

	AEngine_Actor_GetLocalRole_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetLifeSpan
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetLifeSpan()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetLifeSpan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetLifeSpan");

	AEngine_Actor_GetLifeSpan_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetInstigatorController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Controller*      ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Controller* AEngine_Actor::GetInstigatorController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigatorController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigatorController");

	AEngine_Actor_GetInstigatorController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* AEngine_Actor::GetInstigator()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigator");

	AEngine_Actor_GetInstigator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetInputVectorAxisValue
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          InputAxisKey                   (ConstParm, Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::GetInputVectorAxisValue(const struct FInputCore_Key& InputAxisKey)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputVectorAxisValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputVectorAxisValue");

	AEngine_Actor_GetInputVectorAxisValue_Params params;
	params.InputAxisKey = InputAxisKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetInputAxisValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InputAxisName                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetInputAxisValue(const struct FName& InputAxisName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisValue");

	AEngine_Actor_GetInputAxisValue_Params params;
	params.InputAxisName = InputAxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetInputAxisKeyValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          InputAxisKey                   (ConstParm, Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetInputAxisKeyValue(const struct FInputCore_Key& InputAxisKey)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisKeyValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisKeyValue");

	AEngine_Actor_GetInputAxisKeyValue_Params params;
	params.InputAxisKey = InputAxisKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetHorizontalDotProductTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           OtherActor                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetHorizontalDotProductTo(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDotProductTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDotProductTo");

	AEngine_Actor_GetHorizontalDotProductTo_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetHorizontalDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           OtherActor                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetHorizontalDistanceTo(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDistanceTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDistanceTo");

	AEngine_Actor_GetHorizontalDistanceTo_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetGameTimeSinceCreation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetGameTimeSinceCreation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetGameTimeSinceCreation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetGameTimeSinceCreation");

	AEngine_Actor_GetGameTimeSinceCreation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetDotProductTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           OtherActor                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetDotProductTo(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDotProductTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDotProductTo");

	AEngine_Actor_GetDotProductTo_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetDistanceTo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           OtherActor                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetDistanceTo(class AEngine_Actor* OtherActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDistanceTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDistanceTo");

	AEngine_Actor_GetDistanceTo_Params params;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetComponentsByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ComponentClass                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UEngine_ActorComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UEngine_ActorComponent*> AEngine_Actor::GetComponentsByTag(class UClass* ComponentClass, const struct FName& Tag)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByTag");

	AEngine_Actor_GetComponentsByTag_Params params;
	params.ComponentClass = ComponentClass;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetComponentsByInterface
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  Interface                      (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UEngine_ActorComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UEngine_ActorComponent*> AEngine_Actor::GetComponentsByInterface(class UClass* Interface)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByInterface");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByInterface");

	AEngine_Actor_GetComponentsByInterface_Params params;
	params.Interface = Interface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetComponentByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  ComponentClass                 (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ActorComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_ActorComponent* AEngine_Actor::GetComponentByClass(class UClass* ComponentClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentByClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentByClass");

	AEngine_Actor_GetComponentByClass_Params params;
	params.ComponentClass = ComponentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetAttachParentSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName AEngine_Actor::GetAttachParentSocketName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachParentSocketName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachParentSocketName");

	AEngine_Actor_GetAttachParentSocketName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetAttachParentActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_Actor::GetAttachParentActor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachParentActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachParentActor");

	AEngine_Actor_GetAttachParentActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetAttachedActors
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)
// bool                           bResetArray                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::GetAttachedActors(bool bResetArray, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachedActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachedActors");

	AEngine_Actor_GetAttachedActors_Params params;
	params.bResetArray = bResetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;
}


// Function Engine.Actor.GetAllChildActors
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AEngine_Actor*>   ChildActors                    (Parm, OutParm, ZeroConstructor)
// bool                           bIncludeDescendants            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::GetAllChildActors(bool bIncludeDescendants, TArray<class AEngine_Actor*>* ChildActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAllChildActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAllChildActors");

	AEngine_Actor_GetAllChildActors_Params params;
	params.bIncludeDescendants = bIncludeDescendants;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ChildActors != nullptr)
		*ChildActors = params.ChildActors;
}


// Function Engine.Actor.GetActorUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::GetActorUpVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorUpVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorUpVector");

	AEngine_Actor_GetActorUpVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorTimeDilation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetActorTimeDilation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTimeDilation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTimeDilation");

	AEngine_Actor_GetActorTimeDilation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorTickInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Actor::GetActorTickInterval()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTickInterval");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTickInterval");

	AEngine_Actor_GetActorTickInterval_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::GetActorScale3D()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorScale3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorScale3D");

	AEngine_Actor_GetActorScale3D_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorRightVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::GetActorRightVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRightVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRightVector");

	AEngine_Actor_GetActorRightVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::GetActorRelativeScale3D()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRelativeScale3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRelativeScale3D");

	AEngine_Actor_GetActorRelativeScale3D_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Actor::GetActorForwardVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorForwardVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorForwardVector");

	AEngine_Actor_GetActorForwardVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorEyesViewPoint
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 OutLocation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                OutRotation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::GetActorEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEyesViewPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEyesViewPoint");

	AEngine_Actor_GetActorEyesViewPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutLocation != nullptr)
		*OutLocation = params.OutLocation;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;
}


// Function Engine.Actor.GetActorEnableCollision
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::GetActorEnableCollision()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEnableCollision");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEnableCollision");

	AEngine_Actor_GetActorEnableCollision_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.GetActorBounds
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           bOnlyCollidingComponents       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::GetActorBounds(bool bOnlyCollidingComponents, struct FVector* Origin, struct FVector* BoxExtent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorBounds");

	AEngine_Actor_GetActorBounds_Params params;
	params.bOnlyCollidingComponents = bOnlyCollidingComponents;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Origin != nullptr)
		*Origin = params.Origin;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;
}


// Function Engine.Actor.ForceNetUpdate
// (Native, Public, BlueprintCallable)

void AEngine_Actor::ForceNetUpdate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ForceNetUpdate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ForceNetUpdate");

	AEngine_Actor_ForceNetUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.FlushNetDormancy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AEngine_Actor::FlushNetDormancy()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.FlushNetDormancy");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.FlushNetDormancy");

	AEngine_Actor_FlushNetDormancy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.EnableInput
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerController* PlayerController               (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::EnableInput(class AEngine_PlayerController* PlayerController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.EnableInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.EnableInput");

	AEngine_Actor_EnableInput_Params params;
	params.PlayerController = PlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DisableInput
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerController* PlayerController               (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::DisableInput(class AEngine_PlayerController* PlayerController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.DisableInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.DisableInput");

	AEngine_Actor_DisableInput_Params params;
	params.PlayerController = PlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.DetachRootComponentFromParent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bMaintainWorldPosition         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::DetachRootComponentFromParent(bool bMaintainWorldPosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.DetachRootComponentFromParent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.DetachRootComponentFromParent");

	AEngine_Actor_DetachRootComponentFromParent_Params params;
	params.bMaintainWorldPosition = bMaintainWorldPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.AddTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ActorComponent*  PrerequisiteComponent          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void AEngine_Actor::AddTickPrerequisiteComponent(class UEngine_ActorComponent* PrerequisiteComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteComponent");

	AEngine_Actor_AddTickPrerequisiteComponent_Params params;
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.AddTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           PrerequisiteActor              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Actor::AddTickPrerequisiteActor(class AEngine_Actor* PrerequisiteActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteActor");

	AEngine_Actor_AddTickPrerequisiteActor_Params params;
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Actor.AddComponent
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   TemplateName                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bManualAttachment              (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              RelativeTransform              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// class UObject*                 ComponentTemplateContext       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ActorComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_ActorComponent* AEngine_Actor::AddComponent(const struct FName& TemplateName, bool bManualAttachment, const struct FTransform& RelativeTransform, class UObject* ComponentTemplateContext)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddComponent");

	AEngine_Actor_AddComponent_Params params;
	params.TemplateName = TemplateName;
	params.bManualAttachment = bManualAttachment;
	params.RelativeTransform = RelativeTransform;
	params.ComponentTemplateContext = ComponentTemplateContext;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Actor.ActorHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Actor::ActorHasTag(const struct FName& Tag)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorHasTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorHasTag");

	AEngine_Actor_ActorHasTag_Params params;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.ToggleActive
// (Native, Public, BlueprintCallable)

void UEngine_ActorComponent::ToggleActive()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ToggleActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ToggleActive");

	UEngine_ActorComponent_ToggleActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetTickGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ETickingGroup> NewTickGroup                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::SetTickGroup(TEnumAsByte<FEngine_Engine_ETickingGroup> NewTickGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickGroup");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickGroup");

	UEngine_ActorComponent_SetTickGroup_Params params;
	params.NewTickGroup = NewTickGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetTickableWhenPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bTickableWhenPaused            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::SetTickableWhenPaused(bool bTickableWhenPaused)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickableWhenPaused");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetTickableWhenPaused");

	UEngine_ActorComponent_SetTickableWhenPaused_Params params;
	params.bTickableWhenPaused = bTickableWhenPaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetIsReplicated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ShouldReplicate                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::SetIsReplicated(bool ShouldReplicate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetIsReplicated");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetIsReplicated");

	UEngine_ActorComponent_SetIsReplicated_Params params;
	params.ShouldReplicate = ShouldReplicate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetComponentTickInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          TickInterval                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::SetComponentTickInterval(float TickInterval)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickInterval");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickInterval");

	UEngine_ActorComponent_SetComponentTickInterval_Params params;
	params.TickInterval = TickInterval;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetComponentTickEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::SetComponentTickEnabled(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickEnabled");

	UEngine_ActorComponent_SetComponentTickEnabled_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetAutoActivate
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewAutoActivate               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::SetAutoActivate(bool bNewAutoActivate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetAutoActivate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetAutoActivate");

	UEngine_ActorComponent_SetAutoActivate_Params params;
	params.bNewAutoActivate = bNewAutoActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.SetActive
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewActive                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bReset                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::SetActive(bool bNewActive, bool bReset)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetActive");

	UEngine_ActorComponent_SetActive_Params params;
	params.bNewActive = bNewActive;
	params.bReset = bReset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.RemoveTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ActorComponent*  PrerequisiteComponent          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_ActorComponent::RemoveTickPrerequisiteComponent(class UEngine_ActorComponent* PrerequisiteComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteComponent");

	UEngine_ActorComponent_RemoveTickPrerequisiteComponent_Params params;
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.RemoveTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           PrerequisiteActor              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::RemoveTickPrerequisiteActor(class AEngine_Actor* PrerequisiteActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteActor");

	UEngine_ActorComponent_RemoveTickPrerequisiteActor_Params params;
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          DeltaSeconds                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::ReceiveTick(float DeltaSeconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveTick");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveTick");

	UEngine_ActorComponent_ReceiveTick_Params params;
	params.DeltaSeconds = DeltaSeconds;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.ReceiveEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FEngine_Engine_EEndPlayReason> EndPlayReason                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::ReceiveEndPlay(TEnumAsByte<FEngine_Engine_EEndPlayReason> EndPlayReason)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveEndPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveEndPlay");

	UEngine_ActorComponent_ReceiveEndPlay_Params params;
	params.EndPlayReason = EndPlayReason;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UEngine_ActorComponent::ReceiveBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveBeginPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReceiveBeginPlay");

	UEngine_ActorComponent_ReceiveBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.OnRep_IsActive
// (Native, Public)

void UEngine_ActorComponent::OnRep_IsActive()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.OnRep_IsActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.OnRep_IsActive");

	UEngine_ActorComponent_OnRep_IsActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.K2_DestroyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::K2_DestroyComponent(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.K2_DestroyComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.K2_DestroyComponent");

	UEngine_ActorComponent_K2_DestroyComponent_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.IsComponentTickEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ActorComponent::IsComponentTickEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsComponentTickEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsComponentTickEnabled");

	UEngine_ActorComponent_IsComponentTickEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.IsBeingDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ActorComponent::IsBeingDestroyed()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsBeingDestroyed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsBeingDestroyed");

	UEngine_ActorComponent_IsBeingDestroyed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ActorComponent::IsActive()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsActive");

	UEngine_ActorComponent_IsActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_ActorComponent::GetOwner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetOwner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetOwner");

	UEngine_ActorComponent_GetOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.GetComponentTickInterval
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_ActorComponent::GetComponentTickInterval()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetComponentTickInterval");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetComponentTickInterval");

	UEngine_ActorComponent_GetComponentTickInterval_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.Deactivate
// (Native, Public, BlueprintCallable)

void UEngine_ActorComponent::Deactivate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Deactivate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Deactivate");

	UEngine_ActorComponent_Deactivate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.ComponentHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ActorComponent::ComponentHasTag(const struct FName& Tag)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ComponentHasTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ComponentHasTag");

	UEngine_ActorComponent_ComponentHasTag_Params params;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ActorComponent.AddTickPrerequisiteComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ActorComponent*  PrerequisiteComponent          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_ActorComponent::AddTickPrerequisiteComponent(class UEngine_ActorComponent* PrerequisiteComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteComponent");

	UEngine_ActorComponent_AddTickPrerequisiteComponent_Params params;
	params.PrerequisiteComponent = PrerequisiteComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.AddTickPrerequisiteActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           PrerequisiteActor              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::AddTickPrerequisiteActor(class AEngine_Actor* PrerequisiteActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteActor");

	UEngine_ActorComponent_AddTickPrerequisiteActor_Params params;
	params.PrerequisiteActor = PrerequisiteActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ActorComponent.Activate
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bReset                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ActorComponent::Activate(bool bReset)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Activate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Activate");

	UEngine_ActorComponent_Activate_Params params;
	params.bReset = bReset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.ToggleVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bPropagateToChildren           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::ToggleVisibility(bool bPropagateToChildren)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ToggleVisibility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ToggleVisibility");

	UEngine_SceneComponent_ToggleVisibility_Params params;
	params.bPropagateToChildren = bPropagateToChildren;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.SnapTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  InParent                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::SnapTo(class UEngine_SceneComponent* InParent, const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SnapTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SnapTo");

	UEngine_SceneComponent_SnapTo_Params params;
	params.InParent = InParent;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.SetWorldScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewScale                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::SetWorldScale3D(const struct FVector& NewScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldScale3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldScale3D");

	UEngine_SceneComponent_SetWorldScale3D_Params params;
	params.NewScale = NewScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.SetVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewVisibility                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPropagateToChildren           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetVisibility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetVisibility");

	UEngine_SceneComponent_SetVisibility_Params params;
	params.bNewVisibility = bNewVisibility;
	params.bPropagateToChildren = bPropagateToChildren;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.SetShouldUpdatePhysicsVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInShouldUpdatePhysicsVolume   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::SetShouldUpdatePhysicsVolume(bool bInShouldUpdatePhysicsVolume)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetShouldUpdatePhysicsVolume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetShouldUpdatePhysicsVolume");

	UEngine_SceneComponent_SetShouldUpdatePhysicsVolume_Params params;
	params.bInShouldUpdatePhysicsVolume = bInShouldUpdatePhysicsVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.SetRelativeScale3D
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewScale3D                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::SetRelativeScale3D(const struct FVector& NewScale3D)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeScale3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeScale3D");

	UEngine_SceneComponent_SetRelativeScale3D_Params params;
	params.NewScale3D = NewScale3D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.SetMobility
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EComponentMobility> NewMobility                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::SetMobility(TEnumAsByte<FEngine_Engine_EComponentMobility> NewMobility)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetMobility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetMobility");

	UEngine_SceneComponent_SetMobility_Params params;
	params.NewMobility = NewMobility;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.SetHiddenInGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           NewHidden                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPropagateToChildren           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::SetHiddenInGame(bool NewHidden, bool bPropagateToChildren)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetHiddenInGame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetHiddenInGame");

	UEngine_SceneComponent_SetHiddenInGame_Params params;
	params.NewHidden = NewHidden;
	params.bPropagateToChildren = bPropagateToChildren;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.SetAbsolute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewAbsoluteLocation           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNewAbsoluteRotation           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNewAbsoluteScale              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetAbsolute");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetAbsolute");

	UEngine_SceneComponent_SetAbsolute_Params params;
	params.bNewAbsoluteLocation = bNewAbsoluteLocation;
	params.bNewAbsoluteRotation = bNewAbsoluteRotation;
	params.bNewAbsoluteScale = bNewAbsoluteScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.ResetRelativeTransform
// (Final, Native, Public, BlueprintCallable)

void UEngine_SceneComponent::ResetRelativeTransform()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ResetRelativeTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ResetRelativeTransform");

	UEngine_SceneComponent_ResetRelativeTransform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.OnRep_Visibility
// (Final, Native, Private)
// Parameters:
// bool                           OldValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::OnRep_Visibility(bool OldValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Visibility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Visibility");

	UEngine_SceneComponent_OnRep_Visibility_Params params;
	params.OldValue = OldValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.OnRep_Transform
// (Final, Native, Private)

void UEngine_SceneComponent::OnRep_Transform()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Transform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Transform");

	UEngine_SceneComponent_OnRep_Transform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.OnRep_AttachSocketName
// (Final, Native, Private)

void UEngine_SceneComponent::OnRep_AttachSocketName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachSocketName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachSocketName");

	UEngine_SceneComponent_OnRep_AttachSocketName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.OnRep_AttachParent
// (Final, Native, Private)

void UEngine_SceneComponent::OnRep_AttachParent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachParent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachParent");

	UEngine_SceneComponent_OnRep_AttachParent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.OnRep_AttachChildren
// (Final, Native, Private)

void UEngine_SceneComponent::OnRep_AttachChildren()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachChildren");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_AttachChildren");

	UEngine_SceneComponent_OnRep_AttachChildren_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.K2_SetWorldTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              NewTransform                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetWorldTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldTransform");

	UEngine_SceneComponent_K2_SetWorldTransform_Params params;
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_SetWorldRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetWorldRotation(const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldRotation");

	UEngine_SceneComponent_K2_SetWorldRotation_Params params;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_SetWorldLocationAndRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetWorldLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocationAndRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocationAndRotation");

	UEngine_SceneComponent_K2_SetWorldLocationAndRotation_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_SetWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetWorldLocation(const struct FVector& NewLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetWorldLocation");

	UEngine_SceneComponent_K2_SetWorldLocation_Params params;
	params.NewLocation = NewLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_SetRelativeTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              NewTransform                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetRelativeTransform(const struct FTransform& NewTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeTransform");

	UEngine_SceneComponent_K2_SetRelativeTransform_Params params;
	params.NewTransform = NewTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_SetRelativeRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetRelativeRotation(const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeRotation");

	UEngine_SceneComponent_K2_SetRelativeRotation_Params params;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetRelativeLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation");

	UEngine_SceneComponent_K2_SetRelativeLocationAndRotation_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_SetRelativeLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_SetRelativeLocation(const struct FVector& NewLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_SetRelativeLocation");

	UEngine_SceneComponent_K2_SetRelativeLocation_Params params;
	params.NewLocation = NewLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_GetComponentToWorld
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SceneComponent::K2_GetComponentToWorld()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentToWorld");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentToWorld");

	UEngine_SceneComponent_K2_GetComponentToWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.K2_GetComponentScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SceneComponent::K2_GetComponentScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentScale");

	UEngine_SceneComponent_K2_GetComponentScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.K2_GetComponentRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SceneComponent::K2_GetComponentRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentRotation");

	UEngine_SceneComponent_K2_GetComponentRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.K2_GetComponentLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SceneComponent::K2_GetComponentLocation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentLocation");

	UEngine_SceneComponent_K2_GetComponentLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.K2_DetachFromComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_EDetachmentRule LocationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EDetachmentRule RotationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EDetachmentRule ScaleRule                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCallModify                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_DetachFromComponent(FEngine_Engine_EDetachmentRule LocationRule, FEngine_Engine_EDetachmentRule RotationRule, FEngine_Engine_EDetachmentRule ScaleRule, bool bCallModify)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_DetachFromComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_DetachFromComponent");

	UEngine_SceneComponent_K2_DetachFromComponent_Params params;
	params.LocationRule = LocationRule;
	params.RotationRule = RotationRule;
	params.ScaleRule = ScaleRule;
	params.bCallModify = bCallModify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneComponent.K2_AttachToComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  Parent                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   SocketName                     (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule LocationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule RotationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule ScaleRule                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWeldSimulatedBodies           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::K2_AttachToComponent(class UEngine_SceneComponent* Parent, const struct FName& SocketName, FEngine_Engine_EAttachmentRule LocationRule, FEngine_Engine_EAttachmentRule RotationRule, FEngine_Engine_EAttachmentRule ScaleRule, bool bWeldSimulatedBodies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachToComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachToComponent");

	UEngine_SceneComponent_K2_AttachToComponent_Params params;
	params.Parent = Parent;
	params.SocketName = SocketName;
	params.LocationRule = LocationRule;
	params.RotationRule = RotationRule;
	params.ScaleRule = ScaleRule;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.K2_AttachTo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  InParent                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> AttachType                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bWeldSimulatedBodies           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::K2_AttachTo(class UEngine_SceneComponent* InParent, const struct FName& InSocketName, TEnumAsByte<FEngine_Engine_EAttachLocation> AttachType, bool bWeldSimulatedBodies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachTo");

	UEngine_SceneComponent_K2_AttachTo_Params params;
	params.InParent = InParent;
	params.InSocketName = InSocketName;
	params.AttachType = AttachType;
	params.bWeldSimulatedBodies = bWeldSimulatedBodies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.K2_AddWorldTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              DeltaTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddWorldTransform(const struct FTransform& DeltaTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldTransform");

	UEngine_SceneComponent_K2_AddWorldTransform_Params params;
	params.DeltaTransform = DeltaTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_AddWorldRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                DeltaRotation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddWorldRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldRotation");

	UEngine_SceneComponent_K2_AddWorldRotation_Params params;
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_AddWorldOffset
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 DeltaLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddWorldOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddWorldOffset");

	UEngine_SceneComponent_K2_AddWorldOffset_Params params;
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_AddRelativeRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                DeltaRotation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddRelativeRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeRotation");

	UEngine_SceneComponent_K2_AddRelativeRotation_Params params;
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_AddRelativeLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 DeltaLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddRelativeLocation(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddRelativeLocation");

	UEngine_SceneComponent_K2_AddRelativeLocation_Params params;
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_AddLocalTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              DeltaTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddLocalTransform(const struct FTransform& DeltaTransform, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalTransform");

	UEngine_SceneComponent_K2_AddLocalTransform_Params params;
	params.DeltaTransform = DeltaTransform;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_AddLocalRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                DeltaRotation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddLocalRotation(const struct FRotator& DeltaRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalRotation");

	UEngine_SceneComponent_K2_AddLocalRotation_Params params;
	params.DeltaRotation = DeltaRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.K2_AddLocalOffset
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 DeltaLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepHitResult                 (Parm, OutParm, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::K2_AddLocalOffset(const struct FVector& DeltaLocation, bool bSweep, bool bTeleport, struct FEngine_HitResult* SweepHitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AddLocalOffset");

	UEngine_SceneComponent_K2_AddLocalOffset_Params params;
	params.DeltaLocation = DeltaLocation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SweepHitResult != nullptr)
		*SweepHitResult = params.SweepHitResult;
}


// Function Engine.SceneComponent.IsVisible
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::IsVisible()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsVisible");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsVisible");

	UEngine_SceneComponent_IsVisible_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.IsSimulatingPhysics
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::IsSimulatingPhysics(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsSimulatingPhysics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsSimulatingPhysics");

	UEngine_SceneComponent_IsSimulatingPhysics_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.IsAnySimulatingPhysics
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::IsAnySimulatingPhysics()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsAnySimulatingPhysics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsAnySimulatingPhysics");

	UEngine_SceneComponent_IsAnySimulatingPhysics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SceneComponent::GetUpVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetUpVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetUpVector");

	UEngine_SceneComponent_GetUpVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketTransform
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ERelativeTransformSpace> TransformSpace                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SceneComponent::GetSocketTransform(const struct FName& InSocketName, TEnumAsByte<FEngine_Engine_ERelativeTransformSpace> TransformSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketTransform");

	UEngine_SceneComponent_GetSocketTransform_Params params;
	params.InSocketName = InSocketName;
	params.TransformSpace = TransformSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SceneComponent::GetSocketRotation(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketRotation");

	UEngine_SceneComponent_GetSocketRotation_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketQuaternion
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_SceneComponent::GetSocketQuaternion(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketQuaternion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketQuaternion");

	UEngine_SceneComponent_GetSocketQuaternion_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetSocketLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SceneComponent::GetSocketLocation(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketLocation");

	UEngine_SceneComponent_GetSocketLocation_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetShouldUpdatePhysicsVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::GetShouldUpdatePhysicsVolume()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetShouldUpdatePhysicsVolume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetShouldUpdatePhysicsVolume");

	UEngine_SceneComponent_GetShouldUpdatePhysicsVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetRightVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SceneComponent::GetRightVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRightVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRightVector");

	UEngine_SceneComponent_GetRightVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetRelativeTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SceneComponent::GetRelativeTransform()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRelativeTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRelativeTransform");

	UEngine_SceneComponent_GetRelativeTransform_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetPhysicsVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_PhysicsVolume*   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PhysicsVolume* UEngine_SceneComponent::GetPhysicsVolume()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetPhysicsVolume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetPhysicsVolume");

	UEngine_SceneComponent_GetPhysicsVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetParentComponents
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UEngine_SceneComponent*> Parents                        (Parm, OutParm, ZeroConstructor)

void UEngine_SceneComponent::GetParentComponents(TArray<class UEngine_SceneComponent*>* Parents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetParentComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetParentComponents");

	UEngine_SceneComponent_GetParentComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Parents != nullptr)
		*Parents = params.Parents;
}


// Function Engine.SceneComponent.GetNumChildrenComponents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SceneComponent::GetNumChildrenComponents()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetNumChildrenComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetNumChildrenComponents");

	UEngine_SceneComponent_GetNumChildrenComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetForwardVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SceneComponent::GetForwardVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetForwardVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetForwardVector");

	UEngine_SceneComponent_GetForwardVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetComponentVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SceneComponent::GetComponentVelocity()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetComponentVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetComponentVelocity");

	UEngine_SceneComponent_GetComponentVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetChildrenComponents
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           bIncludeAllDescendants         (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UEngine_SceneComponent*> Children                       (Parm, OutParm, ZeroConstructor)

void UEngine_SceneComponent::GetChildrenComponents(bool bIncludeAllDescendants, TArray<class UEngine_SceneComponent*>* Children)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildrenComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildrenComponents");

	UEngine_SceneComponent_GetChildrenComponents_Params params;
	params.bIncludeAllDescendants = bIncludeAllDescendants;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Children != nullptr)
		*Children = params.Children;
}


// Function Engine.SceneComponent.GetChildComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ChildIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SceneComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_SceneComponent* UEngine_SceneComponent::GetChildComponent(int ChildIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildComponent");

	UEngine_SceneComponent_GetChildComponent_Params params;
	params.ChildIndex = ChildIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetAttachSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_SceneComponent::GetAttachSocketName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachSocketName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachSocketName");

	UEngine_SceneComponent_GetAttachSocketName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetAttachParent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_SceneComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_SceneComponent* UEngine_SceneComponent::GetAttachParent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachParent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachParent");

	UEngine_SceneComponent_GetAttachParent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.GetAllSocketNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FName>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FName> UEngine_SceneComponent::GetAllSocketNames()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAllSocketNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAllSocketNames");

	UEngine_SceneComponent_GetAllSocketNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.DoesSocketExist
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SceneComponent::DoesSocketExist(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DoesSocketExist");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DoesSocketExist");

	UEngine_SceneComponent_DoesSocketExist_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneComponent.DetachFromParent
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bMaintainWorldPosition         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCallModify                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneComponent::DetachFromParent(bool bMaintainWorldPosition, bool bCallModify)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DetachFromParent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DetachFromParent");

	UEngine_SceneComponent_DetachFromParent_Params params;
	params.bMaintainWorldPosition = bMaintainWorldPosition;
	params.bCallModify = bCallModify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.WakeRigidBody
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::WakeRigidBody(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeRigidBody");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeRigidBody");

	UEngine_PrimitiveComponent_WakeRigidBody_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.WakeAllRigidBodies
// (Native, Public, BlueprintCallable)

void UEngine_PrimitiveComponent::WakeAllRigidBodies()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeAllRigidBodies");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeAllRigidBodies");

	UEngine_PrimitiveComponent_WakeAllRigidBodies_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetWalkableSlopeOverride
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_WalkableSlopeOverride NewOverride                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_PrimitiveComponent::SetWalkableSlopeOverride(const struct FEngine_WalkableSlopeOverride& NewOverride)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetWalkableSlopeOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetWalkableSlopeOverride");

	UEngine_PrimitiveComponent_SetWalkableSlopeOverride_Params params;
	params.NewOverride = NewOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetUseCCD
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           InUseCCD                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetUseCCD(bool InUseCCD, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetUseCCD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetUseCCD");

	UEngine_PrimitiveComponent_SetUseCCD_Params params;
	params.InUseCCD = InUseCCD;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetTranslucentSortPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            NewTranslucentSortPriority     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetTranslucentSortPriority(int NewTranslucentSortPriority)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetTranslucentSortPriority");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetTranslucentSortPriority");

	UEngine_PrimitiveComponent_SetTranslucentSortPriority_Params params;
	params.NewTranslucentSortPriority = NewTranslucentSortPriority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetSingleSampleShadowFromStationaryLights
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewSingleSampleShadowFromStationaryLights (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSingleSampleShadowFromStationaryLights");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSingleSampleShadowFromStationaryLights");

	UEngine_PrimitiveComponent_SetSingleSampleShadowFromStationaryLights_Params params;
	params.bNewSingleSampleShadowFromStationaryLights = bNewSingleSampleShadowFromStationaryLights;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetSimulatePhysics
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bSimulate                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetSimulatePhysics(bool bSimulate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSimulatePhysics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSimulatePhysics");

	UEngine_PrimitiveComponent_SetSimulatePhysics_Params params;
	params.bSimulate = bSimulate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRenderInMainPass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bValue                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetRenderInMainPass(bool bValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderInMainPass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderInMainPass");

	UEngine_PrimitiveComponent_SetRenderInMainPass_Params params;
	params.bValue = bValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetRenderCustomDepth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bValue                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetRenderCustomDepth(bool bValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderCustomDepth");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderCustomDepth");

	UEngine_PrimitiveComponent_SetRenderCustomDepth_Params params;
	params.bValue = bValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetReceivesDecals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewReceivesDecals             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetReceivesDecals(bool bNewReceivesDecals)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetReceivesDecals");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetReceivesDecals");

	UEngine_PrimitiveComponent_SetReceivesDecals_Params params;
	params.bNewReceivesDecals = bNewReceivesDecals;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysMaterialOverride
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_PhysicalMaterial* NewPhysMaterial                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysMaterialOverride(class UEngine_PhysicalMaterial* NewPhysMaterial)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysMaterialOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysMaterialOverride");

	UEngine_PrimitiveComponent_SetPhysMaterialOverride_Params params;
	params.NewPhysMaterial = NewPhysMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInRadians
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewMaxAngVel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysicsMaxAngularVelocityInRadians(float NewMaxAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInRadians");

	UEngine_PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians_Params params;
	params.NewMaxAngVel = NewMaxAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInDegrees
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewMaxAngVel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysicsMaxAngularVelocityInDegrees(float NewMaxAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInDegrees");

	UEngine_PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees_Params params;
	params.NewMaxAngVel = NewMaxAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewMaxAngVel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity");

	UEngine_PrimitiveComponent_SetPhysicsMaxAngularVelocity_Params params;
	params.NewMaxAngVel = NewMaxAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewVel                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity");

	UEngine_PrimitiveComponent_SetPhysicsLinearVelocity_Params params;
	params.NewVel = NewVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewAngVel                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysicsAngularVelocityInRadians(const struct FVector& NewAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInRadians");

	UEngine_PrimitiveComponent_SetPhysicsAngularVelocityInRadians_Params params;
	params.NewAngVel = NewAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewAngVel                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysicsAngularVelocityInDegrees(const struct FVector& NewAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInDegrees");

	UEngine_PrimitiveComponent_SetPhysicsAngularVelocityInDegrees_Params params;
	params.NewAngVel = NewAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewAngVel                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetPhysicsAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity");

	UEngine_PrimitiveComponent_SetPhysicsAngularVelocity_Params params;
	params.NewAngVel = NewAngVel;
	params.bAddToCurrent = bAddToCurrent;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetOwnerNoSee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewOwnerNoSee                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOwnerNoSee");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOwnerNoSee");

	UEngine_PrimitiveComponent_SetOwnerNoSee_Params params;
	params.bNewOwnerNoSee = bNewOwnerNoSee;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetOnlyOwnerSee
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewOnlyOwnerSee               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOnlyOwnerSee");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOnlyOwnerSee");

	UEngine_PrimitiveComponent_SetOnlyOwnerSee_Params params;
	params.bNewOnlyOwnerSee = bNewOnlyOwnerSee;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewNotifyRigidBodyCollision   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision");

	UEngine_PrimitiveComponent_SetNotifyRigidBodyCollision_Params params;
	params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetMaterialByName
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   MaterialSlotName               (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetMaterialByName(const struct FName& MaterialSlotName, class UEngine_MaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterialByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterialByName");

	UEngine_PrimitiveComponent_SetMaterialByName_Params params;
	params.MaterialSlotName = MaterialSlotName;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            ElementIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetMaterial(int ElementIndex, class UEngine_MaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterial");

	UEngine_PrimitiveComponent_SetMaterial_Params params;
	params.ElementIndex = ElementIndex;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetMassScale
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          InMassScale                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetMassScale(const struct FName& BoneName, float InMassScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassScale");

	UEngine_PrimitiveComponent_SetMassScale_Params params;
	params.BoneName = BoneName;
	params.InMassScale = InMassScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetMassOverrideInKg
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          MassInKg                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOverrideMass                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetMassOverrideInKg(const struct FName& BoneName, float MassInKg, bool bOverrideMass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassOverrideInKg");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMassOverrideInKg");

	UEngine_PrimitiveComponent_SetMassOverrideInKg_Params params;
	params.BoneName = BoneName;
	params.MassInKg = MassInKg;
	params.bOverrideMass = bOverrideMass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetLinearDamping
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          InDamping                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetLinearDamping(float InDamping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLinearDamping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLinearDamping");

	UEngine_PrimitiveComponent_SetLinearDamping_Params params;
	params.InDamping = InDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetLightAttachmentsAsGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInLightAttachmentsAsGroup     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetLightAttachmentsAsGroup(bool bInLightAttachmentsAsGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLightAttachmentsAsGroup");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLightAttachmentsAsGroup");

	UEngine_PrimitiveComponent_SetLightAttachmentsAsGroup_Params params;
	params.bInLightAttachmentsAsGroup = bInLightAttachmentsAsGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetGenerateOverlapEvents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInGenerateOverlapEvents       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetGenerateOverlapEvents(bool bInGenerateOverlapEvents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetGenerateOverlapEvents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetGenerateOverlapEvents");

	UEngine_PrimitiveComponent_SetGenerateOverlapEvents_Params params;
	params.bInGenerateOverlapEvents = bInGenerateOverlapEvents;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetExcludeFromLightAttachmentGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInExcludeFromLightAttachmentGroup (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetExcludeFromLightAttachmentGroup(bool bInExcludeFromLightAttachmentGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetExcludeFromLightAttachmentGroup");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetExcludeFromLightAttachmentGroup");

	UEngine_PrimitiveComponent_SetExcludeFromLightAttachmentGroup_Params params;
	params.bInExcludeFromLightAttachmentGroup = bInExcludeFromLightAttachmentGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetEnableGravity
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bGravityEnabled                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetEnableGravity(bool bGravityEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetEnableGravity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetEnableGravity");

	UEngine_PrimitiveComponent_SetEnableGravity_Params params;
	params.bGravityEnabled = bGravityEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector4
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            DataIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector4                Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCustomPrimitiveDataVector4(int DataIndex, const struct FVector4& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector4");

	UEngine_PrimitiveComponent_SetCustomPrimitiveDataVector4_Params params;
	params.DataIndex = DataIndex;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector3
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            DataIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCustomPrimitiveDataVector3(int DataIndex, const struct FVector& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector3");

	UEngine_PrimitiveComponent_SetCustomPrimitiveDataVector3_Params params;
	params.DataIndex = DataIndex;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector2
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            DataIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCustomPrimitiveDataVector2(int DataIndex, const struct FVector2D& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector2");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataVector2");

	UEngine_PrimitiveComponent_SetCustomPrimitiveDataVector2_Params params;
	params.DataIndex = DataIndex;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCustomPrimitiveDataFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            DataIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCustomPrimitiveDataFloat(int DataIndex, float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomPrimitiveDataFloat");

	UEngine_PrimitiveComponent_SetCustomPrimitiveDataFloat_Params params;
	params.DataIndex = DataIndex;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCustomDepthStencilWriteMask
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_ERendererStencilMask WriteMaskBit                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCustomDepthStencilWriteMask(FEngine_Engine_ERendererStencilMask WriteMaskBit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilWriteMask");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilWriteMask");

	UEngine_PrimitiveComponent_SetCustomDepthStencilWriteMask_Params params;
	params.WriteMaskBit = WriteMaskBit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCustomDepthStencilValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCustomDepthStencilValue(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilValue");

	UEngine_PrimitiveComponent_SetCustomDepthStencilValue_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCullDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewCullDistance                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCullDistance(float NewCullDistance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCullDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCullDistance");

	UEngine_PrimitiveComponent_SetCullDistance_Params params;
	params.NewCullDistance = NewCullDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetConstraintMode
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EDOFMode> ConstraintMode                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetConstraintMode(TEnumAsByte<FEngine_Engine_EDOFMode> ConstraintMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetConstraintMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetConstraintMode");

	UEngine_PrimitiveComponent_SetConstraintMode_Params params;
	params.ConstraintMode = ConstraintMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCollisionResponseToChannel
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel                        (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECollisionResponse> NewResponse                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCollisionResponseToChannel(TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel, TEnumAsByte<FEngine_Engine_ECollisionResponse> NewResponse)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToChannel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToChannel");

	UEngine_PrimitiveComponent_SetCollisionResponseToChannel_Params params;
	params.Channel = Channel;
	params.NewResponse = NewResponse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionResponse> NewResponse                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCollisionResponseToAllChannels(TEnumAsByte<FEngine_Engine_ECollisionResponse> NewResponse)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels");

	UEngine_PrimitiveComponent_SetCollisionResponseToAllChannels_Params params;
	params.NewResponse = NewResponse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCollisionProfileName
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InCollisionProfileName         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCollisionProfileName(const struct FName& InCollisionProfileName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionProfileName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionProfileName");

	UEngine_PrimitiveComponent_SetCollisionProfileName_Params params;
	params.InCollisionProfileName = InCollisionProfileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCollisionObjectType
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCollisionObjectType(TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionObjectType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionObjectType");

	UEngine_PrimitiveComponent_SetCollisionObjectType_Params params;
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCollisionEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionEnabled> NewType                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCollisionEnabled(TEnumAsByte<FEngine_Engine_ECollisionEnabled> NewType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionEnabled");

	UEngine_PrimitiveComponent_SetCollisionEnabled_Params params;
	params.NewType = NewType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 CenterOfMassOffset             (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCenterOfMass(const struct FVector& CenterOfMassOffset, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCenterOfMass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCenterOfMass");

	UEngine_PrimitiveComponent_SetCenterOfMass_Params params;
	params.CenterOfMassOffset = CenterOfMassOffset;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCastShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           NewCastShadow                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCastShadow(bool NewCastShadow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastShadow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastShadow");

	UEngine_PrimitiveComponent_SetCastShadow_Params params;
	params.NewCastShadow = NewCastShadow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetCastInsetShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInCastInsetShadow             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetCastInsetShadow(bool bInCastInsetShadow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastInsetShadow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastInsetShadow");

	UEngine_PrimitiveComponent_SetCastInsetShadow_Params params;
	params.bInCastInsetShadow = bInCastInsetShadow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetBoundsScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewBoundsScale                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetBoundsScale(float NewBoundsScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetBoundsScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetBoundsScale");

	UEngine_PrimitiveComponent_SetBoundsScale_Params params;
	params.NewBoundsScale = NewBoundsScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetAngularDamping
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          InDamping                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetAngularDamping(float InDamping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAngularDamping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAngularDamping");

	UEngine_PrimitiveComponent_SetAngularDamping_Params params;
	params.InDamping = InDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetAllUseCCD
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           InUseCCD                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetAllUseCCD(bool InUseCCD)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllUseCCD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllUseCCD");

	UEngine_PrimitiveComponent_SetAllUseCCD_Params params;
	params.InUseCCD = InUseCCD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewVel                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetAllPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity");

	UEngine_PrimitiveComponent_SetAllPhysicsLinearVelocity_Params params;
	params.NewVel = NewVel;
	params.bAddToCurrent = bAddToCurrent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInRadians
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewAngVel                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetAllPhysicsAngularVelocityInRadians(const struct FVector& NewAngVel, bool bAddToCurrent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInRadians");

	UEngine_PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians_Params params;
	params.NewAngVel = NewAngVel;
	params.bAddToCurrent = bAddToCurrent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewAngVel                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           bAddToCurrent                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetAllPhysicsAngularVelocityInDegrees(const struct FVector& NewAngVel, bool bAddToCurrent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInDegrees");

	UEngine_PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees_Params params;
	params.NewAngVel = NewAngVel;
	params.bAddToCurrent = bAddToCurrent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.SetAllMassScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          InMassScale                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::SetAllMassScale(float InMassScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllMassScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllMassScale");

	UEngine_PrimitiveComponent_SetAllMassScale_Params params;
	params.InMassScale = InMassScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.ScaleByMomentOfInertia
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 InputVector                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::ScaleByMomentOfInertia(const struct FVector& InputVector, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ScaleByMomentOfInertia");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ScaleByMomentOfInertia");

	UEngine_PrimitiveComponent_ScaleByMomentOfInertia_Params params;
	params.InputVector = InputVector;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.PutRigidBodyToSleep
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::PutRigidBodyToSleep(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.PutRigidBodyToSleep");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.PutRigidBodyToSleep");

	UEngine_PrimitiveComponent_PutRigidBodyToSleep_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.K2_SphereTraceComponent
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 TraceStart                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TraceEnd                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          SphereRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShowTrace                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPersistentShowTrace           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitLocation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitNormal                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::K2_SphereTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, float SphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, struct FName* BoneName, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_SphereTraceComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_SphereTraceComponent");

	UEngine_PrimitiveComponent_K2_SphereTraceComponent_Params params;
	params.TraceStart = TraceStart;
	params.TraceEnd = TraceEnd;
	params.SphereRadius = SphereRadius;
	params.bTraceComplex = bTraceComplex;
	params.bShowTrace = bShowTrace;
	params.bPersistentShowTrace = bPersistentShowTrace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
	if (BoneName != nullptr)
		*BoneName = params.BoneName;
	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_SphereOverlapComponent
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InSphereCentre                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          InSphereRadius                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShowTrace                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPersistentShowTrace           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitLocation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitNormal                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::K2_SphereOverlapComponent(const struct FVector& InSphereCentre, float InSphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, struct FName* BoneName, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_SphereOverlapComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_SphereOverlapComponent");

	UEngine_PrimitiveComponent_K2_SphereOverlapComponent_Params params;
	params.InSphereCentre = InSphereCentre;
	params.InSphereRadius = InSphereRadius;
	params.bTraceComplex = bTraceComplex;
	params.bShowTrace = bShowTrace;
	params.bPersistentShowTrace = bPersistentShowTrace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
	if (BoneName != nullptr)
		*BoneName = params.BoneName;
	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_LineTraceComponent
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 TraceStart                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TraceEnd                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShowTrace                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPersistentShowTrace           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitLocation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitNormal                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::K2_LineTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, struct FName* BoneName, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_LineTraceComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_LineTraceComponent");

	UEngine_PrimitiveComponent_K2_LineTraceComponent_Params params;
	params.TraceStart = TraceStart;
	params.TraceEnd = TraceEnd;
	params.bTraceComplex = bTraceComplex;
	params.bShowTrace = bShowTrace;
	params.bPersistentShowTrace = bPersistentShowTrace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
	if (BoneName != nullptr)
		*BoneName = params.BoneName;
	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::K2_IsQueryCollisionEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled");

	UEngine_PrimitiveComponent_K2_IsQueryCollisionEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::K2_IsPhysicsCollisionEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled");

	UEngine_PrimitiveComponent_K2_IsPhysicsCollisionEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_IsCollisionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::K2_IsCollisionEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsCollisionEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_IsCollisionEnabled");

	UEngine_PrimitiveComponent_K2_IsCollisionEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.K2_BoxOverlapComponent
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InBoxCentre                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FBox                    InBox                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShowTrace                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPersistentShowTrace           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitLocation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitNormal                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::K2_BoxOverlapComponent(const struct FVector& InBoxCentre, const struct FBox& InBox, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, struct FName* BoneName, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_BoxOverlapComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_BoxOverlapComponent");

	UEngine_PrimitiveComponent_K2_BoxOverlapComponent_Params params;
	params.InBoxCentre = InBoxCentre;
	params.InBox = InBox;
	params.bTraceComplex = bTraceComplex;
	params.bShowTrace = bShowTrace;
	params.bPersistentShowTrace = bPersistentShowTrace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitLocation != nullptr)
		*HitLocation = params.HitLocation;
	if (HitNormal != nullptr)
		*HitNormal = params.HitNormal;
	if (BoneName != nullptr)
		*BoneName = params.BoneName;
	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.IsOverlappingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_PrimitiveComponent* OtherComp                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::IsOverlappingComponent(class UEngine_PrimitiveComponent* OtherComp)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingComponent");

	UEngine_PrimitiveComponent_IsOverlappingComponent_Params params;
	params.OtherComp = OtherComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.IsOverlappingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           Other                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::IsOverlappingActor(class AEngine_Actor* Other)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsOverlappingActor");

	UEngine_PrimitiveComponent_IsOverlappingActor_Params params;
	params.Other = Other;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.IsGravityEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::IsGravityEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsGravityEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsGravityEnabled");

	UEngine_PrimitiveComponent_IsGravityEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::IsAnyRigidBodyAwake()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake");

	UEngine_PrimitiveComponent_IsAnyRigidBodyAwake_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           bShouldIgnore                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::IgnoreComponentWhenMoving(class UEngine_PrimitiveComponent* Component, bool bShouldIgnore)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving");

	UEngine_PrimitiveComponent_IgnoreComponentWhenMoving_Params params;
	params.Component = Component;
	params.bShouldIgnore = bShouldIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.IgnoreActorWhenMoving
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           Actor                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShouldIgnore                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::IgnoreActorWhenMoving(class AEngine_Actor* Actor, bool bShouldIgnore)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreActorWhenMoving");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreActorWhenMoving");

	UEngine_PrimitiveComponent_IgnoreActorWhenMoving_Params params;
	params.Actor = Actor;
	params.bShouldIgnore = bShouldIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.GetWalkableSlopeOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEngine_WalkableSlopeOverride ReturnValue                    (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData)

struct FEngine_WalkableSlopeOverride UEngine_PrimitiveComponent::GetWalkableSlopeOverride()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetWalkableSlopeOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetWalkableSlopeOverride");

	UEngine_PrimitiveComponent_GetWalkableSlopeOverride_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::GetPhysicsLinearVelocityAtPoint(const struct FVector& Point, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint");

	UEngine_PrimitiveComponent_GetPhysicsLinearVelocityAtPoint_Params params;
	params.Point = Point;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::GetPhysicsLinearVelocity(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity");

	UEngine_PrimitiveComponent_GetPhysicsLinearVelocity_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInRadians
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::GetPhysicsAngularVelocityInRadians(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInRadians");

	UEngine_PrimitiveComponent_GetPhysicsAngularVelocityInRadians_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::GetPhysicsAngularVelocityInDegrees(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInDegrees");

	UEngine_PrimitiveComponent_GetPhysicsAngularVelocityInDegrees_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::GetPhysicsAngularVelocity(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity");

	UEngine_PrimitiveComponent_GetPhysicsAngularVelocity_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetOverlappingComponents
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UEngine_PrimitiveComponent*> OutOverlappingComponents       (Parm, OutParm, ZeroConstructor)

void UEngine_PrimitiveComponent::GetOverlappingComponents(TArray<class UEngine_PrimitiveComponent*>* OutOverlappingComponents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingComponents");

	UEngine_PrimitiveComponent_GetOverlappingComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutOverlappingComponents != nullptr)
		*OutOverlappingComponents = params.OutOverlappingComponents;
}


// Function Engine.PrimitiveComponent.GetOverlappingActors
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AEngine_Actor*>   OverlappingActors              (Parm, OutParm, ZeroConstructor)
// class UClass*                  ClassFilter                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::GetOverlappingActors(class UClass* ClassFilter, TArray<class AEngine_Actor*>* OverlappingActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingActors");

	UEngine_PrimitiveComponent_GetOverlappingActors_Params params;
	params.ClassFilter = ClassFilter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OverlappingActors != nullptr)
		*OverlappingActors = params.OverlappingActors;
}


// Function Engine.PrimitiveComponent.GetNumMaterials
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_PrimitiveComponent::GetNumMaterials()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetNumMaterials");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetNumMaterials");

	UEngine_PrimitiveComponent_GetNumMaterials_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMaterialFromCollisionFaceIndex
// (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            FaceIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            SectionIndex                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInterface* UEngine_PrimitiveComponent::GetMaterialFromCollisionFaceIndex(int FaceIndex, int* SectionIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterialFromCollisionFaceIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterialFromCollisionFaceIndex");

	UEngine_PrimitiveComponent_GetMaterialFromCollisionFaceIndex_Params params;
	params.FaceIndex = FaceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SectionIndex != nullptr)
		*SectionIndex = params.SectionIndex;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ElementIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInterface* UEngine_PrimitiveComponent::GetMaterial(int ElementIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterial");

	UEngine_PrimitiveComponent_GetMaterial_Params params;
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMassScale
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PrimitiveComponent::GetMassScale(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMassScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMassScale");

	UEngine_PrimitiveComponent_GetMassScale_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetMass
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PrimitiveComponent::GetMass()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMass");

	UEngine_PrimitiveComponent_GetMass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetLinearDamping
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PrimitiveComponent::GetLinearDamping()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetLinearDamping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetLinearDamping");

	UEngine_PrimitiveComponent_GetLinearDamping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetInertiaTensor
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::GetInertiaTensor(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetInertiaTensor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetInertiaTensor");

	UEngine_PrimitiveComponent_GetInertiaTensor_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetGenerateOverlapEvents
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::GetGenerateOverlapEvents()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetGenerateOverlapEvents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetGenerateOverlapEvents");

	UEngine_PrimitiveComponent_GetGenerateOverlapEvents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionResponseToChannel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel                        (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECollisionResponse> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_ECollisionResponse> UEngine_PrimitiveComponent::GetCollisionResponseToChannel(TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionResponseToChannel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionResponseToChannel");

	UEngine_PrimitiveComponent_GetCollisionResponseToChannel_Params params;
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionProfileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_PrimitiveComponent::GetCollisionProfileName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionProfileName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionProfileName");

	UEngine_PrimitiveComponent_GetCollisionProfileName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionObjectType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionChannel> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_ECollisionChannel> UEngine_PrimitiveComponent::GetCollisionObjectType()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionObjectType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionObjectType");

	UEngine_PrimitiveComponent_GetCollisionObjectType_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCollisionEnabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionEnabled> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_ECollisionEnabled> UEngine_PrimitiveComponent::GetCollisionEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionEnabled");

	UEngine_PrimitiveComponent_GetCollisionEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetClosestPointOnCollision
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Point                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 OutPointOnBody                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PrimitiveComponent::GetClosestPointOnCollision(const struct FVector& Point, const struct FName& BoneName, struct FVector* OutPointOnBody)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetClosestPointOnCollision");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetClosestPointOnCollision");

	UEngine_PrimitiveComponent_GetClosestPointOnCollision_Params params;
	params.Point = Point;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPointOnBody != nullptr)
		*OutPointOnBody = params.OutPointOnBody;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PrimitiveComponent::GetCenterOfMass(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCenterOfMass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCenterOfMass");

	UEngine_PrimitiveComponent_GetCenterOfMass_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.GetAngularDamping
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PrimitiveComponent::GetAngularDamping()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetAngularDamping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetAngularDamping");

	UEngine_PrimitiveComponent_GetAngularDamping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            ElementIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* SourceMaterial                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   OptionalName                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* UEngine_PrimitiveComponent::CreateDynamicMaterialInstance(int ElementIndex, class UEngine_MaterialInterface* SourceMaterial, const struct FName& OptionalName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance");

	UEngine_PrimitiveComponent_CreateDynamicMaterialInstance_Params params;
	params.ElementIndex = ElementIndex;
	params.SourceMaterial = SourceMaterial;
	params.OptionalName = OptionalName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            ElementIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* Parent                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* UEngine_PrimitiveComponent::CreateAndSetMaterialInstanceDynamicFromMaterial(int ElementIndex, class UEngine_MaterialInterface* Parent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial");

	UEngine_PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial_Params params;
	params.ElementIndex = ElementIndex;
	params.Parent = Parent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            ElementIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* UEngine_PrimitiveComponent::CreateAndSetMaterialInstanceDynamic(int ElementIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic");

	UEngine_PrimitiveComponent_CreateAndSetMaterialInstanceDynamic_Params params;
	params.ElementIndex = ElementIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UEngine_PrimitiveComponent*> ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UEngine_PrimitiveComponent*> UEngine_PrimitiveComponent::CopyArrayOfMoveIgnoreComponents()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents");

	UEngine_PrimitiveComponent_CopyArrayOfMoveIgnoreComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AEngine_Actor*>   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class AEngine_Actor*> UEngine_PrimitiveComponent::CopyArrayOfMoveIgnoreActors()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors");

	UEngine_PrimitiveComponent_CopyArrayOfMoveIgnoreActors_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.ClearMoveIgnoreComponents
// (Final, Native, Public, BlueprintCallable)

void UEngine_PrimitiveComponent::ClearMoveIgnoreComponents()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreComponents");

	UEngine_PrimitiveComponent_ClearMoveIgnoreComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.ClearMoveIgnoreActors
// (Final, Native, Public, BlueprintCallable)

void UEngine_PrimitiveComponent::ClearMoveIgnoreActors()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreActors");

	UEngine_PrimitiveComponent_ClearMoveIgnoreActors_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.CanCharacterStepUp
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Pawn*            Pawn                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PrimitiveComponent::CanCharacterStepUp(class AEngine_Pawn* Pawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CanCharacterStepUp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CanCharacterStepUp");

	UEngine_PrimitiveComponent_CanCharacterStepUp_Params params;
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PrimitiveComponent.AddTorqueInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Torque                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAccelChange                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddTorqueInRadians(const struct FVector& Torque, const struct FName& BoneName, bool bAccelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorqueInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorqueInRadians");

	UEngine_PrimitiveComponent_AddTorqueInRadians_Params params;
	params.Torque = Torque;
	params.BoneName = BoneName;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddTorqueInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Torque                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAccelChange                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddTorqueInDegrees(const struct FVector& Torque, const struct FName& BoneName, bool bAccelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorqueInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorqueInDegrees");

	UEngine_PrimitiveComponent_AddTorqueInDegrees_Params params;
	params.Torque = Torque;
	params.BoneName = BoneName;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddTorque
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Torque                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAccelChange                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddTorque(const struct FVector& Torque, const struct FName& BoneName, bool bAccelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorque");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorque");

	UEngine_PrimitiveComponent_AddTorque_Params params;
	params.Torque = Torque;
	params.BoneName = BoneName;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddRadialImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Origin                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          Strength                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ERadialImpulseFalloff> Falloff                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVelChange                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<FEngine_Engine_ERadialImpulseFalloff> Falloff, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialImpulse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialImpulse");

	UEngine_PrimitiveComponent_AddRadialImpulse_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.Strength = Strength;
	params.Falloff = Falloff;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddRadialForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Origin                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          Strength                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ERadialImpulseFalloff> Falloff                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAccelChange                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddRadialForce(const struct FVector& Origin, float Radius, float Strength, TEnumAsByte<FEngine_Engine_ERadialImpulseFalloff> Falloff, bool bAccelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialForce");

	UEngine_PrimitiveComponent_AddRadialForce_Params params;
	params.Origin = Origin;
	params.Radius = Radius;
	params.Strength = Strength;
	params.Falloff = Falloff;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddImpulseAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulseAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulseAtLocation");

	UEngine_PrimitiveComponent_AddImpulseAtLocation_Params params;
	params.Impulse = Impulse;
	params.Location = Location;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVelChange                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddImpulse(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulse");

	UEngine_PrimitiveComponent_AddImpulse_Params params;
	params.Impulse = Impulse;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddForceAtLocationLocal
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 force                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddForceAtLocationLocal(const struct FVector& force, const struct FVector& Location, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocationLocal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocationLocal");

	UEngine_PrimitiveComponent_AddForceAtLocationLocal_Params params;
	params.force = force;
	params.Location = Location;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddForceAtLocation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 force                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddForceAtLocation(const struct FVector& force, const struct FVector& Location, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocation");

	UEngine_PrimitiveComponent_AddForceAtLocation_Params params;
	params.force = force;
	params.Location = Location;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 force                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAccelChange                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddForce(const struct FVector& force, const struct FName& BoneName, bool bAccelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForce");

	UEngine_PrimitiveComponent_AddForce_Params params;
	params.force = force;
	params.BoneName = BoneName;
	params.bAccelChange = bAccelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddAngularImpulseInRadians
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVelChange                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddAngularImpulseInRadians(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulseInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulseInRadians");

	UEngine_PrimitiveComponent_AddAngularImpulseInRadians_Params params;
	params.Impulse = Impulse;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddAngularImpulseInDegrees
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVelChange                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddAngularImpulseInDegrees(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulseInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulseInDegrees");

	UEngine_PrimitiveComponent_AddAngularImpulseInDegrees_Params params;
	params.Impulse = Impulse;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PrimitiveComponent.AddAngularImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVelChange                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PrimitiveComponent::AddAngularImpulse(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddAngularImpulse");

	UEngine_PrimitiveComponent_AddAngularImpulse_Params params;
	params.Impulse = Impulse;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.SetVectorParameterValueOnMaterials
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ParameterValue                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MeshComponent::SetVectorParameterValueOnMaterials(const struct FName& ParameterName, const struct FVector& ParameterValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetVectorParameterValueOnMaterials");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetVectorParameterValueOnMaterials");

	UEngine_MeshComponent_SetVectorParameterValueOnMaterials_Params params;
	params.ParameterName = ParameterName;
	params.ParameterValue = ParameterValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.SetScalarParameterValueOnMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ParameterValue                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MeshComponent::SetScalarParameterValueOnMaterials(const struct FName& ParameterName, float ParameterValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetScalarParameterValueOnMaterials");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.SetScalarParameterValueOnMaterials");

	UEngine_MeshComponent_SetScalarParameterValueOnMaterials_Params params;
	params.ParameterName = ParameterName;
	params.ParameterValue = ParameterValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.PrestreamTextures
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Seconds                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPrioritizeCharacterTextures   (Parm, ZeroConstructor, IsPlainOldData)
// int                            CinematicTextureGroups         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MeshComponent::PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, int CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.PrestreamTextures");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.PrestreamTextures");

	UEngine_MeshComponent_PrestreamTextures_Params params;
	params.Seconds = Seconds;
	params.bPrioritizeCharacterTextures = bPrioritizeCharacterTextures;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshComponent.IsMaterialSlotNameValid
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   MaterialSlotName               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_MeshComponent::IsMaterialSlotNameValid(const struct FName& MaterialSlotName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.IsMaterialSlotNameValid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.IsMaterialSlotNameValid");

	UEngine_MeshComponent_IsMaterialSlotNameValid_Params params;
	params.MaterialSlotName = MaterialSlotName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.GetMaterialSlotNames
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FName>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FName> UEngine_MeshComponent::GetMaterialSlotNames()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterialSlotNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterialSlotNames");

	UEngine_MeshComponent_GetMaterialSlotNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.GetMaterials
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UEngine_MaterialInterface*> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<class UEngine_MaterialInterface*> UEngine_MeshComponent::GetMaterials()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterials");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterials");

	UEngine_MeshComponent_GetMaterials_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MeshComponent.GetMaterialIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   MaterialSlotName               (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_MeshComponent::GetMaterialIndex(const struct FName& MaterialSlotName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterialIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshComponent.GetMaterialIndex");

	UEngine_MeshComponent_GetMaterialIndex_Params params;
	params.MaterialSlotName = MaterialSlotName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.UnloadSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InProfileName                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::UnloadSkinWeightProfile(const struct FName& InProfileName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnloadSkinWeightProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnloadSkinWeightProfile");

	UEngine_SkinnedMeshComponent_UnloadSkinWeightProfile_Params params;
	params.InProfileName = InProfileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.UnHideBoneByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::UnHideBoneByName(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnHideBoneByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnHideBoneByName");

	UEngine_SkinnedMeshComponent_UnHideBoneByName_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.TransformToBoneSpace
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InPosition                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                InRotation                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutPosition                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                OutRotation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::TransformToBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformToBoneSpace");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformToBoneSpace");

	UEngine_SkinnedMeshComponent_TransformToBoneSpace_Params params;
	params.BoneName = BoneName;
	params.InPosition = InPosition;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPosition != nullptr)
		*OutPosition = params.OutPosition;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;
}


// Function Engine.SkinnedMeshComponent.TransformFromBoneSpace
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InPosition                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                InRotation                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutPosition                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                OutRotation                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::TransformFromBoneSpace(const struct FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformFromBoneSpace");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformFromBoneSpace");

	UEngine_SkinnedMeshComponent_TransformFromBoneSpace_Params params;
	params.BoneName = BoneName;
	params.InPosition = InPosition;
	params.InRotation = InRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPosition != nullptr)
		*OutPosition = params.OutPosition;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;
}


// Function Engine.SkinnedMeshComponent.ShowMaterialSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            MaterialID                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            SectionIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShow                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::ShowMaterialSection(int MaterialID, int SectionIndex, bool bShow, int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ShowMaterialSection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ShowMaterialSection");

	UEngine_SkinnedMeshComponent_ShowMaterialSection_Params params;
	params.MaterialID = MaterialID;
	params.SectionIndex = SectionIndex;
	params.bShow = bShow;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.ShowAllMaterialSections
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::ShowAllMaterialSections(int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ShowAllMaterialSections");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ShowAllMaterialSections");

	UEngine_SkinnedMeshComponent_ShowAllMaterialSections_Params params;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetVertexColorOverride_LinearColor
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FLinearColor>    VertexColors                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_SkinnedMeshComponent::SetVertexColorOverride_LinearColor(int LODIndex, TArray<struct FLinearColor> VertexColors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetVertexColorOverride_LinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetVertexColorOverride_LinearColor");

	UEngine_SkinnedMeshComponent_SetVertexColorOverride_LinearColor_Params params;
	params.LODIndex = LODIndex;
	params.VertexColors = VertexColors;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InProfileName                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkinnedMeshComponent::SetSkinWeightProfile(const struct FName& InProfileName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkinWeightProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkinWeightProfile");

	UEngine_SkinnedMeshComponent_SetSkinWeightProfile_Params params;
	params.InProfileName = InProfileName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.SetSkinWeightOverride
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_SkelMeshSkinWeightInfo> SkinWeights                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_SkinnedMeshComponent::SetSkinWeightOverride(int LODIndex, TArray<struct FEngine_SkelMeshSkinWeightInfo> SkinWeights)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkinWeightOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkinWeightOverride");

	UEngine_SkinnedMeshComponent_SetSkinWeightOverride_Params params;
	params.LODIndex = LODIndex;
	params.SkinWeights = SkinWeights;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetSkeletalMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SkeletalMesh*    NewMesh                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bReinitPose                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetSkeletalMesh(class UEngine_SkeletalMesh* NewMesh, bool bReinitPose)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkeletalMesh");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkeletalMesh");

	UEngine_SkinnedMeshComponent_SetSkeletalMesh_Params params;
	params.NewMesh = NewMesh;
	params.bReinitPose = bReinitPose;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetRenderStatic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetRenderStatic(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetRenderStatic");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetRenderStatic");

	UEngine_SkinnedMeshComponent_SetRenderStatic_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetPhysicsAsset
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_PhysicsAsset*    NewPhysicsAsset                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForceReInit                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetPhysicsAsset(class UEngine_PhysicsAsset* NewPhysicsAsset, bool bForceReInit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetPhysicsAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetPhysicsAsset");

	UEngine_SkinnedMeshComponent_SetPhysicsAsset_Params params;
	params.NewPhysicsAsset = NewPhysicsAsset;
	params.bForceReInit = bForceReInit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetMinLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            InNewMinLOD                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetMinLOD(int InNewMinLOD)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMinLOD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMinLOD");

	UEngine_SkinnedMeshComponent_SetMinLOD_Params params;
	params.InNewMinLOD = InNewMinLOD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SkinnedMeshComponent* NewMasterBoneComponent         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           bForceUpdate                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetMasterPoseComponent(class UEngine_SkinnedMeshComponent* NewMasterBoneComponent, bool bForceUpdate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMasterPoseComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMasterPoseComponent");

	UEngine_SkinnedMeshComponent_SetMasterPoseComponent_Params params;
	params.NewMasterBoneComponent = NewMasterBoneComponent;
	params.bForceUpdate = bForceUpdate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetForcedLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            InNewForcedLOD                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetForcedLOD(int InNewForcedLOD)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetForcedLOD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetForcedLOD");

	UEngine_SkinnedMeshComponent_SetForcedLOD_Params params;
	params.InNewForcedLOD = InNewForcedLOD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetCastCapsuleIndirectShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetCastCapsuleIndirectShadow(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCastCapsuleIndirectShadow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCastCapsuleIndirectShadow");

	UEngine_SkinnedMeshComponent_SetCastCapsuleIndirectShadow_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetCastCapsuleDirectShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetCastCapsuleDirectShadow(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCastCapsuleDirectShadow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCastCapsuleDirectShadow");

	UEngine_SkinnedMeshComponent_SetCastCapsuleDirectShadow_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.SetCapsuleIndirectShadowMinVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::SetCapsuleIndirectShadowMinVisibility(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCapsuleIndirectShadowMinVisibility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetCapsuleIndirectShadowMinVisibility");

	UEngine_SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.IsUsingSkinWeightProfile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkinnedMeshComponent::IsUsingSkinWeightProfile()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsUsingSkinWeightProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsUsingSkinWeightProfile");

	UEngine_SkinnedMeshComponent_IsUsingSkinWeightProfile_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.IsMaterialSectionShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            MaterialID                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkinnedMeshComponent::IsMaterialSectionShown(int MaterialID, int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsMaterialSectionShown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsMaterialSectionShown");

	UEngine_SkinnedMeshComponent_IsMaterialSectionShown_Params params;
	params.MaterialID = MaterialID;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.IsBoneHiddenByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkinnedMeshComponent::IsBoneHiddenByName(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsBoneHiddenByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsBoneHiddenByName");

	UEngine_SkinnedMeshComponent_IsBoneHiddenByName_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.HideBoneByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EPhysBodyOp> PhysBodyOption                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::HideBoneByName(const struct FName& BoneName, TEnumAsByte<FEngine_Engine_EPhysBodyOp> PhysBodyOption)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.HideBoneByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.HideBoneByName");

	UEngine_SkinnedMeshComponent_HideBoneByName_Params params;
	params.BoneName = BoneName;
	params.PhysBodyOption = PhysBodyOption;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.GetTwistAndSwingAngleOfDeltaRotationFromRefPose
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutTwistAngle                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutSwingAngle                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkinnedMeshComponent::GetTwistAndSwingAngleOfDeltaRotationFromRefPose(const struct FName& BoneName, float* OutTwistAngle, float* OutSwingAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetTwistAndSwingAngleOfDeltaRotationFromRefPose");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetTwistAndSwingAngleOfDeltaRotationFromRefPose");

	UEngine_SkinnedMeshComponent_GetTwistAndSwingAngleOfDeltaRotationFromRefPose_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTwistAngle != nullptr)
		*OutTwistAngle = params.OutTwistAngle;
	if (OutSwingAngle != nullptr)
		*OutSwingAngle = params.OutSwingAngle;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetSocketBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_SkinnedMeshComponent::GetSocketBoneName(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetSocketBoneName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetSocketBoneName");

	UEngine_SkinnedMeshComponent_GetSocketBoneName_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetRefPosePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            BoneIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SkinnedMeshComponent::GetRefPosePosition(int BoneIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetRefPosePosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetRefPosePosition");

	UEngine_SkinnedMeshComponent_GetRefPosePosition_Params params;
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetParentBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_SkinnedMeshComponent::GetParentBone(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetParentBone");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetParentBone");

	UEngine_SkinnedMeshComponent_GetParentBone_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetNumLODs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SkinnedMeshComponent::GetNumLODs()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetNumLODs");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetNumLODs");

	UEngine_SkinnedMeshComponent_GetNumLODs_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetNumBones
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SkinnedMeshComponent::GetNumBones()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetNumBones");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetNumBones");

	UEngine_SkinnedMeshComponent_GetNumBones_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetForcedLOD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SkinnedMeshComponent::GetForcedLOD()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetForcedLOD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetForcedLOD");

	UEngine_SkinnedMeshComponent_GetForcedLOD_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetDeltaTransformFromRefPose
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BaseName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SkinnedMeshComponent::GetDeltaTransformFromRefPose(const struct FName& BoneName, const struct FName& BaseName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetDeltaTransformFromRefPose");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetDeltaTransformFromRefPose");

	UEngine_SkinnedMeshComponent_GetDeltaTransformFromRefPose_Params params;
	params.BoneName = BoneName;
	params.BaseName = BaseName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetCurrentSkinWeightProfileName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_SkinnedMeshComponent::GetCurrentSkinWeightProfileName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetCurrentSkinWeightProfileName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetCurrentSkinWeightProfileName");

	UEngine_SkinnedMeshComponent_GetCurrentSkinWeightProfileName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            BoneIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_SkinnedMeshComponent::GetBoneName(int BoneIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneName");

	UEngine_SkinnedMeshComponent_GetBoneName_Params params;
	params.BoneIndex = BoneIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.GetBoneIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SkinnedMeshComponent::GetBoneIndex(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneIndex");

	UEngine_SkinnedMeshComponent_GetBoneIndex_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.FindClosestBone_K2
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 TestLocation                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoneLocation                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          IgnoreScale                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRequirePhysicsAsset           (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_SkinnedMeshComponent::FindClosestBone_K2(const struct FVector& TestLocation, float IgnoreScale, bool bRequirePhysicsAsset, struct FVector* BoneLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.FindClosestBone_K2");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.FindClosestBone_K2");

	UEngine_SkinnedMeshComponent_FindClosestBone_K2_Params params;
	params.TestLocation = TestLocation;
	params.IgnoreScale = IgnoreScale;
	params.bRequirePhysicsAsset = bRequirePhysicsAsset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (BoneLocation != nullptr)
		*BoneLocation = params.BoneLocation;

	return params.ReturnValue;
}


// Function Engine.SkinnedMeshComponent.ClearVertexColorOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::ClearVertexColorOverride(int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearVertexColorOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearVertexColorOverride");

	UEngine_SkinnedMeshComponent_ClearVertexColorOverride_Params params;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.ClearSkinWeightProfile
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkinnedMeshComponent::ClearSkinWeightProfile()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearSkinWeightProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearSkinWeightProfile");

	UEngine_SkinnedMeshComponent_ClearSkinWeightProfile_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.ClearSkinWeightOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkinnedMeshComponent::ClearSkinWeightOverride(int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearSkinWeightOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.ClearSkinWeightOverride");

	UEngine_SkinnedMeshComponent_ClearSkinWeightOverride_Params params;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkinnedMeshComponent.BoneIsChildOf
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ParentBoneName                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkinnedMeshComponent::BoneIsChildOf(const struct FName& BoneName, const struct FName& ParentBoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.BoneIsChildOf");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.BoneIsChildOf");

	UEngine_SkinnedMeshComponent_BoneIsChildOf_Params params;
	params.BoneName = BoneName;
	params.ParentBoneName = ParentBoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.UnlinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::UnlinkAnimClassLayers(class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.UnlinkAnimClassLayers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.UnlinkAnimClassLayers");

	UEngine_SkeletalMeshComponent_UnlinkAnimClassLayers_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bRestoreSimulationSpace        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::UnbindClothFromMasterPoseComponent(bool bRestoreSimulationSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent");

	UEngine_SkeletalMeshComponent_UnbindClothFromMasterPoseComponent_Params params;
	params.bRestoreSimulationSpace = bRestoreSimulationSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ToggleDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ToggleDisablePostProcessBlueprint()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ToggleDisablePostProcessBlueprint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ToggleDisablePostProcessBlueprint");

	UEngine_SkeletalMeshComponent_ToggleDisablePostProcessBlueprint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.TermBodiesBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParentBoneName                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::TermBodiesBelow(const struct FName& ParentBoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.TermBodiesBelow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.TermBodiesBelow");

	UEngine_SkeletalMeshComponent_TermBodiesBelow_Params params;
	params.ParentBoneName = ParentBoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SuspendClothingSimulation
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::SuspendClothingSimulation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SuspendClothingSimulation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SuspendClothingSimulation");

	UEngine_SkeletalMeshComponent_SuspendClothingSimulation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::Stop()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Stop");

	UEngine_SkeletalMeshComponent_Stop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SnapshotPose
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_PoseSnapshot    Snapshot                       (Parm, OutParm, ReferenceParm)

void UEngine_SkeletalMeshComponent::SnapshotPose(struct FEngine_PoseSnapshot* Snapshot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SnapshotPose");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SnapshotPose");

	UEngine_SkeletalMeshComponent_SnapshotPose_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Snapshot != nullptr)
		*Snapshot = params.Snapshot;
}


// Function Engine.SkeletalMeshComponent.SetUpdateAnimationInEditor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           NewUpdateState                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetUpdateAnimationInEditor(bool NewUpdateState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetUpdateAnimationInEditor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetUpdateAnimationInEditor");

	UEngine_SkeletalMeshComponent_SetUpdateAnimationInEditor_Params params;
	params.NewUpdateState = NewUpdateState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetTeleportRotationThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Threshold                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetTeleportRotationThreshold(float Threshold)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetTeleportRotationThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetTeleportRotationThreshold");

	UEngine_SkeletalMeshComponent_SetTeleportRotationThreshold_Params params;
	params.Threshold = Threshold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetTeleportDistanceThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Threshold                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetTeleportDistanceThreshold(float Threshold)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetTeleportDistanceThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetTeleportDistanceThreshold");

	UEngine_SkeletalMeshComponent_SetTeleportDistanceThreshold_Params params;
	params.Threshold = Threshold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InPos                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFireNotifies                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetPosition(float InPos, bool bFireNotifies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPosition");

	UEngine_SkeletalMeshComponent_SetPosition_Params params;
	params.InPos = InPos;
	params.bFireNotifies = bFireNotifies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Rate                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetPlayRate(float Rate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPlayRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPlayRate");

	UEngine_SkeletalMeshComponent_SetPlayRate_Params params;
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          PhysicsBlendWeight             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetPhysicsBlendWeight(float PhysicsBlendWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight");

	UEngine_SkeletalMeshComponent_SetPhysicsBlendWeight_Params params;
	params.PhysicsBlendWeight = PhysicsBlendWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewNotifyRigidBodyCollision   (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, const struct FName& BoneName, bool bIncludeSelf)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow");

	UEngine_SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow_Params params;
	params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	params.BoneName = BoneName;
	params.bIncludeSelf = bIncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetMorphTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   MorphTargetName                (Parm, ZeroConstructor, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRemoveZeroWeight              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetMorphTarget(const struct FName& MorphTargetName, float Value, bool bRemoveZeroWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetMorphTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetMorphTarget");

	UEngine_SkeletalMeshComponent_SetMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;
	params.Value = Value;
	params.bRemoveZeroWeight = bRemoveZeroWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewBlendPhysics               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetEnablePhysicsBlending(bool bNewBlendPhysics)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending");

	UEngine_SkeletalMeshComponent_SetEnablePhysicsBlending_Params params;
	params.bNewBlendPhysics = bNewBlendPhysics;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableGravity                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, const struct FName& BoneName, bool bIncludeSelf)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow");

	UEngine_SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow_Params params;
	params.bEnableGravity = bEnableGravity;
	params.BoneName = BoneName;
	params.bIncludeSelf = bIncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetEnableBodyGravity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableGravity                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetEnableBodyGravity(bool bEnableGravity, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnableBodyGravity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnableBodyGravity");

	UEngine_SkeletalMeshComponent_SetEnableBodyGravity_Params params;
	params.bEnableGravity = bEnableGravity;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInDisablePostProcess          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetDisablePostProcessBlueprint(bool bInDisablePostProcess)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetDisablePostProcessBlueprint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetDisablePostProcessBlueprint");

	UEngine_SkeletalMeshComponent_SetDisablePostProcessBlueprint_Params params;
	params.bInDisablePostProcess = bInDisablePostProcess;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetDisableAnimCurves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInDisableAnimCurves           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetDisableAnimCurves(bool bInDisableAnimCurves)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetDisableAnimCurves");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetDisableAnimCurves");

	UEngine_SkeletalMeshComponent_SetDisableAnimCurves_Params params;
	params.bInDisableAnimCurves = bInDisableAnimCurves;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDefaultIfNotFound             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetConstraintProfileForAll(const struct FName& ProfileName, bool bDefaultIfNotFound)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll");

	UEngine_SkeletalMeshComponent_SetConstraintProfileForAll_Params params;
	params.ProfileName = ProfileName;
	params.bDefaultIfNotFound = bDefaultIfNotFound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetConstraintProfile
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   JointName                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDefaultIfNotFound             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetConstraintProfile(const struct FName& JointName, const struct FName& ProfileName, bool bDefaultIfNotFound)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetConstraintProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetConstraintProfile");

	UEngine_SkeletalMeshComponent_SetConstraintProfile_Params params;
	params.JointName = JointName;
	params.ProfileName = ProfileName;
	params.bDefaultIfNotFound = bDefaultIfNotFound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetClothMaxDistanceScale(float Scale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale");

	UEngine_SkeletalMeshComponent_SetClothMaxDistanceScale_Params params;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewNotifyRigidBodyCollision   (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision");

	UEngine_SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision_Params params;
	params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAnimClass
// (Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  NewClass                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAnimClass(class UClass* NewClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimClass");

	UEngine_SkeletalMeshComponent_SetAnimClass_Params params;
	params.NewClass = NewClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAnimationMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EAnimationMode> InAnimationMode                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAnimationMode(TEnumAsByte<FEngine_Engine_EAnimationMode> InAnimationMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimationMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimationMode");

	UEngine_SkeletalMeshComponent_SetAnimationMode_Params params;
	params.InAnimationMode = InAnimationMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimationAsset*  NewAnimToPlay                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAnimation(class UEngine_AnimationAsset* NewAnimToPlay)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimation");

	UEngine_SkeletalMeshComponent_SetAnimation_Params params;
	params.NewAnimToPlay = NewAnimToPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAngularLimits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InBoneName                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Swing1LimitAngle               (Parm, ZeroConstructor, IsPlainOldData)
// float                          TwistLimitAngle                (Parm, ZeroConstructor, IsPlainOldData)
// float                          Swing2LimitAngle               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAngularLimits(const struct FName& InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAngularLimits");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAngularLimits");

	UEngine_SkeletalMeshComponent_SetAngularLimits_Params params;
	params.InBoneName = InBoneName;
	params.Swing1LimitAngle = Swing1LimitAngle;
	params.TwistLimitAngle = TwistLimitAngle;
	params.Swing2LimitAngle = Swing2LimitAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllowedAnimCurvesEvaluation
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FName>           List                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bAllow                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllowedAnimCurvesEvaluation(TArray<struct FName> List, bool bAllow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowedAnimCurvesEvaluation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowedAnimCurvesEvaluation");

	UEngine_SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation_Params params;
	params.List = List;
	params.bAllow = bAllow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllowAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInAllow                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllowAnimCurveEvaluation(bool bInAllow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowAnimCurveEvaluation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllowAnimCurveEvaluation");

	UEngine_SkeletalMeshComponent_SetAllowAnimCurveEvaluation_Params params;
	params.bInAllow = bInAllow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableSwingDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableTwistDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSkipCustomPhysicsType         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive");

	UEngine_SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableSwingDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableTwistDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSkipCustomPhysicsType         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive");

	UEngine_SkeletalMeshComponent_SetAllMotorsAngularPositionDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InSpring                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          InDamping                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InForceLimit                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSkipCustomPhysicsType         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams");

	UEngine_SkeletalMeshComponent_SetAllMotorsAngularDriveParams_Params params;
	params.InSpring = InSpring;
	params.InDamping = InDamping;
	params.InForceLimit = InForceLimit;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewSimulate                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllBodiesSimulatePhysics(bool bNewSimulate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics");

	UEngine_SkeletalMeshComponent_SetAllBodiesSimulatePhysics_Params params;
	params.bNewSimulate = bNewSimulate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          PhysicsBlendWeight             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSkipCustomPhysicsType         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight");

	UEngine_SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight_Params params;
	params.PhysicsBlendWeight = PhysicsBlendWeight;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   InBoneName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           bNewSimulate                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllBodiesBelowSimulatePhysics(const struct FName& InBoneName, bool bNewSimulate, bool bIncludeSelf)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics");

	UEngine_SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics_Params params;
	params.InBoneName = InBoneName;
	params.bNewSimulate = bNewSimulate;
	params.bIncludeSelf = bIncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   InBoneName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          PhysicsBlendWeight             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSkipCustomPhysicsType         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::SetAllBodiesBelowPhysicsBlendWeight(const struct FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight");

	UEngine_SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight_Params params;
	params.InBoneName = InBoneName;
	params.PhysicsBlendWeight = PhysicsBlendWeight;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
	params.bIncludeSelf = bIncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ResumeClothingSimulation
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ResumeClothingSimulation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResumeClothingSimulation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResumeClothingSimulation");

	UEngine_SkeletalMeshComponent_ResumeClothingSimulation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ResetClothTeleportMode
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ResetClothTeleportMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetClothTeleportMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetClothTeleportMode");

	UEngine_SkeletalMeshComponent_ResetClothTeleportMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ResetAnimInstanceDynamics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_ETeleportType   InTeleportType                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::ResetAnimInstanceDynamics(FEngine_Engine_ETeleportType InTeleportType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAnimInstanceDynamics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAnimInstanceDynamics");

	UEngine_SkeletalMeshComponent_ResetAnimInstanceDynamics_Params params;
	params.InTeleportType = InTeleportType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ResetAllowedAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ResetAllowedAnimCurveEvaluation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllowedAnimCurveEvaluation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllowedAnimCurveEvaluation");

	UEngine_SkeletalMeshComponent_ResetAllowedAnimCurveEvaluation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ResetAllBodiesSimulatePhysics()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics");

	UEngine_SkeletalMeshComponent_ResetAllBodiesSimulatePhysics_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.PlayAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimationAsset*  NewAnimToPlay                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLooping                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::PlayAnimation(class UEngine_AnimationAsset* NewAnimToPlay, bool bLooping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.PlayAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.PlayAnimation");

	UEngine_SkeletalMeshComponent_PlayAnimation_Params params;
	params.NewAnimToPlay = NewAnimToPlay;
	params.bLooping = bLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bLooping                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::Play(bool bLooping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Play");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Play");

	UEngine_SkeletalMeshComponent_Play_Params params;
	params.bLooping = bLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.OverrideAnimationData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimationAsset*  InAnimToPlay                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsLooping                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsPlaying                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Position                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          PlayRate                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::OverrideAnimationData(class UEngine_AnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.OverrideAnimationData");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.OverrideAnimationData");

	UEngine_SkeletalMeshComponent_OverrideAnimationData_Params params;
	params.InAnimToPlay = InAnimToPlay;
	params.bIsLooping = bIsLooping;
	params.bIsPlaying = bIsPlaying;
	params.Position = Position;
	params.PlayRate = PlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.LinkAnimGraphByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InTag                          (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::LinkAnimGraphByTag(const struct FName& InTag, class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.LinkAnimGraphByTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.LinkAnimGraphByTag");

	UEngine_SkeletalMeshComponent_LinkAnimGraphByTag_Params params;
	params.InTag = InTag;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.LinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::LinkAnimClassLayers(class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.LinkAnimClassLayers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.LinkAnimClassLayers");

	UEngine_SkeletalMeshComponent_LinkAnimClassLayers_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldPosition                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ClosestWorldPosition           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Normal                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Distance                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::K2_GetClosestPointOnPhysicsAsset(const struct FVector& WorldPosition, struct FVector* ClosestWorldPosition, struct FVector* Normal, struct FName* BoneName, float* Distance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset");

	UEngine_SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset_Params params;
	params.WorldPosition = WorldPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ClosestWorldPosition != nullptr)
		*ClosestWorldPosition = params.ClosestWorldPosition;
	if (Normal != nullptr)
		*Normal = params.Normal;
	if (BoneName != nullptr)
		*BoneName = params.BoneName;
	if (Distance != nullptr)
		*Distance = params.Distance;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::IsPlaying()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsPlaying");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsPlaying");

	UEngine_SkeletalMeshComponent_IsPlaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.IsClothingSimulationSuspended
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::IsClothingSimulationSuspended()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsClothingSimulationSuspended");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsClothingSimulationSuspended");

	UEngine_SkeletalMeshComponent_IsClothingSimulationSuspended_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::IsBodyGravityEnabled(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled");

	UEngine_SkeletalMeshComponent_IsBodyGravityEnabled_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.HasValidAnimationInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::HasValidAnimationInstance()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.HasValidAnimationInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.HasValidAnimationInstance");

	UEngine_SkeletalMeshComponent_HasValidAnimationInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetTeleportRotationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SkeletalMeshComponent::GetTeleportRotationThreshold()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTeleportRotationThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTeleportRotationThreshold");

	UEngine_SkeletalMeshComponent_GetTeleportRotationThreshold_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetTeleportDistanceThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SkeletalMeshComponent::GetTeleportDistanceThreshold()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTeleportDistanceThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTeleportDistanceThreshold");

	UEngine_SkeletalMeshComponent_GetTeleportDistanceThreshold_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SkeletalMeshComponent::GetSkeletalCenterOfMass()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass");

	UEngine_SkeletalMeshComponent_GetSkeletalCenterOfMass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPostProcessInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_SkeletalMeshComponent::GetPostProcessInstance()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPostProcessInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPostProcessInstance");

	UEngine_SkeletalMeshComponent_GetPostProcessInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SkeletalMeshComponent::GetPosition()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPosition");

	UEngine_SkeletalMeshComponent_GetPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SkeletalMeshComponent::GetPlayRate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPlayRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPlayRate");

	UEngine_SkeletalMeshComponent_GetPlayRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetMorphTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   MorphTargetName                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SkeletalMeshComponent::GetMorphTarget(const struct FName& MorphTargetName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetMorphTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetMorphTarget");

	UEngine_SkeletalMeshComponent_GetMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InGroup                        (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_SkeletalMeshComponent::GetLinkedAnimLayerInstanceByGroup(const struct FName& InGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByGroup");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByGroup");

	UEngine_SkeletalMeshComponent_GetLinkedAnimLayerInstanceByGroup_Params params;
	params.InGroup = InGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_SkeletalMeshComponent::GetLinkedAnimLayerInstanceByClass(class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimLayerInstanceByClass");

	UEngine_SkeletalMeshComponent_GetLinkedAnimLayerInstanceByClass_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstancesByTag
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InTag                          (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UEngine_AnimInstance*> OutLinkedInstances             (Parm, OutParm, ZeroConstructor)

void UEngine_SkeletalMeshComponent::GetLinkedAnimGraphInstancesByTag(const struct FName& InTag, TArray<class UEngine_AnimInstance*>* OutLinkedInstances)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstancesByTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstancesByTag");

	UEngine_SkeletalMeshComponent_GetLinkedAnimGraphInstancesByTag_Params params;
	params.InTag = InTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutLinkedInstances != nullptr)
		*OutLinkedInstances = params.OutLinkedInstances;
}


// Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstanceByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InTag                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_SkeletalMeshComponent::GetLinkedAnimGraphInstanceByTag(const struct FName& InTag)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstanceByTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetLinkedAnimGraphInstanceByTag");

	UEngine_SkeletalMeshComponent_GetLinkedAnimGraphInstanceByTag_Params params;
	params.InTag = InTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetDisablePostProcessBlueprint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::GetDisablePostProcessBlueprint()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetDisablePostProcessBlueprint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetDisablePostProcessBlueprint");

	UEngine_SkeletalMeshComponent_GetDisablePostProcessBlueprint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetDisableAnimCurves
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::GetDisableAnimCurves()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetDisableAnimCurves");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetDisableAnimCurves");

	UEngine_SkeletalMeshComponent_GetDisableAnimCurves_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetCurrentJointAngles
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   InBoneName                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Swing1Angle                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          TwistAngle                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Swing2Angle                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::GetCurrentJointAngles(const struct FName& InBoneName, float* Swing1Angle, float* TwistAngle, float* Swing2Angle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetCurrentJointAngles");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetCurrentJointAngles");

	UEngine_SkeletalMeshComponent_GetCurrentJointAngles_Params params;
	params.InBoneName = InBoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Swing1Angle != nullptr)
		*Swing1Angle = params.Swing1Angle;
	if (TwistAngle != nullptr)
		*TwistAngle = params.TwistAngle;
	if (Swing2Angle != nullptr)
		*Swing2Angle = params.Swing2Angle;
}


// Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SkeletalMeshComponent::GetClothMaxDistanceScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale");

	UEngine_SkeletalMeshComponent_GetClothMaxDistanceScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetClothingSimulationInteractor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClothingSystemRuntimeInterface_ClothingSimulationInteractor* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClothingSystemRuntimeInterface_ClothingSimulationInteractor* UEngine_SkeletalMeshComponent::GetClothingSimulationInteractor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothingSimulationInteractor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothingSimulationInteractor");

	UEngine_SkeletalMeshComponent_GetClothingSimulationInteractor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetBoneMass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bScaleMass                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SkeletalMeshComponent::GetBoneMass(const struct FName& BoneName, bool bScaleMass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetBoneMass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetBoneMass");

	UEngine_SkeletalMeshComponent_GetBoneMass_Params params;
	params.BoneName = BoneName;
	params.bScaleMass = bScaleMass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAnimInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_SkeletalMeshComponent::GetAnimInstance()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimInstance");

	UEngine_SkeletalMeshComponent_GetAnimInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAnimClass
// (Final, Native, Public)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UEngine_SkeletalMeshComponent::GetAnimClass()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimClass");

	UEngine_SkeletalMeshComponent_GetAnimClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAnimationMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_EAnimationMode> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_EAnimationMode> UEngine_SkeletalMeshComponent::GetAnimationMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimationMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimationMode");

	UEngine_SkeletalMeshComponent_GetAnimationMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.GetAllowedAnimCurveEvaluate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMeshComponent::GetAllowedAnimCurveEvaluate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAllowedAnimCurveEvaluate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAllowedAnimCurveEvaluate");

	UEngine_SkeletalMeshComponent_GetAllowedAnimCurveEvaluate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ForceClothNextUpdateTeleportAndReset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset");

	UEngine_SkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ForceClothNextUpdateTeleport()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport");

	UEngine_SkeletalMeshComponent_ForceClothNextUpdateTeleport_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.FindConstraintBoneName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ConstraintIndex                (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_SkeletalMeshComponent::FindConstraintBoneName(int ConstraintIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.FindConstraintBoneName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.FindConstraintBoneName");

	UEngine_SkeletalMeshComponent_FindConstraintBoneName_Params params;
	params.ConstraintIndex = ConstraintIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshComponent.ClearMorphTargets
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::ClearMorphTargets()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ClearMorphTargets");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ClearMorphTargets");

	UEngine_SkeletalMeshComponent_ClearMorphTargets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.BreakConstraint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   InBoneName                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::BreakConstraint(const struct FVector& Impulse, const struct FVector& HitLocation, const struct FName& InBoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BreakConstraint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BreakConstraint");

	UEngine_SkeletalMeshComponent_BreakConstraint_Params params;
	params.Impulse = Impulse;
	params.HitLocation = HitLocation;
	params.InBoneName = InBoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkeletalMeshComponent::BindClothToMasterPoseComponent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BindClothToMasterPoseComponent");

	UEngine_SkeletalMeshComponent_BindClothToMasterPoseComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.AllowAnimCurveEvaluation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   NameOfCurve                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAllow                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::AllowAnimCurveEvaluation(const struct FName& NameOfCurve, bool bAllow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AllowAnimCurveEvaluation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AllowAnimCurveEvaluation");

	UEngine_SkeletalMeshComponent_AllowAnimCurveEvaluation_Params params;
	params.NameOfCurve = NameOfCurve;
	params.bAllow = bAllow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVelChange                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::AddImpulseToAllBodiesBelow(const struct FVector& Impulse, const struct FName& BoneName, bool bVelChange, bool bIncludeSelf)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow");

	UEngine_SkeletalMeshComponent_AddImpulseToAllBodiesBelow_Params params;
	params.Impulse = Impulse;
	params.BoneName = BoneName;
	params.bVelChange = bVelChange;
	params.bIncludeSelf = bIncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 force                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAccelChange                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::AddForceToAllBodiesBelow(const struct FVector& force, const struct FName& BoneName, bool bAccelChange, bool bIncludeSelf)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow");

	UEngine_SkeletalMeshComponent_AddForceToAllBodiesBelow_Params params;
	params.force = force;
	params.BoneName = BoneName;
	params.bAccelChange = bAccelChange;
	params.bIncludeSelf = bIncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   InBoneName                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          AddPhysicsBlendWeight          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSkipCustomPhysicsType         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshComponent::AccumulateAllBodiesBelowPhysicsBlendWeight(const struct FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight");

	UEngine_SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight_Params params;
	params.InBoneName = InBoneName;
	params.AddPhysicsBlendWeight = AddPhysicsBlendWeight;
	params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.UnlockAIResources
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bUnlockMovement                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           UnlockAILogic                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlockAIResources");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlockAIResources");

	UEngine_AnimInstance_UnlockAIResources_Params params;
	params.bUnlockMovement = bUnlockMovement;
	params.UnlockAILogic = UnlockAILogic;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.UnlinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::UnlinkAnimClassLayers(class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlinkAnimClassLayers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlinkAnimClassLayers");

	UEngine_AnimInstance_UnlinkAnimClassLayers_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.TryGetPawnOwner
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* UEngine_AnimInstance::TryGetPawnOwner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.TryGetPawnOwner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.TryGetPawnOwner");

	UEngine_AnimInstance_TryGetPawnOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.StopSlotAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InBlendOutTime                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   SlotNodeName                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::StopSlotAnimation(float InBlendOutTime, const struct FName& SlotNodeName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.StopSlotAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.StopSlotAnimation");

	UEngine_AnimInstance_StopSlotAnimation_Params params;
	params.InBlendOutTime = InBlendOutTime;
	params.SlotNodeName = SlotNodeName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.SnapshotPose
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_PoseSnapshot    Snapshot                       (Parm, OutParm, ReferenceParm)

void UEngine_AnimInstance::SnapshotPose(struct FEngine_PoseSnapshot* Snapshot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SnapshotPose");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SnapshotPose");

	UEngine_AnimInstance_SnapshotPose_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Snapshot != nullptr)
		*Snapshot = params.Snapshot;
}


// Function Engine.AnimInstance.SetRootMotionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ERootMotionMode> Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::SetRootMotionMode(TEnumAsByte<FEngine_Engine_ERootMotionMode> Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetRootMotionMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetRootMotionMode");

	UEngine_AnimInstance_SetRootMotionMode_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.SetMorphTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   MorphTargetName                (Parm, ZeroConstructor, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::SetMorphTarget(const struct FName& MorphTargetName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetMorphTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetMorphTarget");

	UEngine_AnimInstance_SetMorphTarget_Params params;
	params.MorphTargetName = MorphTargetName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.SavePoseSnapshot
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   SnapshotName                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::SavePoseSnapshot(const struct FName& SnapshotName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SavePoseSnapshot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SavePoseSnapshot");

	UEngine_AnimInstance_SavePoseSnapshot_Params params;
	params.SnapshotName = SnapshotName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.ResetDynamics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_ETeleportType   InTeleportType                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::ResetDynamics(FEngine_Engine_ETeleportType InTeleportType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.ResetDynamics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.ResetDynamics");

	UEngine_AnimInstance_ResetDynamics_Params params;
	params.InTeleportType = InTeleportType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimSequenceBase* Asset                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   SlotNodeName                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendInTime                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendOutTime                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPlayRate                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            LoopCount                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendOutTriggerTime            (Parm, ZeroConstructor, IsPlainOldData)
// float                          InTimeToStartMontageAt         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimMontage*     ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimMontage* UEngine_AnimInstance::PlaySlotAnimationAsDynamicMontage(class UEngine_AnimSequenceBase* Asset, const struct FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage");

	UEngine_AnimInstance_PlaySlotAnimationAsDynamicMontage_Params params;
	params.Asset = Asset;
	params.SlotNodeName = SlotNodeName;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.InPlayRate = InPlayRate;
	params.LoopCount = LoopCount;
	params.BlendOutTriggerTime = BlendOutTriggerTime;
	params.InTimeToStartMontageAt = InTimeToStartMontageAt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.PlaySlotAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimSequenceBase* Asset                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   SlotNodeName                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendInTime                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendOutTime                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPlayRate                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            LoopCount                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::PlaySlotAnimation(class UEngine_AnimSequenceBase* Asset, const struct FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int LoopCount)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimation");

	UEngine_AnimInstance_PlaySlotAnimation_Params params;
	params.Asset = Asset;
	params.SlotNodeName = SlotNodeName;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.InPlayRate = InPlayRate;
	params.LoopCount = LoopCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InBlendOutTime                 (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_Stop(float InBlendOutTime, class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Stop");

	UEngine_AnimInstance_Montage_Stop_Params params;
	params.InBlendOutTime = InBlendOutTime;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          NewPosition                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_SetPosition(class UEngine_AnimMontage* Montage, float NewPosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPosition");

	UEngine_AnimInstance_Montage_SetPosition_Params params;
	params.Montage = Montage;
	params.NewPosition = NewPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          NewPlayRate                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_SetPlayRate(class UEngine_AnimMontage* Montage, float NewPlayRate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPlayRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPlayRate");

	UEngine_AnimInstance_Montage_SetPlayRate_Params params;
	params.Montage = Montage;
	params.NewPlayRate = NewPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_SetNextSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   SectionNameToChange            (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   NextSection                    (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_SetNextSection(const struct FName& SectionNameToChange, const struct FName& NextSection, class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetNextSection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetNextSection");

	UEngine_AnimInstance_Montage_SetNextSection_Params params;
	params.SectionNameToChange = SectionNameToChange;
	params.NextSection = NextSection;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_Resume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_Resume(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Resume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Resume");

	UEngine_AnimInstance_Montage_Resume_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     MontageToPlay                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPlayRate                     (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EMontagePlayReturnType ReturnValueType                (Parm, ZeroConstructor, IsPlainOldData)
// float                          InTimeToStartMontageAt         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bStopAllMontages               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::Montage_Play(class UEngine_AnimMontage* MontageToPlay, float InPlayRate, FEngine_Engine_EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Play");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Play");

	UEngine_AnimInstance_Montage_Play_Params params;
	params.MontageToPlay = MontageToPlay;
	params.InPlayRate = InPlayRate;
	params.ReturnValueType = ReturnValueType;
	params.InTimeToStartMontageAt = InTimeToStartMontageAt;
	params.bStopAllMontages = bStopAllMontages;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_Pause
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_Pause(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Pause");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Pause");

	UEngine_AnimInstance_Montage_Pause_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_JumpToSectionsEnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   SectionName                    (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_JumpToSectionsEnd(const struct FName& SectionName, class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSectionsEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSectionsEnd");

	UEngine_AnimInstance_Montage_JumpToSectionsEnd_Params params;
	params.SectionName = SectionName;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_JumpToSection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   SectionName                    (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::Montage_JumpToSection(const struct FName& SectionName, class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSection");

	UEngine_AnimInstance_Montage_JumpToSection_Params params;
	params.SectionName = SectionName;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.Montage_IsPlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::Montage_IsPlaying(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsPlaying");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsPlaying");

	UEngine_AnimInstance_Montage_IsPlaying_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::Montage_IsActive(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsActive");

	UEngine_AnimInstance_Montage_IsActive_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::Montage_GetPosition(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPosition");

	UEngine_AnimInstance_Montage_GetPosition_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::Montage_GetPlayRate(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPlayRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPlayRate");

	UEngine_AnimInstance_Montage_GetPlayRate_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetIsStopped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::Montage_GetIsStopped(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetIsStopped");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetIsStopped");

	UEngine_AnimInstance_Montage_GetIsStopped_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetCurrentSection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_AnimInstance::Montage_GetCurrentSection(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetCurrentSection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetCurrentSection");

	UEngine_AnimInstance_Montage_GetCurrentSection_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.Montage_GetBlendTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     Montage                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::Montage_GetBlendTime(class UEngine_AnimMontage* Montage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetBlendTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetBlendTime");

	UEngine_AnimInstance_Montage_GetBlendTime_Params params;
	params.Montage = Montage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.LockAIResources
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bLockMovement                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           LockAILogic                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::LockAIResources(bool bLockMovement, bool LockAILogic)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LockAIResources");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LockAIResources");

	UEngine_AnimInstance_LockAIResources_Params params;
	params.bLockMovement = bLockMovement;
	params.LockAILogic = LockAILogic;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.LinkAnimGraphByTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InTag                          (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::LinkAnimGraphByTag(const struct FName& InTag, class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LinkAnimGraphByTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LinkAnimGraphByTag");

	UEngine_AnimInstance_LinkAnimGraphByTag_Params params;
	params.InTag = InTag;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.LinkAnimClassLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::LinkAnimClassLayers(class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LinkAnimClassLayers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LinkAnimClassLayers");

	UEngine_AnimInstance_LinkAnimClassLayers_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.IsSyncGroupBetweenMarkers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSyncGroupName                (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PreviousMarker                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   NextMarker                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRespectMarkerOrder            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::IsSyncGroupBetweenMarkers(const struct FName& InSyncGroupName, const struct FName& PreviousMarker, const struct FName& NextMarker, bool bRespectMarkerOrder)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsSyncGroupBetweenMarkers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsSyncGroupBetweenMarkers");

	UEngine_AnimInstance_IsSyncGroupBetweenMarkers_Params params;
	params.InSyncGroupName = InSyncGroupName;
	params.PreviousMarker = PreviousMarker;
	params.NextMarker = NextMarker;
	params.bRespectMarkerOrder = bRespectMarkerOrder;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.IsPlayingSlotAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimSequenceBase* Asset                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   SlotNodeName                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::IsPlayingSlotAnimation(class UEngine_AnimSequenceBase* Asset, const struct FName& SlotNodeName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsPlayingSlotAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsPlayingSlotAnimation");

	UEngine_AnimInstance_IsPlayingSlotAnimation_Params params;
	params.Asset = Asset;
	params.SlotNodeName = SlotNodeName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.IsAnyMontagePlaying
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::IsAnyMontagePlaying()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsAnyMontagePlaying");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsAnyMontagePlaying");

	UEngine_AnimInstance_IsAnyMontagePlaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.HasMarkerBeenHitThisFrame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   SyncGroup                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   MarkerName                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::HasMarkerBeenHitThisFrame(const struct FName& SyncGroup, const struct FName& MarkerName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.HasMarkerBeenHitThisFrame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.HasMarkerBeenHitThisFrame");

	UEngine_AnimInstance_HasMarkerBeenHitThisFrame_Params params;
	params.SyncGroup = SyncGroup;
	params.MarkerName = MarkerName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetTimeToClosestMarker
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   SyncGroup                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   MarkerName                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutMarkerTime                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimInstance::GetTimeToClosestMarker(const struct FName& SyncGroup, const struct FName& MarkerName, float* OutMarkerTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetTimeToClosestMarker");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetTimeToClosestMarker");

	UEngine_AnimInstance_GetTimeToClosestMarker_Params params;
	params.SyncGroup = SyncGroup;
	params.MarkerName = MarkerName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutMarkerTime != nullptr)
		*OutMarkerTime = params.OutMarkerTime;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetSyncGroupPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSyncGroupName                (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_MarkerSyncAnimPosition ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEngine_MarkerSyncAnimPosition UEngine_AnimInstance::GetSyncGroupPosition(const struct FName& InSyncGroupName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetSyncGroupPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetSyncGroupPosition");

	UEngine_AnimInstance_GetSyncGroupPosition_Params params;
	params.InSyncGroupName = InSyncGroupName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            StateIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetRelevantAnimTimeRemainingFraction(int MachineIndex, int StateIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction");

	UEngine_AnimInstance_GetRelevantAnimTimeRemainingFraction_Params params;
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTimeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            StateIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetRelevantAnimTimeRemaining(int MachineIndex, int StateIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemaining");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeRemaining");

	UEngine_AnimInstance_GetRelevantAnimTimeRemaining_Params params;
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTimeFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            StateIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetRelevantAnimTimeFraction(int MachineIndex, int StateIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeFraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTimeFraction");

	UEngine_AnimInstance_GetRelevantAnimTimeFraction_Params params;
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            StateIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetRelevantAnimTime(int MachineIndex, int StateIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimTime");

	UEngine_AnimInstance_GetRelevantAnimTime_Params params;
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetRelevantAnimLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            StateIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetRelevantAnimLength(int MachineIndex, int StateIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetRelevantAnimLength");

	UEngine_AnimInstance_GetRelevantAnimLength_Params params;
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetOwningComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_SkeletalMeshComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_SkeletalMeshComponent* UEngine_AnimInstance::GetOwningComponent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningComponent");

	UEngine_AnimInstance_GetOwningComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetOwningActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_AnimInstance::GetOwningActor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningActor");

	UEngine_AnimInstance_GetOwningActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InGroup                        (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_AnimInstance::GetLinkedAnimLayerInstanceByGroup(const struct FName& InGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByGroup");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByGroup");

	UEngine_AnimInstance_GetLinkedAnimLayerInstanceByGroup_Params params;
	params.InGroup = InGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_AnimInstance::GetLinkedAnimLayerInstanceByClass(class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimLayerInstanceByClass");

	UEngine_AnimInstance_GetLinkedAnimLayerInstanceByClass_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetLinkedAnimGraphInstancesByTag
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InTag                          (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class UEngine_AnimInstance*> OutLinkedInstances             (Parm, OutParm, ZeroConstructor)

void UEngine_AnimInstance::GetLinkedAnimGraphInstancesByTag(const struct FName& InTag, TArray<class UEngine_AnimInstance*>* OutLinkedInstances)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimGraphInstancesByTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimGraphInstancesByTag");

	UEngine_AnimInstance_GetLinkedAnimGraphInstancesByTag_Params params;
	params.InTag = InTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutLinkedInstances != nullptr)
		*OutLinkedInstances = params.OutLinkedInstances;
}


// Function Engine.AnimInstance.GetLinkedAnimGraphInstanceByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InTag                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AnimInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimInstance* UEngine_AnimInstance::GetLinkedAnimGraphInstanceByTag(const struct FName& InTag)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimGraphInstanceByTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetLinkedAnimGraphInstanceByTag");

	UEngine_AnimInstance_GetLinkedAnimGraphInstanceByTag_Params params;
	params.InTag = InTag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            TransitionIndex                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceTransitionTimeElapsedFraction(int MachineIndex, int TransitionIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction");

	UEngine_AnimInstance_GetInstanceTransitionTimeElapsedFraction_Params params;
	params.MachineIndex = MachineIndex;
	params.TransitionIndex = TransitionIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            TransitionIndex                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceTransitionTimeElapsed(int MachineIndex, int TransitionIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed");

	UEngine_AnimInstance_GetInstanceTransitionTimeElapsed_Params params;
	params.MachineIndex = MachineIndex;
	params.TransitionIndex = TransitionIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            TransitionIndex                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceTransitionCrossfadeDuration(int MachineIndex, int TransitionIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration");

	UEngine_AnimInstance_GetInstanceTransitionCrossfadeDuration_Params params;
	params.MachineIndex = MachineIndex;
	params.TransitionIndex = TransitionIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceStateWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            StateIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceStateWeight(int MachineIndex, int StateIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceStateWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceStateWeight");

	UEngine_AnimInstance_GetInstanceStateWeight_Params params;
	params.MachineIndex = MachineIndex;
	params.StateIndex = StateIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceMachineWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceMachineWeight(int MachineIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceMachineWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceMachineWeight");

	UEngine_AnimInstance_GetInstanceMachineWeight_Params params;
	params.MachineIndex = MachineIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceCurrentStateElapsedTime(int MachineIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime");

	UEngine_AnimInstance_GetInstanceCurrentStateElapsedTime_Params params;
	params.MachineIndex = MachineIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            AssetPlayerIndex               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceAssetPlayerTimeFromEndFraction(int AssetPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction");

	UEngine_AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction_Params params;
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            AssetPlayerIndex               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceAssetPlayerTimeFromEnd(int AssetPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd");

	UEngine_AnimInstance_GetInstanceAssetPlayerTimeFromEnd_Params params;
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            AssetPlayerIndex               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceAssetPlayerTimeFraction(int AssetPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction");

	UEngine_AnimInstance_GetInstanceAssetPlayerTimeFraction_Params params;
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            AssetPlayerIndex               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceAssetPlayerTime(int AssetPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerTime");

	UEngine_AnimInstance_GetInstanceAssetPlayerTime_Params params;
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetInstanceAssetPlayerLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            AssetPlayerIndex               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetInstanceAssetPlayerLength(int AssetPlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetInstanceAssetPlayerLength");

	UEngine_AnimInstance_GetInstanceAssetPlayerLength_Params params;
	params.AssetPlayerIndex = AssetPlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetCurveValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   CurveName                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::GetCurveValue(const struct FName& CurveName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurveValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurveValue");

	UEngine_AnimInstance_GetCurveValue_Params params;
	params.CurveName = CurveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetCurrentStateName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            MachineIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_AnimInstance::GetCurrentStateName(int MachineIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentStateName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentStateName");

	UEngine_AnimInstance_GetCurrentStateName_Params params;
	params.MachineIndex = MachineIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetCurrentActiveMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimMontage*     ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimMontage* UEngine_AnimInstance::GetCurrentActiveMontage()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentActiveMontage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentActiveMontage");

	UEngine_AnimInstance_GetCurrentActiveMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.GetAllCurveNames
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FName>           OutNames                       (Parm, OutParm, ZeroConstructor)

void UEngine_AnimInstance::GetAllCurveNames(TArray<struct FName>* OutNames)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAllCurveNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAllCurveNames");

	UEngine_AnimInstance_GetAllCurveNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutNames != nullptr)
		*OutNames = params.OutNames;
}


// Function Engine.AnimInstance.GetActiveCurveNames
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FEngine_Engine_EAnimCurveType  CurveType                      (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FName>           OutNames                       (Parm, OutParm, ZeroConstructor)

void UEngine_AnimInstance::GetActiveCurveNames(FEngine_Engine_EAnimCurveType CurveType, TArray<struct FName>* OutNames)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetActiveCurveNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetActiveCurveNames");

	UEngine_AnimInstance_GetActiveCurveNames_Params params;
	params.CurveType = CurveType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutNames != nullptr)
		*OutNames = params.OutNames;
}


// Function Engine.AnimInstance.ClearMorphTargets
// (Final, Native, Public, BlueprintCallable)

void UEngine_AnimInstance::ClearMorphTargets()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.ClearMorphTargets");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.ClearMorphTargets");

	UEngine_AnimInstance_ClearMorphTargets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.CalculateDirection
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Velocity                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                BaseRotation                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimInstance::CalculateDirection(const struct FVector& Velocity, const struct FRotator& BaseRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.CalculateDirection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.CalculateDirection");

	UEngine_AnimInstance_CalculateDirection_Params params;
	params.Velocity = Velocity;
	params.BaseRotation = BaseRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimInstance.BlueprintUpdateAnimation
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          DeltaTimeX                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimInstance::BlueprintUpdateAnimation(float DeltaTimeX)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintUpdateAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintUpdateAnimation");

	UEngine_AnimInstance_BlueprintUpdateAnimation_Params params;
	params.DeltaTimeX = DeltaTimeX;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.BlueprintPostEvaluateAnimation
// (Event, Public, BlueprintEvent)

void UEngine_AnimInstance::BlueprintPostEvaluateAnimation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintPostEvaluateAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintPostEvaluateAnimation");

	UEngine_AnimInstance_BlueprintPostEvaluateAnimation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.BlueprintInitializeAnimation
// (Event, Public, BlueprintEvent)

void UEngine_AnimInstance::BlueprintInitializeAnimation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintInitializeAnimation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintInitializeAnimation");

	UEngine_AnimInstance_BlueprintInitializeAnimation_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimInstance.BlueprintBeginPlay
// (Event, Public, BlueprintEvent)

void UEngine_AnimInstance::BlueprintBeginPlay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintBeginPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintBeginPlay");

	UEngine_AnimInstance_BlueprintBeginPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.SetVectorParameter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Param                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_FXSystemComponent::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetVectorParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetVectorParameter");

	UEngine_FXSystemComponent_SetVectorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.SetUseAutoManageAttachment
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bAutoManage                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_FXSystemComponent::SetUseAutoManageAttachment(bool bAutoManage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetUseAutoManageAttachment");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetUseAutoManageAttachment");

	UEngine_FXSystemComponent_SetUseAutoManageAttachment_Params params;
	params.bAutoManage = bAutoManage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.SetFloatParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          Param                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_FXSystemComponent::SetFloatParameter(const struct FName& ParameterName, float Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetFloatParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetFloatParameter");

	UEngine_FXSystemComponent_SetFloatParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.SetEmitterEnable
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   EmitterName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNewEnableState                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_FXSystemComponent::SetEmitterEnable(const struct FName& EmitterName, bool bNewEnableState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetEmitterEnable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetEmitterEnable");

	UEngine_FXSystemComponent_SetEmitterEnable_Params params;
	params.EmitterName = EmitterName;
	params.bNewEnableState = bNewEnableState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.SetColorParameter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Param                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_FXSystemComponent::SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetColorParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetColorParameter");

	UEngine_FXSystemComponent_SetColorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.SetAutoAttachmentParameters
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  Parent                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   SocketName                     (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule LocationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule RotationRule                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAttachmentRule ScaleRule                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_FXSystemComponent::SetAutoAttachmentParameters(class UEngine_SceneComponent* Parent, const struct FName& SocketName, FEngine_Engine_EAttachmentRule LocationRule, FEngine_Engine_EAttachmentRule RotationRule, FEngine_Engine_EAttachmentRule ScaleRule)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetAutoAttachmentParameters");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetAutoAttachmentParameters");

	UEngine_FXSystemComponent_SetAutoAttachmentParameters_Params params;
	params.Parent = Parent;
	params.SocketName = SocketName;
	params.LocationRule = LocationRule;
	params.RotationRule = RotationRule;
	params.ScaleRule = ScaleRule;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.SetActorParameter
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           Param                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_FXSystemComponent::SetActorParameter(const struct FName& ParameterName, class AEngine_Actor* Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetActorParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.SetActorParameter");

	UEngine_FXSystemComponent_SetActorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.ReleaseToPool
// (Native, Public, BlueprintCallable)

void UEngine_FXSystemComponent::ReleaseToPool()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.ReleaseToPool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.ReleaseToPool");

	UEngine_FXSystemComponent_ReleaseToPool_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.FXSystemComponent.GetFXSystemAsset
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_FXSystemAsset*   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_FXSystemAsset* UEngine_FXSystemComponent::GetFXSystemAsset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.GetFXSystemAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.FXSystemComponent.GetFXSystemAsset");

	UEngine_FXSystemComponent_GetFXSystemAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotify.Received_Notify
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UEngine_SkeletalMeshComponent* MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UEngine_AnimSequenceBase* Animation                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimNotify::Received_Notify(class UEngine_SkeletalMeshComponent* MeshComp, class UEngine_AnimSequenceBase* Animation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.Received_Notify");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.Received_Notify");

	UEngine_AnimNotify_Received_Notify_Params params;
	params.MeshComp = MeshComp;
	params.Animation = Animation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotify.GetNotifyName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_AnimNotify::GetNotifyName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.GetNotifyName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.GetNotifyName");

	UEngine_AnimNotify_GetNotifyName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotifyState.Received_NotifyTick
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UEngine_SkeletalMeshComponent* MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UEngine_AnimSequenceBase* Animation                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          FrameDeltaTime                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimNotifyState::Received_NotifyTick(class UEngine_SkeletalMeshComponent* MeshComp, class UEngine_AnimSequenceBase* Animation, float FrameDeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyTick");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyTick");

	UEngine_AnimNotifyState_Received_NotifyTick_Params params;
	params.MeshComp = MeshComp;
	params.Animation = Animation;
	params.FrameDeltaTime = FrameDeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotifyState.Received_NotifyEnd
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UEngine_SkeletalMeshComponent* MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UEngine_AnimSequenceBase* Animation                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimNotifyState::Received_NotifyEnd(class UEngine_SkeletalMeshComponent* MeshComp, class UEngine_AnimSequenceBase* Animation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyEnd");

	UEngine_AnimNotifyState_Received_NotifyEnd_Params params;
	params.MeshComp = MeshComp;
	params.Animation = Animation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotifyState.Received_NotifyBegin
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UEngine_SkeletalMeshComponent* MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UEngine_AnimSequenceBase* Animation                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          TotalDuration                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AnimNotifyState::Received_NotifyBegin(class UEngine_SkeletalMeshComponent* MeshComp, class UEngine_AnimSequenceBase* Animation, float TotalDuration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyBegin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyBegin");

	UEngine_AnimNotifyState_Received_NotifyBegin_Params params;
	params.MeshComp = MeshComp;
	params.Animation = Animation;
	params.TotalDuration = TotalDuration;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotifyState.GetNotifyName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_AnimNotifyState::GetNotifyName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.GetNotifyName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.GetNotifyName");

	UEngine_AnimNotifyState_GetNotifyName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.SpawnDefaultController
// (Native, Public, BlueprintCallable)

void AEngine_Pawn::SpawnDefaultController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SpawnDefaultController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SpawnDefaultController");

	AEngine_Pawn_SpawnDefaultController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.SetCanAffectNavigationGeneration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForceUpdate                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SetCanAffectNavigationGeneration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SetCanAffectNavigationGeneration");

	AEngine_Pawn_SetCanAffectNavigationGeneration_Params params;
	params.bNewValue = bNewValue;
	params.bForceUpdate = bForceUpdate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ReceiveUnpossessed
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      OldController                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::ReceiveUnpossessed(class AEngine_Controller* OldController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceiveUnpossessed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceiveUnpossessed");

	AEngine_Pawn_ReceiveUnpossessed_Params params;
	params.OldController = OldController;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ReceivePossessed
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      NewController                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::ReceivePossessed(class AEngine_Controller* NewController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceivePossessed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceivePossessed");

	AEngine_Pawn_ReceivePossessed_Params params;
	params.NewController = NewController;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.PawnMakeNoise
// (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                          Loudness                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NoiseLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseNoiseMakerLocation         (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           NoiseMaker                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::PawnMakeNoise(float Loudness, const struct FVector& NoiseLocation, bool bUseNoiseMakerLocation, class AEngine_Actor* NoiseMaker)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.PawnMakeNoise");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.PawnMakeNoise");

	AEngine_Pawn_PawnMakeNoise_Params params;
	params.Loudness = Loudness;
	params.NoiseLocation = NoiseLocation;
	params.bUseNoiseMakerLocation = bUseNoiseMakerLocation;
	params.NoiseMaker = NoiseMaker;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.OnRep_PlayerState
// (Native, Public)

void AEngine_Pawn::OnRep_PlayerState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_PlayerState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_PlayerState");

	AEngine_Pawn_OnRep_PlayerState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.OnRep_Controller
// (Native, Public)

void AEngine_Pawn::OnRep_Controller()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_Controller");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_Controller");

	AEngine_Pawn_OnRep_Controller_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.LaunchPawn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 LaunchVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bXYOverride                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bZOverride                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::LaunchPawn(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.LaunchPawn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.LaunchPawn");

	AEngine_Pawn_LaunchPawn_Params params;
	params.LaunchVelocity = LaunchVelocity;
	params.bXYOverride = bXYOverride;
	params.bZOverride = bZOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.K2_GetMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Pawn::K2_GetMovementInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.K2_GetMovementInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.K2_GetMovementInputVector");

	AEngine_Pawn_K2_GetMovementInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsPlayerControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Pawn::IsPlayerControlled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsPlayerControlled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsPlayerControlled");

	AEngine_Pawn_IsPlayerControlled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsPawnControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Pawn::IsPawnControlled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsPawnControlled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsPawnControlled");

	AEngine_Pawn_IsPawnControlled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Pawn::IsMoveInputIgnored()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsMoveInputIgnored");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsMoveInputIgnored");

	AEngine_Pawn_IsMoveInputIgnored_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsLocallyControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Pawn::IsLocallyControlled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsLocallyControlled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsLocallyControlled");

	AEngine_Pawn_IsLocallyControlled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Pawn::IsControlled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsControlled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsControlled");

	AEngine_Pawn_IsControlled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.IsBotControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Pawn::IsBotControlled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsBotControlled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsBotControlled");

	AEngine_Pawn_IsBotControlled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetPendingMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Pawn::GetPendingMovementInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetPendingMovementInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetPendingMovementInputVector");

	AEngine_Pawn_GetPendingMovementInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetNavAgentLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Pawn::GetNavAgentLocation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetNavAgentLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetNavAgentLocation");

	AEngine_Pawn_GetNavAgentLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetMovementComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_PawnMovementComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_PawnMovementComponent* AEngine_Pawn::GetMovementComponent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementComponent");

	AEngine_Pawn_GetMovementComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetMovementBaseActor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_Pawn*            Pawn                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_Pawn::STATIC_GetMovementBaseActor(class AEngine_Pawn* Pawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementBaseActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementBaseActor");

	AEngine_Pawn_GetMovementBaseActor_Params params;
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetLastMovementInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Pawn::GetLastMovementInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetLastMovementInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetLastMovementInputVector");

	AEngine_Pawn_GetLastMovementInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetControlRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator AEngine_Pawn::GetControlRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetControlRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetControlRotation");

	AEngine_Pawn_GetControlRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Controller*      ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Controller* AEngine_Pawn::GetController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetController");

	AEngine_Pawn_GetController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.GetBaseAimRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator AEngine_Pawn::GetBaseAimRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetBaseAimRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetBaseAimRotation");

	AEngine_Pawn_GetBaseAimRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.DetachFromControllerPendingDestroy
// (Native, Public, BlueprintCallable)

void AEngine_Pawn::DetachFromControllerPendingDestroy()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.DetachFromControllerPendingDestroy");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.DetachFromControllerPendingDestroy");

	AEngine_Pawn_DetachFromControllerPendingDestroy_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.ConsumeMovementInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Pawn::ConsumeMovementInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ConsumeMovementInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ConsumeMovementInputVector");

	AEngine_Pawn_ConsumeMovementInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Pawn.AddMovementInput
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 WorldDirection                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScaleValue                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForce                         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::AddMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddMovementInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddMovementInput");

	AEngine_Pawn_AddMovementInput_Params params;
	params.WorldDirection = WorldDirection;
	params.ScaleValue = ScaleValue;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.AddControllerYawInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::AddControllerYawInput(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerYawInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerYawInput");

	AEngine_Pawn_AddControllerYawInput_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.AddControllerRollInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::AddControllerRollInput(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerRollInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerRollInput");

	AEngine_Pawn_AddControllerRollInput_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Pawn.AddControllerPitchInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Pawn::AddControllerPitchInput(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerPitchInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerPitchInput");

	AEngine_Pawn_AddControllerPitchInput_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.UnCrouch
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bClientSimulation              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::UnCrouch(bool bClientSimulation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.UnCrouch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.UnCrouch");

	AEngine_Character_UnCrouch_Params params;
	params.bClientSimulation = bClientSimulation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.StopJumping
// (Native, Public, BlueprintCallable)

void AEngine_Character::StopJumping()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.StopJumping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.StopJumping");

	AEngine_Character_StopJumping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.StopAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     AnimMontage                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::StopAnimMontage(class UEngine_AnimMontage* AnimMontage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.StopAnimMontage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.StopAnimMontage");

	AEngine_Character_StopAnimMontage_Params params;
	params.AnimMontage = AnimMontage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ServerMoveOld
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          OldTimeStamp                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 OldAccel                       (Parm)
// unsigned char                  OldMoveFlags                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ServerMoveOld(float OldTimeStamp, const struct FEngine_Vector_NetQuantize10& OldAccel, unsigned char OldMoveFlags)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveOld");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveOld");

	AEngine_Character_ServerMoveOld_Params params;
	params.OldTimeStamp = OldTimeStamp;
	params.OldAccel = OldAccel;
	params.OldMoveFlags = OldMoveFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ServerMoveNoBase
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel                        (Parm)
// struct FEngine_Vector_NetQuantize100 ClientLoc                      (Parm)
// unsigned char                  CompressedMoveFlags            (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientRoll                     (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View                           (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ServerMoveNoBase(float Timestamp, const struct FEngine_Vector_NetQuantize10& InAccel, const struct FEngine_Vector_NetQuantize100& ClientLoc, unsigned char CompressedMoveFlags, unsigned char ClientRoll, uint32_t View, unsigned char ClientMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveNoBase");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveNoBase");

	AEngine_Character_ServerMoveNoBase_Params params;
	params.Timestamp = Timestamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.CompressedMoveFlags = CompressedMoveFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ServerMoveDualNoBase
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          TimeStamp0                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel0                       (Parm)
// unsigned char                  PendingFlags                   (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View0                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel                        (Parm)
// struct FEngine_Vector_NetQuantize100 ClientLoc                      (Parm)
// unsigned char                  NewFlags                       (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientRoll                     (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View                           (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ServerMoveDualNoBase(float TimeStamp0, const struct FEngine_Vector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, float Timestamp, const struct FEngine_Vector_NetQuantize10& InAccel, const struct FEngine_Vector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, unsigned char ClientMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDualNoBase");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDualNoBase");

	AEngine_Character_ServerMoveDualNoBase_Params params;
	params.TimeStamp0 = TimeStamp0;
	params.InAccel0 = InAccel0;
	params.PendingFlags = PendingFlags;
	params.View0 = View0;
	params.Timestamp = Timestamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.NewFlags = NewFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ServerMoveDualHybridRootMotion
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          TimeStamp0                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel0                       (Parm)
// unsigned char                  PendingFlags                   (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View0                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel                        (Parm)
// struct FEngine_Vector_NetQuantize100 ClientLoc                      (Parm)
// unsigned char                  NewFlags                       (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientRoll                     (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View                           (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* ClientMovementBase             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   ClientBaseBoneName             (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ServerMoveDualHybridRootMotion(float TimeStamp0, const struct FEngine_Vector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, float Timestamp, const struct FEngine_Vector_NetQuantize10& InAccel, const struct FEngine_Vector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UEngine_PrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDualHybridRootMotion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDualHybridRootMotion");

	AEngine_Character_ServerMoveDualHybridRootMotion_Params params;
	params.TimeStamp0 = TimeStamp0;
	params.InAccel0 = InAccel0;
	params.PendingFlags = PendingFlags;
	params.View0 = View0;
	params.Timestamp = Timestamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.NewFlags = NewFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementBase = ClientMovementBase;
	params.ClientBaseBoneName = ClientBaseBoneName;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ServerMoveDual
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          TimeStamp0                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel0                       (Parm)
// unsigned char                  PendingFlags                   (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View0                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel                        (Parm)
// struct FEngine_Vector_NetQuantize100 ClientLoc                      (Parm)
// unsigned char                  NewFlags                       (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientRoll                     (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View                           (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* ClientMovementBase             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   ClientBaseBoneName             (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ServerMoveDual(float TimeStamp0, const struct FEngine_Vector_NetQuantize10& InAccel0, unsigned char PendingFlags, uint32_t View0, float Timestamp, const struct FEngine_Vector_NetQuantize10& InAccel, const struct FEngine_Vector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UEngine_PrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDual");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMoveDual");

	AEngine_Character_ServerMoveDual_Params params;
	params.TimeStamp0 = TimeStamp0;
	params.InAccel0 = InAccel0;
	params.PendingFlags = PendingFlags;
	params.View0 = View0;
	params.Timestamp = Timestamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.NewFlags = NewFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementBase = ClientMovementBase;
	params.ClientBaseBoneName = ClientBaseBoneName;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ServerMove
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantize10 InAccel                        (Parm)
// struct FEngine_Vector_NetQuantize100 ClientLoc                      (Parm)
// unsigned char                  CompressedMoveFlags            (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientRoll                     (Parm, ZeroConstructor, IsPlainOldData)
// uint32_t                       View                           (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* ClientMovementBase             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   ClientBaseBoneName             (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ClientMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ServerMove(float Timestamp, const struct FEngine_Vector_NetQuantize10& InAccel, const struct FEngine_Vector_NetQuantize100& ClientLoc, unsigned char CompressedMoveFlags, unsigned char ClientRoll, uint32_t View, class UEngine_PrimitiveComponent* ClientMovementBase, const struct FName& ClientBaseBoneName, unsigned char ClientMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMove");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ServerMove");

	AEngine_Character_ServerMove_Params params;
	params.Timestamp = Timestamp;
	params.InAccel = InAccel;
	params.ClientLoc = ClientLoc;
	params.CompressedMoveFlags = CompressedMoveFlags;
	params.ClientRoll = ClientRoll;
	params.View = View;
	params.ClientMovementBase = ClientMovementBase;
	params.ClientBaseBoneName = ClientBaseBoneName;
	params.ClientMovementMode = ClientMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.RootMotionDebugClientPrintOnScreen
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)

void AEngine_Character::RootMotionDebugClientPrintOnScreen(const struct FString& inString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.RootMotionDebugClientPrintOnScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.RootMotionDebugClientPrintOnScreen");

	AEngine_Character_RootMotionDebugClientPrintOnScreen_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.PlayAnimMontage
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     AnimMontage                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPlayRate                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   StartSectionName               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Character::PlayAnimMontage(class UEngine_AnimMontage* AnimMontage, float InPlayRate, const struct FName& StartSectionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.PlayAnimMontage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.PlayAnimMontage");

	AEngine_Character_PlayAnimMontage_Params params;
	params.AnimMontage = AnimMontage;
	params.InPlayRate = InPlayRate;
	params.StartSectionName = StartSectionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.OnWalkingOffLedge
// (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 PreviousFloorImpactNormal      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 PreviousFloorContactNormal     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 PreviousLocation               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          TimeDelta                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::OnWalkingOffLedge(const struct FVector& PreviousFloorImpactNormal, const struct FVector& PreviousFloorContactNormal, const struct FVector& PreviousLocation, float TimeDelta)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnWalkingOffLedge");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnWalkingOffLedge");

	AEngine_Character_OnWalkingOffLedge_Params params;
	params.PreviousFloorImpactNormal = PreviousFloorImpactNormal;
	params.PreviousFloorContactNormal = PreviousFloorContactNormal;
	params.PreviousLocation = PreviousLocation;
	params.TimeDelta = TimeDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.OnRep_RootMotion
// (Final, Native, Public)

void AEngine_Character::OnRep_RootMotion()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_RootMotion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_RootMotion");

	AEngine_Character_OnRep_RootMotion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.OnRep_ReplicatedBasedMovement
// (Native, Public)

void AEngine_Character::OnRep_ReplicatedBasedMovement()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplicatedBasedMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplicatedBasedMovement");

	AEngine_Character_OnRep_ReplicatedBasedMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.OnRep_ReplayLastTransformUpdateTimeStamp
// (Final, Native, Public)

void AEngine_Character::OnRep_ReplayLastTransformUpdateTimeStamp()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplayLastTransformUpdateTimeStamp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplayLastTransformUpdateTimeStamp");

	AEngine_Character_OnRep_ReplayLastTransformUpdateTimeStamp_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.OnRep_IsCrouched
// (Native, Public)

void AEngine_Character::OnRep_IsCrouched()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_IsCrouched");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_IsCrouched");

	AEngine_Character_OnRep_IsCrouched_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.OnLaunched
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 LaunchVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bXYOverride                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bZOverride                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLaunched");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLaunched");

	AEngine_Character_OnLaunched_Params params;
	params.LaunchVelocity = LaunchVelocity;
	params.bXYOverride = bXYOverride;
	params.bZOverride = bZOverride;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.OnLanded
// (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
// struct FEngine_HitResult       Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void AEngine_Character::OnLanded(const struct FEngine_HitResult& Hit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLanded");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLanded");

	AEngine_Character_OnLanded_Params params;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.OnJumped
// (Native, Event, Public, BlueprintEvent)

void AEngine_Character::OnJumped()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.OnJumped");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.OnJumped");

	AEngine_Character_OnJumped_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.LaunchCharacter
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 LaunchVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bXYOverride                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bZOverride                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.LaunchCharacter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.LaunchCharacter");

	AEngine_Character_LaunchCharacter_Params params;
	params.LaunchVelocity = LaunchVelocity;
	params.bXYOverride = bXYOverride;
	params.bZOverride = bZOverride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.K2_UpdateCustomMovement
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::K2_UpdateCustomMovement(float DeltaTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_UpdateCustomMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_UpdateCustomMovement");

	AEngine_Character_K2_UpdateCustomMovement_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.K2_OnStartCrouch
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          HalfHeightAdjust               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScaledHalfHeightAdjust         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnStartCrouch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnStartCrouch");

	AEngine_Character_K2_OnStartCrouch_Params params;
	params.HalfHeightAdjust = HalfHeightAdjust;
	params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.K2_OnMovementModeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FEngine_Engine_EMovementMode> PrevMovementMode               (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EMovementMode> NewMovementMode                (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  PrevCustomMode                 (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  NewCustomMode                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::K2_OnMovementModeChanged(TEnumAsByte<FEngine_Engine_EMovementMode> PrevMovementMode, TEnumAsByte<FEngine_Engine_EMovementMode> NewMovementMode, unsigned char PrevCustomMode, unsigned char NewCustomMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnMovementModeChanged");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnMovementModeChanged");

	AEngine_Character_K2_OnMovementModeChanged_Params params;
	params.PrevMovementMode = PrevMovementMode;
	params.NewMovementMode = NewMovementMode;
	params.PrevCustomMode = PrevCustomMode;
	params.NewCustomMode = NewCustomMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.K2_OnEndCrouch
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          HalfHeightAdjust               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScaledHalfHeightAdjust         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnEndCrouch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnEndCrouch");

	AEngine_Character_K2_OnEndCrouch_Params params;
	params.HalfHeightAdjust = HalfHeightAdjust;
	params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.Jump
// (Native, Public, BlueprintCallable)

void AEngine_Character::Jump()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.Jump");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.Jump");

	AEngine_Character_Jump_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.IsPlayingRootMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Character::IsPlayingRootMotion()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingRootMotion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingRootMotion");

	AEngine_Character_IsPlayingRootMotion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.IsPlayingNetworkedRootMotionMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Character::IsPlayingNetworkedRootMotionMontage()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingNetworkedRootMotionMontage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingNetworkedRootMotionMontage");

	AEngine_Character_IsPlayingNetworkedRootMotionMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.IsJumpProvidingForce
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Character::IsJumpProvidingForce()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.IsJumpProvidingForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.IsJumpProvidingForce");

	AEngine_Character_IsJumpProvidingForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.HasAnyRootMotion
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Character::HasAnyRootMotion()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.HasAnyRootMotion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.HasAnyRootMotion");

	AEngine_Character_HasAnyRootMotion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.GetCurrentMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimMontage*     ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimMontage* AEngine_Character::GetCurrentMontage()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.GetCurrentMontage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.GetCurrentMontage");

	AEngine_Character_GetCurrentMontage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.GetBaseTranslationOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_Character::GetBaseTranslationOffset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.GetBaseTranslationOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.GetBaseTranslationOffset");

	AEngine_Character_GetBaseTranslationOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.GetBaseRotationOffsetRotator
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator AEngine_Character::GetBaseRotationOffsetRotator()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.GetBaseRotationOffsetRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.GetBaseRotationOffsetRotator");

	AEngine_Character_GetBaseRotationOffsetRotator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.GetAnimRootMotionTranslationScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Character::GetAnimRootMotionTranslationScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.GetAnimRootMotionTranslationScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.GetAnimRootMotionTranslationScale");

	AEngine_Character_GetAnimRootMotionTranslationScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.Crouch
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bClientSimulation              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::Crouch(bool bClientSimulation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.Crouch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.Crouch");

	AEngine_Character_Crouch_Params params;
	params.bClientSimulation = bClientSimulation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientVeryShortAdjustPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewLoc                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* NewBase                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   NewBaseBoneName                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHasBase                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bBaseRelativePosition          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ServerMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ClientVeryShortAdjustPosition(float Timestamp, const struct FVector& NewLoc, class UEngine_PrimitiveComponent* NewBase, const struct FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientVeryShortAdjustPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientVeryShortAdjustPosition");

	AEngine_Character_ClientVeryShortAdjustPosition_Params params;
	params.Timestamp = Timestamp;
	params.NewLoc = NewLoc;
	params.NewBase = NewBase;
	params.NewBaseBoneName = NewBaseBoneName;
	params.bHasBase = bHasBase;
	params.bBaseRelativePosition = bBaseRelativePosition;
	params.ServerMovementMode = ServerMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientCheatWalk
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_Character::ClientCheatWalk()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatWalk");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatWalk");

	AEngine_Character_ClientCheatWalk_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientCheatGhost
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_Character::ClientCheatGhost()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatGhost");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatGhost");

	AEngine_Character_ClientCheatGhost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientCheatFly
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_Character::ClientCheatFly()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatFly");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatFly");

	AEngine_Character_ClientCheatFly_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientAdjustRootMotionSourcePosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_RootMotionSourceGroup ServerRootMotion               (Parm)
// bool                           bHasAnimRootMotion             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ServerMontageTrackPosition     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ServerLoc                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantizeNormal ServerRotation                 (Parm)
// float                          ServerVelZ                     (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* ServerBase                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   ServerBoneName                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHasBase                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bBaseRelativePosition          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ServerMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ClientAdjustRootMotionSourcePosition(float Timestamp, const struct FEngine_RootMotionSourceGroup& ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FEngine_Vector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UEngine_PrimitiveComponent* ServerBase, const struct FName& ServerBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustRootMotionSourcePosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustRootMotionSourcePosition");

	AEngine_Character_ClientAdjustRootMotionSourcePosition_Params params;
	params.Timestamp = Timestamp;
	params.ServerRootMotion = ServerRootMotion;
	params.bHasAnimRootMotion = bHasAnimRootMotion;
	params.ServerMontageTrackPosition = ServerMontageTrackPosition;
	params.ServerLoc = ServerLoc;
	params.ServerRotation = ServerRotation;
	params.ServerVelZ = ServerVelZ;
	params.ServerBase = ServerBase;
	params.ServerBoneName = ServerBoneName;
	params.bHasBase = bHasBase;
	params.bBaseRelativePosition = bBaseRelativePosition;
	params.ServerMovementMode = ServerMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientAdjustRootMotionPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ServerMontageTrackPosition     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ServerLoc                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_Vector_NetQuantizeNormal ServerRotation                 (Parm)
// float                          ServerVelZ                     (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* ServerBase                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   ServerBoneName                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHasBase                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bBaseRelativePosition          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ServerMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FEngine_Vector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UEngine_PrimitiveComponent* ServerBase, const struct FName& ServerBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustRootMotionPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustRootMotionPosition");

	AEngine_Character_ClientAdjustRootMotionPosition_Params params;
	params.Timestamp = Timestamp;
	params.ServerMontageTrackPosition = ServerMontageTrackPosition;
	params.ServerLoc = ServerLoc;
	params.ServerRotation = ServerRotation;
	params.ServerVelZ = ServerVelZ;
	params.ServerBase = ServerBase;
	params.ServerBoneName = ServerBoneName;
	params.bHasBase = bHasBase;
	params.bBaseRelativePosition = bBaseRelativePosition;
	params.ServerMovementMode = ServerMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientAdjustPosition
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewLoc                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewVel                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* NewBase                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   NewBaseBoneName                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHasBase                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bBaseRelativePosition          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ServerMovementMode             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ClientAdjustPosition(float Timestamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UEngine_PrimitiveComponent* NewBase, const struct FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAdjustPosition");

	AEngine_Character_ClientAdjustPosition_Params params;
	params.Timestamp = Timestamp;
	params.NewLoc = NewLoc;
	params.NewVel = NewVel;
	params.NewBase = NewBase;
	params.NewBaseBoneName = NewBaseBoneName;
	params.bHasBase = bHasBase;
	params.bBaseRelativePosition = bBaseRelativePosition;
	params.ServerMovementMode = ServerMovementMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.ClientAckGoodMove
// (Net, Native, Event, Public, NetClient)
// Parameters:
// float                          Timestamp                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::ClientAckGoodMove(float Timestamp)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAckGoodMove");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientAckGoodMove");

	AEngine_Character_ClientAckGoodMove_Params params;
	params.Timestamp = Timestamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Character.CanJumpInternal
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Character::CanJumpInternal()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJumpInternal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJumpInternal");

	AEngine_Character_CanJumpInternal_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.CanJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Character::CanJump()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJump");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJump");

	AEngine_Character_CanJump_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.CanCrouch
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Character::CanCrouch()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.CanCrouch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.CanCrouch");

	AEngine_Character_CanCrouch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Character.CacheInitialMeshOffset
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 MeshRelativeLocation           (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                MeshRelativeRotation           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Character::CacheInitialMeshOffset(const struct FVector& MeshRelativeLocation, const struct FRotator& MeshRelativeRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Character.CacheInitialMeshOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Character.CacheInitialMeshOffset");

	AEngine_Character_CacheInitialMeshOffset_Params params;
	params.MeshRelativeLocation = MeshRelativeLocation;
	params.MeshRelativeRotation = MeshRelativeRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.UpdateSpline
// (Final, Native, Public, BlueprintCallable)

void UEngine_SplineComponent::UpdateSpline()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.UpdateSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.UpdateSpline");

	UEngine_SplineComponent_UpdateSpline_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetWorldLocationAtSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InLocation                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SplineComponent::SetWorldLocationAtSplinePoint(int PointIndex, const struct FVector& InLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetWorldLocationAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetWorldLocationAtSplinePoint");

	UEngine_SplineComponent_SetWorldLocationAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetUpVectorAtSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InUpVector                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetUpVectorAtSplinePoint(int PointIndex, const struct FVector& InUpVector, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetUpVectorAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetUpVectorAtSplinePoint");

	UEngine_SplineComponent_SetUpVectorAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.InUpVector = InUpVector;
	params.CoordinateSpace = CoordinateSpace;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetUnselectedSplineSegmentColor
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            SegmentColor                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SplineComponent::SetUnselectedSplineSegmentColor(const struct FLinearColor& SegmentColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetUnselectedSplineSegmentColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetUnselectedSplineSegmentColor");

	UEngine_SplineComponent_SetUnselectedSplineSegmentColor_Params params;
	params.SegmentColor = SegmentColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetTangentsAtSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InArriveTangent                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 InLeaveTangent                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetTangentsAtSplinePoint(int PointIndex, const struct FVector& InArriveTangent, const struct FVector& InLeaveTangent, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentsAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentsAtSplinePoint");

	UEngine_SplineComponent_SetTangentsAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.InArriveTangent = InArriveTangent;
	params.InLeaveTangent = InLeaveTangent;
	params.CoordinateSpace = CoordinateSpace;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetTangentAtSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InTangent                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetTangentAtSplinePoint(int PointIndex, const struct FVector& InTangent, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentAtSplinePoint");

	UEngine_SplineComponent_SetTangentAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.InTangent = InTangent;
	params.CoordinateSpace = CoordinateSpace;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetSplineWorldPoints
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FVector>         Points                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_SplineComponent::SetSplineWorldPoints(TArray<struct FVector> Points)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineWorldPoints");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineWorldPoints");

	UEngine_SplineComponent_SetSplineWorldPoints_Params params;
	params.Points = Points;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetSplinePointType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplinePointType> Type                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetSplinePointType(int PointIndex, TEnumAsByte<FEngine_Engine_ESplinePointType> Type, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePointType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePointType");

	UEngine_SplineComponent_SetSplinePointType_Params params;
	params.PointIndex = PointIndex;
	params.Type = Type;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetSplinePoints
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FVector>         Points                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetSplinePoints(TArray<struct FVector> Points, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePoints");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePoints");

	UEngine_SplineComponent_SetSplinePoints_Params params;
	params.Points = Points;
	params.CoordinateSpace = CoordinateSpace;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetSplineLocalPoints
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FVector>         Points                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_SplineComponent::SetSplineLocalPoints(TArray<struct FVector> Points)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineLocalPoints");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineLocalPoints");

	UEngine_SplineComponent_SetSplineLocalPoints_Params params;
	params.Points = Points;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetSelectedSplineSegmentColor
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            SegmentColor                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SplineComponent::SetSelectedSplineSegmentColor(const struct FLinearColor& SegmentColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSelectedSplineSegmentColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSelectedSplineSegmentColor");

	UEngine_SplineComponent_SetSelectedSplineSegmentColor_Params params;
	params.SegmentColor = SegmentColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetLocationAtSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InLocation                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetLocationAtSplinePoint(int PointIndex, const struct FVector& InLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetLocationAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetLocationAtSplinePoint");

	UEngine_SplineComponent_SetLocationAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.InLocation = InLocation;
	params.CoordinateSpace = CoordinateSpace;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetDrawDebug
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bShow                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetDrawDebug(bool bShow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetDrawDebug");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetDrawDebug");

	UEngine_SplineComponent_SetDrawDebug_Params params;
	params.bShow = bShow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetDefaultUpVector
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 UpVector                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetDefaultUpVector(const struct FVector& UpVector, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetDefaultUpVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetDefaultUpVector");

	UEngine_SplineComponent_SetDefaultUpVector_Params params;
	params.UpVector = UpVector;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetClosedLoopAtPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInClosedLoop                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          Key                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetClosedLoopAtPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetClosedLoopAtPosition");

	UEngine_SplineComponent_SetClosedLoopAtPosition_Params params;
	params.bInClosedLoop = bInClosedLoop;
	params.Key = Key;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.SetClosedLoop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInClosedLoop                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetClosedLoop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetClosedLoop");

	UEngine_SplineComponent_SetClosedLoop_Params params;
	params.bInClosedLoop = bInClosedLoop;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.RemoveSplinePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::RemoveSplinePoint(int Index, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.RemoveSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.RemoveSplinePoint");

	UEngine_SplineComponent_RemoveSplinePoint_Params params;
	params.Index = Index;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.IsClosedLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SplineComponent::IsClosedLoop()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.IsClosedLoop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.IsClosedLoop");

	UEngine_SplineComponent_IsClosedLoop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetWorldTangentAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline");

	UEngine_SplineComponent_GetWorldTangentAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldRotationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SplineComponent::GetWorldRotationAtTime(float Time, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtTime");

	UEngine_SplineComponent_GetWorldRotationAtTime_Params params;
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SplineComponent::GetWorldRotationAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline");

	UEngine_SplineComponent_GetWorldRotationAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldLocationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetWorldLocationAtTime(float Time, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtTime");

	UEngine_SplineComponent_GetWorldLocationAtTime_Params params;
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldLocationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetWorldLocationAtSplinePoint(int PointIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtSplinePoint");

	UEngine_SplineComponent_GetWorldLocationAtSplinePoint_Params params;
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetWorldLocationAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline");

	UEngine_SplineComponent_GetWorldLocationAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldDirectionAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtTime");

	UEngine_SplineComponent_GetWorldDirectionAtTime_Params params;
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetWorldDirectionAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline");

	UEngine_SplineComponent_GetWorldDirectionAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetVectorPropertyAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetVectorPropertyAtSplinePoint(int Index, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetVectorPropertyAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetVectorPropertyAtSplinePoint");

	UEngine_SplineComponent_GetVectorPropertyAtSplinePoint_Params params;
	params.Index = Index;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetVectorPropertyAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetVectorPropertyAtSplineInputKey(float InKey, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetVectorPropertyAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetVectorPropertyAtSplineInputKey");

	UEngine_SplineComponent_GetVectorPropertyAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetUpVectorAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtTime");

	UEngine_SplineComponent_GetUpVectorAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetUpVectorAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtSplinePoint");

	UEngine_SplineComponent_GetUpVectorAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetUpVectorAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtSplineInputKey");

	UEngine_SplineComponent_GetUpVectorAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetUpVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline");

	UEngine_SplineComponent_GetUpVectorAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseScale                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SplineComponent::GetTransformAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity, bool bUseScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtTime");

	UEngine_SplineComponent_GetTransformAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseScale                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SplineComponent::GetTransformAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtSplinePoint");

	UEngine_SplineComponent_GetTransformAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseScale                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SplineComponent::GetTransformAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtSplineInputKey");

	UEngine_SplineComponent_GetTransformAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseScale                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SplineComponent::GetTransformAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline");

	UEngine_SplineComponent_GetTransformAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetTangentAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtTime");

	UEngine_SplineComponent_GetTangentAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetTangentAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtSplinePoint");

	UEngine_SplineComponent_GetTangentAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetTangentAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtSplineInputKey");

	UEngine_SplineComponent_GetTangentAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetTangentAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline");

	UEngine_SplineComponent_GetTangentAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetSplinePointType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplinePointType> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_ESplinePointType> UEngine_SplineComponent::GetSplinePointType(int PointIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplinePointType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplinePointType");

	UEngine_SplineComponent_GetSplinePointType_Params params;
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetSplineLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetSplineLength()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplineLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplineLength");

	UEngine_SplineComponent_GetSplineLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetScaleAtTime(float Time, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtTime");

	UEngine_SplineComponent_GetScaleAtTime_Params params;
	params.Time = Time;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetScaleAtSplinePoint(int PointIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtSplinePoint");

	UEngine_SplineComponent_GetScaleAtSplinePoint_Params params;
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetScaleAtSplineInputKey(float InKey)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtSplineInputKey");

	UEngine_SplineComponent_GetScaleAtSplineInputKey_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetScaleAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline");

	UEngine_SplineComponent_GetScaleAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SplineComponent::GetRotationAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtTime");

	UEngine_SplineComponent_GetRotationAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SplineComponent::GetRotationAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtSplinePoint");

	UEngine_SplineComponent_GetRotationAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SplineComponent::GetRotationAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtSplineInputKey");

	UEngine_SplineComponent_GetRotationAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SplineComponent::GetRotationAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline");

	UEngine_SplineComponent_GetRotationAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetRollAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtTime");

	UEngine_SplineComponent_GetRollAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetRollAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtSplinePoint");

	UEngine_SplineComponent_GetRollAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtSplineInputKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetRollAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtSplineInputKey");

	UEngine_SplineComponent_GetRollAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRollAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetRollAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRollAtDistanceAlongSpline");

	UEngine_SplineComponent_GetRollAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetRightVectorAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtTime");

	UEngine_SplineComponent_GetRightVectorAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetRightVectorAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtSplinePoint");

	UEngine_SplineComponent_GetRightVectorAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetRightVectorAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtSplineInputKey");

	UEngine_SplineComponent_GetRightVectorAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetRightVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline");

	UEngine_SplineComponent_GetRightVectorAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetNumberOfSplineSegments
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SplineComponent::GetNumberOfSplineSegments()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumberOfSplineSegments");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumberOfSplineSegments");

	UEngine_SplineComponent_GetNumberOfSplineSegments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetNumberOfSplinePoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SplineComponent::GetNumberOfSplinePoints()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumberOfSplinePoints");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumberOfSplinePoints");

	UEngine_SplineComponent_GetNumberOfSplinePoints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetLocationAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtTime");

	UEngine_SplineComponent_GetLocationAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetLocationAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtSplinePoint");

	UEngine_SplineComponent_GetLocationAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetLocationAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtSplineInputKey");

	UEngine_SplineComponent_GetLocationAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetLocationAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline");

	UEngine_SplineComponent_GetLocationAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Tangent                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::GetLocationAndTangentAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, struct FVector* Location, struct FVector* Tangent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint");

	UEngine_SplineComponent_GetLocationAndTangentAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Location != nullptr)
		*Location = params.Location;
	if (Tangent != nullptr)
		*Tangent = params.Tangent;
}


// Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LocalLocation                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LocalTangent                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::GetLocalLocationAndTangentAtSplinePoint(int PointIndex, struct FVector* LocalLocation, struct FVector* LocalTangent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint");

	UEngine_SplineComponent_GetLocalLocationAndTangentAtSplinePoint_Params params;
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LocalLocation != nullptr)
		*LocalLocation = params.LocalLocation;
	if (LocalTangent != nullptr)
		*LocalTangent = params.LocalTangent;
}


// Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetLeaveTangentAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint");

	UEngine_SplineComponent_GetLeaveTangentAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetInputKeyAtDistanceAlongSpline(float Distance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline");

	UEngine_SplineComponent_GetInputKeyAtDistanceAlongSpline_Params params;
	params.Distance = Distance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetFloatPropertyAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetFloatPropertyAtSplinePoint(int Index, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetFloatPropertyAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetFloatPropertyAtSplinePoint");

	UEngine_SplineComponent_GetFloatPropertyAtSplinePoint_Params params;
	params.Index = Index;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetFloatPropertyAtSplineInputKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetFloatPropertyAtSplineInputKey(float InKey, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetFloatPropertyAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetFloatPropertyAtSplineInputKey");

	UEngine_SplineComponent_GetFloatPropertyAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::GetDistanceAlongSplineAtSplinePoint(int PointIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint");

	UEngine_SplineComponent_GetDistanceAlongSplineAtSplinePoint_Params params;
	params.PointIndex = PointIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtTime
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseConstantVelocity           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetDirectionAtTime(float Time, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseConstantVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtTime");

	UEngine_SplineComponent_GetDirectionAtTime_Params params;
	params.Time = Time;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseConstantVelocity = bUseConstantVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetDirectionAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtSplinePoint");

	UEngine_SplineComponent_GetDirectionAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtSplineInputKey
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InKey                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetDirectionAtSplineInputKey(float InKey, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtSplineInputKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtSplineInputKey");

	UEngine_SplineComponent_GetDirectionAtSplineInputKey_Params params;
	params.InKey = InKey;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetDirectionAtDistanceAlongSpline(float Distance, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline");

	UEngine_SplineComponent_GetDirectionAtDistanceAlongSpline_Params params;
	params.Distance = Distance;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetDefaultUpVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetDefaultUpVector(TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDefaultUpVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDefaultUpVector");

	UEngine_SplineComponent_GetDefaultUpVector_Params params;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.GetArriveTangentAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            PointIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::GetArriveTangentAtSplinePoint(int PointIndex, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetArriveTangentAtSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetArriveTangentAtSplinePoint");

	UEngine_SplineComponent_GetArriveTangentAtSplinePoint_Params params;
	params.PointIndex = PointIndex;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::FindUpVectorClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation");

	UEngine_SplineComponent_FindUpVectorClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindTransformClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseScale                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_SplineComponent::FindTransformClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUseScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindTransformClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindTransformClosestToWorldLocation");

	UEngine_SplineComponent_FindTransformClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;
	params.bUseScale = bUseScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindTangentClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::FindTangentClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindTangentClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindTangentClosestToWorldLocation");

	UEngine_SplineComponent_FindTangentClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindScaleClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::FindScaleClosestToWorldLocation(const struct FVector& WorldLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindScaleClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindScaleClosestToWorldLocation");

	UEngine_SplineComponent_FindScaleClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindRotationClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SplineComponent::FindRotationClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRotationClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRotationClosestToWorldLocation");

	UEngine_SplineComponent_FindRotationClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindRollClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::FindRollClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRollClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRollClosestToWorldLocation");

	UEngine_SplineComponent_FindRollClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::FindRightVectorClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation");

	UEngine_SplineComponent_FindRightVectorClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindLocationClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindLocationClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindLocationClosestToWorldLocation");

	UEngine_SplineComponent_FindLocationClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineComponent::FindInputKeyClosestToWorldLocation(const struct FVector& WorldLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation");

	UEngine_SplineComponent_FindInputKeyClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.FindDirectionClosestToWorldLocation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineComponent::FindDirectionClosestToWorldLocation(const struct FVector& WorldLocation, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindDirectionClosestToWorldLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindDirectionClosestToWorldLocation");

	UEngine_SplineComponent_FindDirectionClosestToWorldLocation_Params params;
	params.WorldLocation = WorldLocation;
	params.CoordinateSpace = CoordinateSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineComponent.ClearSplinePoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::ClearSplinePoints(bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.ClearSplinePoints");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.ClearSplinePoints");

	UEngine_SplineComponent_ClearSplinePoints_Params params;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.AddSplineWorldPoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Position                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SplineComponent::AddSplineWorldPoint(const struct FVector& Position)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineWorldPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineWorldPoint");

	UEngine_SplineComponent_AddSplineWorldPoint_Params params;
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.AddSplinePointAtIndex
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Position                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::AddSplinePointAtIndex(const struct FVector& Position, int Index, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplinePointAtIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplinePointAtIndex");

	UEngine_SplineComponent_AddSplinePointAtIndex_Params params;
	params.Position = Position;
	params.Index = Index;
	params.CoordinateSpace = CoordinateSpace;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.AddSplinePoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Position                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::AddSplinePoint(const struct FVector& Position, TEnumAsByte<FEngine_Engine_ESplineCoordinateSpace> CoordinateSpace, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplinePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplinePoint");

	UEngine_SplineComponent_AddSplinePoint_Params params;
	params.Position = Position;
	params.CoordinateSpace = CoordinateSpace;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.AddSplineLocalPoint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Position                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SplineComponent::AddSplineLocalPoint(const struct FVector& Position)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineLocalPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineLocalPoint");

	UEngine_SplineComponent_AddSplineLocalPoint_Params params;
	params.Position = Position;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.AddPoints
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FEngine_SplinePoint> Points                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::AddPoints(TArray<struct FEngine_SplinePoint> Points, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddPoints");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddPoints");

	UEngine_SplineComponent_AddPoints_Params params;
	params.Points = Points;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineComponent.AddPoint
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_SplinePoint     Point                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           bUpdateSpline                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineComponent::AddPoint(const struct FEngine_SplinePoint& Point, bool bUpdateSpline)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddPoint");

	UEngine_SplineComponent_AddPoint_Params params;
	params.Point = Point;
	params.bUpdateSpline = bUpdateSpline;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.StopDelayed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          DelayTime                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::StopDelayed(float DelayTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.StopDelayed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.StopDelayed");

	UEngine_AudioComponent_StopDelayed_Params params;
	params.DelayTime = DelayTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.Stop
// (Native, Public, BlueprintCallable)

void UEngine_AudioComponent::Stop()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Stop");

	UEngine_AudioComponent_Stop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetWaveParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundWave*       InWave                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetWaveParameter(const struct FName& InName, class UEngine_SoundWave* InWave)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetWaveParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetWaveParameter");

	UEngine_AudioComponent_SetWaveParameter_Params params;
	params.InName = InName;
	params.InWave = InWave;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetVolumeMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewVolumeMultiplier            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetVolumeMultiplier(float NewVolumeMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetVolumeMultiplier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetVolumeMultiplier");

	UEngine_AudioComponent_SetVolumeMultiplier_Params params;
	params.NewVolumeMultiplier = NewVolumeMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetUISound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInUISound                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetUISound(bool bInUISound)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetUISound");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetUISound");

	UEngine_AudioComponent_SetUISound_Params params;
	params.bInUISound = bInUISound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetSubmixSend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SoundSubmix*     Submix                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          SendLevel                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetSubmixSend(class UEngine_SoundSubmix* Submix, float SendLevel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSubmixSend");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSubmixSend");

	UEngine_AudioComponent_SetSubmixSend_Params params;
	params.Submix = Submix;
	params.SendLevel = SendLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetSourceBusSendPreEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SoundSourceBus*  SoundSourceBus                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          SourceBusSendLevel             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetSourceBusSendPreEffect(class UEngine_SoundSourceBus* SoundSourceBus, float SourceBusSendLevel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSourceBusSendPreEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSourceBusSendPreEffect");

	UEngine_AudioComponent_SetSourceBusSendPreEffect_Params params;
	params.SoundSourceBus = SoundSourceBus;
	params.SourceBusSendLevel = SourceBusSendLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetSourceBusSendPostEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SoundSourceBus*  SoundSourceBus                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          SourceBusSendLevel             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetSourceBusSendPostEffect(class UEngine_SoundSourceBus* SoundSourceBus, float SourceBusSendLevel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSourceBusSendPostEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSourceBusSendPostEffect");

	UEngine_AudioComponent_SetSourceBusSendPostEffect_Params params;
	params.SoundSourceBus = SoundSourceBus;
	params.SourceBusSendLevel = SourceBusSendLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetSound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SoundBase*       NewSound                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetSound(class UEngine_SoundBase* NewSound)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSound");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSound");

	UEngine_AudioComponent_SetSound_Params params;
	params.NewSound = NewSound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetPitchMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewPitchMultiplier             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetPitchMultiplier(float NewPitchMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPitchMultiplier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPitchMultiplier");

	UEngine_AudioComponent_SetPitchMultiplier_Params params;
	params.NewPitchMultiplier = NewPitchMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetPaused
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bPause                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetPaused(bool bPause)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPaused");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPaused");

	UEngine_AudioComponent_SetPaused_Params params;
	params.bPause = bPause;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetLowPassFilterFrequency
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InLowPassFilterFrequency       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetLowPassFilterFrequency(float InLowPassFilterFrequency)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetLowPassFilterFrequency");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetLowPassFilterFrequency");

	UEngine_AudioComponent_SetLowPassFilterFrequency_Params params;
	params.InLowPassFilterFrequency = InLowPassFilterFrequency;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetLowPassFilterEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           InLowPassFilterEnabled         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetLowPassFilterEnabled(bool InLowPassFilterEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetLowPassFilterEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetLowPassFilterEnabled");

	UEngine_AudioComponent_SetLowPassFilterEnabled_Params params;
	params.InLowPassFilterEnabled = InLowPassFilterEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetIntParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetIntParameter(const struct FName& InName, int inInt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetIntParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetIntParameter");

	UEngine_AudioComponent_SetIntParameter_Params params;
	params.InName = InName;
	params.inInt = inInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetFloatParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          InFloat                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetFloatParameter(const struct FName& InName, float InFloat)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetFloatParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetFloatParameter");

	UEngine_AudioComponent_SetFloatParameter_Params params;
	params.InName = InName;
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.SetBoolParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InBool                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::SetBoolParameter(const struct FName& InName, bool InBool)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetBoolParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetBoolParameter");

	UEngine_AudioComponent_SetBoolParameter_Params params;
	params.InName = InName;
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.Play
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::Play(float StartTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Play");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Play");

	UEngine_AudioComponent_Play_Params params;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.IsPlaying
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::IsPlaying()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.IsPlaying");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.IsPlaying");

	UEngine_AudioComponent_IsPlaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.HasCookedFFTData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::HasCookedFFTData()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.HasCookedFFTData");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.HasCookedFFTData");

	UEngine_AudioComponent_HasCookedFFTData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.HasCookedAmplitudeEnvelopeData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::HasCookedAmplitudeEnvelopeData()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.HasCookedAmplitudeEnvelopeData");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.HasCookedAmplitudeEnvelopeData");

	UEngine_AudioComponent_HasCookedAmplitudeEnvelopeData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.GetPlayState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FEngine_Engine_EAudioComponentPlayState ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FEngine_Engine_EAudioComponentPlayState UEngine_AudioComponent::GetPlayState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetPlayState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetPlayState");

	UEngine_AudioComponent_GetPlayState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.GetCookedFFTDataForAllPlayingSounds
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FEngine_SoundWaveSpectralDataPerSound> OutSoundWaveSpectralData       (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::GetCookedFFTDataForAllPlayingSounds(TArray<struct FEngine_SoundWaveSpectralDataPerSound>* OutSoundWaveSpectralData)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedFFTDataForAllPlayingSounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedFFTDataForAllPlayingSounds");

	UEngine_AudioComponent_GetCookedFFTDataForAllPlayingSounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSoundWaveSpectralData != nullptr)
		*OutSoundWaveSpectralData = params.OutSoundWaveSpectralData;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.GetCookedFFTData
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<float>                  FrequenciesToGet               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FEngine_SoundWaveSpectralData> OutSoundWaveSpectralData       (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::GetCookedFFTData(TArray<float> FrequenciesToGet, TArray<struct FEngine_SoundWaveSpectralData>* OutSoundWaveSpectralData)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedFFTData");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedFFTData");

	UEngine_AudioComponent_GetCookedFFTData_Params params;
	params.FrequenciesToGet = FrequenciesToGet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSoundWaveSpectralData != nullptr)
		*OutSoundWaveSpectralData = params.OutSoundWaveSpectralData;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.GetCookedEnvelopeDataForAllPlayingSounds
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FEngine_SoundWaveEnvelopeDataPerSound> OutEnvelopeData                (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::GetCookedEnvelopeDataForAllPlayingSounds(TArray<struct FEngine_SoundWaveEnvelopeDataPerSound>* OutEnvelopeData)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedEnvelopeDataForAllPlayingSounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedEnvelopeDataForAllPlayingSounds");

	UEngine_AudioComponent_GetCookedEnvelopeDataForAllPlayingSounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutEnvelopeData != nullptr)
		*OutEnvelopeData = params.OutEnvelopeData;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.GetCookedEnvelopeData
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// float                          OutEnvelopeData                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::GetCookedEnvelopeData(float* OutEnvelopeData)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedEnvelopeData");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.GetCookedEnvelopeData");

	UEngine_AudioComponent_GetCookedEnvelopeData_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutEnvelopeData != nullptr)
		*OutEnvelopeData = params.OutEnvelopeData;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.FadeOut
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          FadeOutDuration                (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeVolumeLevel                (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAudioFaderCurve FadeCurve                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::FadeOut(float FadeOutDuration, float FadeVolumeLevel, FEngine_Engine_EAudioFaderCurve FadeCurve)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeOut");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeOut");

	UEngine_AudioComponent_FadeOut_Params params;
	params.FadeOutDuration = FadeOutDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;
	params.FadeCurve = FadeCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.FadeIn
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          FadeInDuration                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeVolumeLevel                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAudioFaderCurve FadeCurve                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime, FEngine_Engine_EAudioFaderCurve FadeCurve)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeIn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeIn");

	UEngine_AudioComponent_FadeIn_Params params;
	params.FadeInDuration = FadeInDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;
	params.StartTime = StartTime;
	params.FadeCurve = FadeCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_SoundAttenuationSettings OutAttenuationSettings         (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AudioComponent::BP_GetAttenuationSettingsToApply(struct FEngine_SoundAttenuationSettings* OutAttenuationSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply");

	UEngine_AudioComponent_BP_GetAttenuationSettingsToApply_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutAttenuationSettings != nullptr)
		*OutAttenuationSettings = params.OutAttenuationSettings;

	return params.ReturnValue;
}


// Function Engine.AudioComponent.AdjustVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          AdjustVolumeDuration           (Parm, ZeroConstructor, IsPlainOldData)
// float                          AdjustVolumeLevel              (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAudioFaderCurve FadeCurve                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel, FEngine_Engine_EAudioFaderCurve FadeCurve)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustVolume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustVolume");

	UEngine_AudioComponent_AdjustVolume_Params params;
	params.AdjustVolumeDuration = AdjustVolumeDuration;
	params.AdjustVolumeLevel = AdjustVolumeLevel;
	params.FadeCurve = FadeCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioComponent.AdjustAttenuation
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_SoundAttenuationSettings InAttenuationSettings          (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_AudioComponent::AdjustAttenuation(const struct FEngine_SoundAttenuationSettings& InAttenuationSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustAttenuation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustAttenuation");

	UEngine_AudioComponent_AdjustAttenuation_Params params;
	params.InAttenuationSettings = InAttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.OnlineBlueprintCallProxyBase.Activate
// (Native, Public, BlueprintCallable)

void UEngine_OnlineBlueprintCallProxyBase::Activate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.OnlineBlueprintCallProxyBase.Activate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.OnlineBlueprintCallProxyBase.Activate");

	UEngine_OnlineBlueprintCallProxyBase_Activate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintAsyncActionBase.Activate
// (Native, Public, BlueprintCallable)

void UEngine_BlueprintAsyncActionBase::Activate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintAsyncActionBase.Activate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintAsyncActionBase.Activate");

	UEngine_BlueprintAsyncActionBase_Activate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.StopMovementImmediately
// (Native, Public, BlueprintCallable)

void UEngine_MovementComponent::StopMovementImmediately()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.StopMovementImmediately");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.StopMovementImmediately");

	UEngine_MovementComponent_StopMovementImmediately_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.SnapUpdatedComponentToPlane
// (Native, Public, BlueprintCallable)

void UEngine_MovementComponent::SnapUpdatedComponentToPlane()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SnapUpdatedComponentToPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SnapUpdatedComponentToPlane");

	UEngine_MovementComponent_SnapUpdatedComponentToPlane_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.SetUpdatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  NewUpdatedComponent            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_MovementComponent::SetUpdatedComponent(class UEngine_SceneComponent* NewUpdatedComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetUpdatedComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetUpdatedComponent");

	UEngine_MovementComponent_SetUpdatedComponent_Params params;
	params.NewUpdatedComponent = NewUpdatedComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.SetPlaneConstraintOrigin
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 PlaneOrigin                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MovementComponent::SetPlaneConstraintOrigin(const struct FVector& PlaneOrigin)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintOrigin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintOrigin");

	UEngine_MovementComponent_SetPlaneConstraintOrigin_Params params;
	params.PlaneOrigin = PlaneOrigin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.SetPlaneConstraintNormal
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 PlaneNormal                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MovementComponent::SetPlaneConstraintNormal(const struct FVector& PlaneNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintNormal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintNormal");

	UEngine_MovementComponent_SetPlaneConstraintNormal_Params params;
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.SetPlaneConstraintFromVectors
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Forward                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Up                             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MovementComponent::SetPlaneConstraintFromVectors(const struct FVector& Forward, const struct FVector& Up)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintFromVectors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintFromVectors");

	UEngine_MovementComponent_SetPlaneConstraintFromVectors_Params params;
	params.Forward = Forward;
	params.Up = Up;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.SetPlaneConstraintEnabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MovementComponent::SetPlaneConstraintEnabled(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintEnabled");

	UEngine_MovementComponent_SetPlaneConstraintEnabled_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.SetPlaneConstraintAxisSetting
// (Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_EPlaneConstraintAxisSetting NewAxisSetting                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MovementComponent::SetPlaneConstraintAxisSetting(FEngine_Engine_EPlaneConstraintAxisSetting NewAxisSetting)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintAxisSetting");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintAxisSetting");

	UEngine_MovementComponent_SetPlaneConstraintAxisSetting_Params params;
	params.NewAxisSetting = NewAxisSetting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.PhysicsVolumeChanged
// (Native, Public)
// Parameters:
// class AEngine_PhysicsVolume*   NewVolume                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MovementComponent::PhysicsVolumeChanged(class AEngine_PhysicsVolume* NewVolume)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.PhysicsVolumeChanged");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.PhysicsVolumeChanged");

	UEngine_MovementComponent_PhysicsVolumeChanged_Params params;
	params.NewVolume = NewVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MovementComponent.K2_MoveUpdatedComponent
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Delta                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bSweep                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_MovementComponent::K2_MoveUpdatedComponent(const struct FVector& Delta, const struct FRotator& NewRotation, bool bSweep, bool bTeleport, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_MoveUpdatedComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_MoveUpdatedComponent");

	UEngine_MovementComponent_K2_MoveUpdatedComponent_Params params;
	params.Delta = Delta;
	params.NewRotation = NewRotation;
	params.bSweep = bSweep;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.K2_GetModifiedMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_MovementComponent::K2_GetModifiedMaxSpeed()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetModifiedMaxSpeed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetModifiedMaxSpeed");

	UEngine_MovementComponent_K2_GetModifiedMaxSpeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.K2_GetMaxSpeedModifier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_MovementComponent::K2_GetMaxSpeedModifier()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetMaxSpeedModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetMaxSpeedModifier");

	UEngine_MovementComponent_K2_GetMaxSpeedModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.IsExceedingMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          MaxSpeed                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_MovementComponent::IsExceedingMaxSpeed(float MaxSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.IsExceedingMaxSpeed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.IsExceedingMaxSpeed");

	UEngine_MovementComponent_IsExceedingMaxSpeed_Params params;
	params.MaxSpeed = MaxSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.GetPlaneConstraintOrigin
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData)

struct FVector UEngine_MovementComponent::GetPlaneConstraintOrigin()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintOrigin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintOrigin");

	UEngine_MovementComponent_GetPlaneConstraintOrigin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.GetPlaneConstraintNormal
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData)

struct FVector UEngine_MovementComponent::GetPlaneConstraintNormal()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintNormal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintNormal");

	UEngine_MovementComponent_GetPlaneConstraintNormal_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.GetPlaneConstraintAxisSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FEngine_Engine_EPlaneConstraintAxisSetting ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FEngine_Engine_EPlaneConstraintAxisSetting UEngine_MovementComponent::GetPlaneConstraintAxisSetting()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintAxisSetting");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintAxisSetting");

	UEngine_MovementComponent_GetPlaneConstraintAxisSetting_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.GetPhysicsVolume
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_PhysicsVolume*   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PhysicsVolume* UEngine_MovementComponent::GetPhysicsVolume()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPhysicsVolume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPhysicsVolume");

	UEngine_MovementComponent_GetPhysicsVolume_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.GetMaxSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_MovementComponent::GetMaxSpeed()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetMaxSpeed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetMaxSpeed");

	UEngine_MovementComponent_GetMaxSpeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.GetGravityZ
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_MovementComponent::GetGravityZ()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetGravityZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetGravityZ");

	UEngine_MovementComponent_GetGravityZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.ConstrainNormalToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Normal                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_MovementComponent::ConstrainNormalToPlane(const struct FVector& Normal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainNormalToPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainNormalToPlane");

	UEngine_MovementComponent_ConstrainNormalToPlane_Params params;
	params.Normal = Normal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.ConstrainLocationToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_MovementComponent::ConstrainLocationToPlane(const struct FVector& Location)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainLocationToPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainLocationToPlane");

	UEngine_MovementComponent_ConstrainLocationToPlane_Params params;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MovementComponent.ConstrainDirectionToPlane
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_MovementComponent::ConstrainDirectionToPlane(const struct FVector& Direction)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainDirectionToPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainDirectionToPlane");

	UEngine_MovementComponent_ConstrainDirectionToPlane_Params params;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMovementComponent.StopMovementKeepPathing
// (Final, Native, Public, BlueprintCallable)

void UEngine_NavMovementComponent::StopMovementKeepPathing()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopMovementKeepPathing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopMovementKeepPathing");

	UEngine_NavMovementComponent_StopMovementKeepPathing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMovementComponent.StopActiveMovement
// (Native, Public, BlueprintCallable)

void UEngine_NavMovementComponent::StopActiveMovement()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopActiveMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopActiveMovement");

	UEngine_NavMovementComponent_StopActiveMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.NavMovementComponent.IsSwimming
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_NavMovementComponent::IsSwimming()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsSwimming");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsSwimming");

	UEngine_NavMovementComponent_IsSwimming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMovementComponent.IsMovingOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_NavMovementComponent::IsMovingOnGround()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsMovingOnGround");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsMovingOnGround");

	UEngine_NavMovementComponent_IsMovingOnGround_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMovementComponent.IsFlying
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_NavMovementComponent::IsFlying()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFlying");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFlying");

	UEngine_NavMovementComponent_IsFlying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMovementComponent.IsFalling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_NavMovementComponent::IsFalling()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFalling");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFalling");

	UEngine_NavMovementComponent_IsFalling_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.NavMovementComponent.IsCrouching
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_NavMovementComponent::IsCrouching()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsCrouching");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsCrouching");

	UEngine_NavMovementComponent_IsCrouching_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PawnMovementComponent.K2_GetInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PawnMovementComponent::K2_GetInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.K2_GetInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.K2_GetInputVector");

	UEngine_PawnMovementComponent_K2_GetInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PawnMovementComponent.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PawnMovementComponent::IsMoveInputIgnored()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.IsMoveInputIgnored");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.IsMoveInputIgnored");

	UEngine_PawnMovementComponent_IsMoveInputIgnored_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PawnMovementComponent.GetPendingInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PawnMovementComponent::GetPendingInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPendingInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPendingInputVector");

	UEngine_PawnMovementComponent_GetPendingInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PawnMovementComponent.GetPawnOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* UEngine_PawnMovementComponent::GetPawnOwner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPawnOwner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPawnOwner");

	UEngine_PawnMovementComponent_GetPawnOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PawnMovementComponent.GetLastInputVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PawnMovementComponent::GetLastInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetLastInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetLastInputVector");

	UEngine_PawnMovementComponent_GetLastInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PawnMovementComponent.ConsumeInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PawnMovementComponent::ConsumeInputVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.ConsumeInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.ConsumeInputVector");

	UEngine_PawnMovementComponent_ConsumeInputVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PawnMovementComponent.AddInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 WorldVector                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForce                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PawnMovementComponent::AddInputVector(const struct FVector& WorldVector, bool bForce)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.AddInputVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.AddInputVector");

	UEngine_PawnMovementComponent_AddInputVector_Params params;
	params.WorldVector = WorldVector;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InWalkableFloorZ               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorZ");

	UEngine_CharacterMovementComponent_SetWalkableFloorZ_Params params;
	params.InWalkableFloorZ = InWalkableFloorZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InWalkableFloorAngle           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorAngle");

	UEngine_CharacterMovementComponent_SetWalkableFloorAngle_Params params;
	params.InWalkableFloorAngle = InWalkableFloorAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetMovementMode
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EMovementMode> NewMovementMode                (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  NewCustomMode                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetMovementMode(TEnumAsByte<FEngine_Engine_EMovementMode> NewMovementMode, unsigned char NewCustomMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetMovementMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetMovementMode");

	UEngine_CharacterMovementComponent_SetMovementMode_Params params;
	params.NewMovementMode = NewMovementMode;
	params.NewCustomMode = NewCustomMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_NavAvoidanceMask GroupMask                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetGroupsToIgnoreMask(const struct FEngine_NavAvoidanceMask& GroupMask)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask");

	UEngine_CharacterMovementComponent_SetGroupsToIgnoreMask_Params params;
	params.GroupMask = GroupMask;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetGroupsToIgnore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            GroupFlags                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetGroupsToIgnore(int GroupFlags)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnore");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnore");

	UEngine_CharacterMovementComponent_SetGroupsToIgnore_Params params;
	params.GroupFlags = GroupFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_NavAvoidanceMask GroupMask                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetGroupsToAvoidMask(const struct FEngine_NavAvoidanceMask& GroupMask)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask");

	UEngine_CharacterMovementComponent_SetGroupsToAvoidMask_Params params;
	params.GroupMask = GroupMask;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetGroupsToAvoid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            GroupFlags                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetGroupsToAvoid(int GroupFlags)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoid");

	UEngine_CharacterMovementComponent_SetGroupsToAvoid_Params params;
	params.GroupFlags = GroupFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_NavAvoidanceMask GroupMask                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetAvoidanceGroupMask(const struct FEngine_NavAvoidanceMask& GroupMask)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask");

	UEngine_CharacterMovementComponent_SetAvoidanceGroupMask_Params params;
	params.GroupMask = GroupMask;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetAvoidanceGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            GroupFlags                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetAvoidanceGroup(int GroupFlags)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroup");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroup");

	UEngine_CharacterMovementComponent_SetAvoidanceGroup_Params params;
	params.GroupFlags = GroupFlags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.SetAvoidanceEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::SetAvoidanceEnabled(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceEnabled");

	UEngine_CharacterMovementComponent_SetAvoidanceEnabled_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::K2_GetWalkableFloorZ()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ");

	UEngine_CharacterMovementComponent_K2_GetWalkableFloorZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::K2_GetWalkableFloorAngle()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle");

	UEngine_CharacterMovementComponent_K2_GetWalkableFloorAngle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::K2_GetModifiedMaxAcceleration()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration");

	UEngine_CharacterMovementComponent_K2_GetModifiedMaxAcceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.K2_FindFloor
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 CapsuleLocation                (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_FindFloorResult FloorResult                    (Parm, OutParm)

void UEngine_CharacterMovementComponent::K2_FindFloor(const struct FVector& CapsuleLocation, struct FEngine_FindFloorResult* FloorResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_FindFloor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_FindFloor");

	UEngine_CharacterMovementComponent_K2_FindFloor_Params params;
	params.CapsuleLocation = CapsuleLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FloorResult != nullptr)
		*FloorResult = params.FloorResult;
}


// Function Engine.CharacterMovementComponent.K2_ComputeFloorDist
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 CapsuleLocation                (Parm, ZeroConstructor, IsPlainOldData)
// float                          LineDistance                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          SweepDistance                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          SweepRadius                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_FindFloorResult FloorResult                    (Parm, OutParm)

void UEngine_CharacterMovementComponent::K2_ComputeFloorDist(const struct FVector& CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, struct FEngine_FindFloorResult* FloorResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_ComputeFloorDist");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_ComputeFloorDist");

	UEngine_CharacterMovementComponent_K2_ComputeFloorDist_Params params;
	params.CapsuleLocation = CapsuleLocation;
	params.LineDistance = LineDistance;
	params.SweepDistance = SweepDistance;
	params.SweepRadius = SweepRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FloorResult != nullptr)
		*FloorResult = params.FloorResult;
}


// Function Engine.CharacterMovementComponent.IsWalking
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_CharacterMovementComponent::IsWalking()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalking");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalking");

	UEngine_CharacterMovementComponent_IsWalking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.IsWalkable
// (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEngine_HitResult       Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_CharacterMovementComponent::IsWalkable(const struct FEngine_HitResult& Hit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalkable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalkable");

	UEngine_CharacterMovementComponent_IsWalkable_Params params;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetValidPerchRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetValidPerchRadius()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetValidPerchRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetValidPerchRadius");

	UEngine_CharacterMovementComponent_GetValidPerchRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetPerchRadiusThreshold()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold");

	UEngine_CharacterMovementComponent_GetPerchRadiusThreshold_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMovementBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_PrimitiveComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_PrimitiveComponent* UEngine_CharacterMovementComponent::GetMovementBase()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMovementBase");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMovementBase");

	UEngine_CharacterMovementComponent_GetMovementBase_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMinAnalogSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetMinAnalogSpeed()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMinAnalogSpeed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMinAnalogSpeed");

	UEngine_CharacterMovementComponent_GetMinAnalogSpeed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxJumpHeightWithJumpTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetMaxJumpHeightWithJumpTime()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeightWithJumpTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeightWithJumpTime");

	UEngine_CharacterMovementComponent_GetMaxJumpHeightWithJumpTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxJumpHeight
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetMaxJumpHeight()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeight");

	UEngine_CharacterMovementComponent_GetMaxJumpHeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxBrakingDeceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetMaxBrakingDeceleration()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxBrakingDeceleration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxBrakingDeceleration");

	UEngine_CharacterMovementComponent_GetMaxBrakingDeceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetMaxAcceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetMaxAcceleration()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxAcceleration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxAcceleration");

	UEngine_CharacterMovementComponent_GetMaxAcceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetLastUpdateVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_CharacterMovementComponent::GetLastUpdateVelocity()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateVelocity");

	UEngine_CharacterMovementComponent_GetLastUpdateVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetLastUpdateRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_CharacterMovementComponent::GetLastUpdateRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateRotation");

	UEngine_CharacterMovementComponent_GetLastUpdateRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetLastUpdateLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_CharacterMovementComponent::GetLastUpdateLocation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetLastUpdateLocation");

	UEngine_CharacterMovementComponent_GetLastUpdateLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_CharacterMovementComponent::GetImpartedMovementBaseVelocity()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity");

	UEngine_CharacterMovementComponent_GetImpartedMovementBaseVelocity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetCurrentAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_CharacterMovementComponent::GetCurrentAcceleration()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCurrentAcceleration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCurrentAcceleration");

	UEngine_CharacterMovementComponent_GetCurrentAcceleration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetCharacterOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Character*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Character* UEngine_CharacterMovementComponent::GetCharacterOwner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCharacterOwner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCharacterOwner");

	UEngine_CharacterMovementComponent_GetCharacterOwner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.GetAnalogInputModifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CharacterMovementComponent::GetAnalogInputModifier()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetAnalogInputModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetAnalogInputModifier");

	UEngine_CharacterMovementComponent_GetAnalogInputModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CharacterMovementComponent.DisableMovement
// (Native, Public, BlueprintCallable)

void UEngine_CharacterMovementComponent::DisableMovement()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.DisableMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.DisableMovement");

	UEngine_CharacterMovementComponent_DisableMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.ClearAccumulatedForces
// (Native, Public, BlueprintCallable)

void UEngine_CharacterMovementComponent::ClearAccumulatedForces()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClearAccumulatedForces");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClearAccumulatedForces");

	UEngine_CharacterMovementComponent_ClearAccumulatedForces_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.CapsuleTouched
// (Native, Protected, HasOutParms)
// Parameters:
// class UEngine_PrimitiveComponent* OverlappedComp                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class AEngine_Actor*           Other                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* OtherComp                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// int                            OtherBodyIndex                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFromSweep                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       SweepResult                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_CharacterMovementComponent::CapsuleTouched(class UEngine_PrimitiveComponent* OverlappedComp, class AEngine_Actor* Other, class UEngine_PrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FEngine_HitResult& SweepResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CapsuleTouched");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CapsuleTouched");

	UEngine_CharacterMovementComponent_CapsuleTouched_Params params;
	params.OverlappedComp = OverlappedComp;
	params.Other = Other;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.CalcVelocity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Friction                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFluid                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          BrakingDeceleration            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CalcVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CalcVelocity");

	UEngine_CharacterMovementComponent_CalcVelocity_Params params;
	params.DeltaTime = DeltaTime;
	params.Friction = Friction;
	params.bFluid = bFluid;
	params.BrakingDeceleration = BrakingDeceleration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.AddImpulse
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Impulse                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bVelocityChange                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddImpulse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddImpulse");

	UEngine_CharacterMovementComponent_AddImpulse_Params params;
	params.Impulse = Impulse;
	params.bVelocityChange = bVelocityChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CharacterMovementComponent.AddForce
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 force                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CharacterMovementComponent::AddForce(const struct FVector& force)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddForce");

	UEngine_CharacterMovementComponent_AddForce_Params params;
	params.force = force;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetTrailSourceData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InFirstSocketName              (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   InSecondSocketName             (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETrailWidthMode> InWidthMode                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          InWidth                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetTrailSourceData(const struct FName& InFirstSocketName, const struct FName& InSecondSocketName, TEnumAsByte<FEngine_Engine_ETrailWidthMode> InWidthMode, float InWidth)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTrailSourceData");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTrailSourceData");

	UEngine_ParticleSystemComponent_SetTrailSourceData_Params params;
	params.InFirstSocketName = InFirstSocketName;
	params.InSecondSocketName = InSecondSocketName;
	params.InWidthMode = InWidthMode;
	params.InWidth = InWidth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetTemplate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ParticleSystem*  NewTemplate                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetTemplate(class UEngine_ParticleSystem* NewTemplate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTemplate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTemplate");

	UEngine_ParticleSystemComponent_SetTemplate_Params params;
	params.NewTemplate = NewTemplate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* Param                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetMaterialParameter(const struct FName& ParameterName, class UEngine_MaterialInterface* Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetMaterialParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetMaterialParameter");

	UEngine_ParticleSystemComponent_SetMaterialParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamTargetTangent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewTangentPoint                (Parm, ZeroConstructor, IsPlainOldData)
// int                            TargetIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetBeamTargetTangent(int EmitterIndex, const struct FVector& NewTangentPoint, int TargetIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetTangent");

	UEngine_ParticleSystemComponent_SetBeamTargetTangent_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTangentPoint = NewTangentPoint;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamTargetStrength
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          NewTargetStrength              (Parm, ZeroConstructor, IsPlainOldData)
// int                            TargetIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetBeamTargetStrength(int EmitterIndex, float NewTargetStrength, int TargetIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetStrength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetStrength");

	UEngine_ParticleSystemComponent_SetBeamTargetStrength_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTargetStrength = NewTargetStrength;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamTargetPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewTargetPoint                 (Parm, ZeroConstructor, IsPlainOldData)
// int                            TargetIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetBeamTargetPoint(int EmitterIndex, const struct FVector& NewTargetPoint, int TargetIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetPoint");

	UEngine_ParticleSystemComponent_SetBeamTargetPoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTargetPoint = NewTargetPoint;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamSourceTangent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewTangentPoint                (Parm, ZeroConstructor, IsPlainOldData)
// int                            SourceIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetBeamSourceTangent(int EmitterIndex, const struct FVector& NewTangentPoint, int SourceIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceTangent");

	UEngine_ParticleSystemComponent_SetBeamSourceTangent_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewTangentPoint = NewTangentPoint;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamSourceStrength
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          NewSourceStrength              (Parm, ZeroConstructor, IsPlainOldData)
// int                            SourceIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetBeamSourceStrength(int EmitterIndex, float NewSourceStrength, int SourceIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceStrength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceStrength");

	UEngine_ParticleSystemComponent_SetBeamSourceStrength_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewSourceStrength = NewSourceStrength;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamSourcePoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewSourcePoint                 (Parm, ZeroConstructor, IsPlainOldData)
// int                            SourceIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetBeamSourcePoint(int EmitterIndex, const struct FVector& NewSourcePoint, int SourceIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourcePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourcePoint");

	UEngine_ParticleSystemComponent_SetBeamSourcePoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewSourcePoint = NewSourcePoint;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetBeamEndPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewEndPoint                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetBeamEndPoint(int EmitterIndex, const struct FVector& NewEndPoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamEndPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamEndPoint");

	UEngine_ParticleSystemComponent_SetBeamEndPoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.NewEndPoint = NewEndPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.SetAutoAttachParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  Parent                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   SocketName                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::SetAutoAttachParams(class UEngine_SceneComponent* Parent, const struct FName& SocketName, TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetAutoAttachParams");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetAutoAttachParams");

	UEngine_ParticleSystemComponent_SetAutoAttachParams_Params params;
	params.Parent = Parent;
	params.SocketName = SocketName;
	params.LocationType = LocationType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.GetNumActiveParticles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_ParticleSystemComponent::GetNumActiveParticles()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNumActiveParticles");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNumActiveParticles");

	UEngine_ParticleSystemComponent_GetNumActiveParticles_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetNamedMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInterface* UEngine_ParticleSystemComponent::GetNamedMaterial(const struct FName& InName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNamedMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNamedMaterial");

	UEngine_ParticleSystemComponent_GetNamedMaterial_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamTargetTangent
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            TargetIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutTangentPoint                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystemComponent::GetBeamTargetTangent(int EmitterIndex, int TargetIndex, struct FVector* OutTangentPoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetTangent");

	UEngine_ParticleSystemComponent_GetBeamTargetTangent_Params params;
	params.EmitterIndex = EmitterIndex;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTangentPoint != nullptr)
		*OutTangentPoint = params.OutTangentPoint;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamTargetStrength
// (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            TargetIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutTargetStrength              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystemComponent::GetBeamTargetStrength(int EmitterIndex, int TargetIndex, float* OutTargetStrength)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetStrength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetStrength");

	UEngine_ParticleSystemComponent_GetBeamTargetStrength_Params params;
	params.EmitterIndex = EmitterIndex;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTargetStrength != nullptr)
		*OutTargetStrength = params.OutTargetStrength;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamTargetPoint
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            TargetIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutTargetPoint                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystemComponent::GetBeamTargetPoint(int EmitterIndex, int TargetIndex, struct FVector* OutTargetPoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamTargetPoint");

	UEngine_ParticleSystemComponent_GetBeamTargetPoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.TargetIndex = TargetIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTargetPoint != nullptr)
		*OutTargetPoint = params.OutTargetPoint;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamSourceTangent
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            SourceIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutTangentPoint                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystemComponent::GetBeamSourceTangent(int EmitterIndex, int SourceIndex, struct FVector* OutTangentPoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourceTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourceTangent");

	UEngine_ParticleSystemComponent_GetBeamSourceTangent_Params params;
	params.EmitterIndex = EmitterIndex;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTangentPoint != nullptr)
		*OutTangentPoint = params.OutTangentPoint;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamSourceStrength
// (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            SourceIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutSourceStrength              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystemComponent::GetBeamSourceStrength(int EmitterIndex, int SourceIndex, float* OutSourceStrength)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourceStrength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourceStrength");

	UEngine_ParticleSystemComponent_GetBeamSourceStrength_Params params;
	params.EmitterIndex = EmitterIndex;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSourceStrength != nullptr)
		*OutSourceStrength = params.OutSourceStrength;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamSourcePoint
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            SourceIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutSourcePoint                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystemComponent::GetBeamSourcePoint(int EmitterIndex, int SourceIndex, struct FVector* OutSourcePoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourcePoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamSourcePoint");

	UEngine_ParticleSystemComponent_GetBeamSourcePoint_Params params;
	params.EmitterIndex = EmitterIndex;
	params.SourceIndex = SourceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSourcePoint != nullptr)
		*OutSourcePoint = params.OutSourcePoint;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GetBeamEndPoint
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            EmitterIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutEndPoint                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystemComponent::GetBeamEndPoint(int EmitterIndex, struct FVector* OutEndPoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamEndPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetBeamEndPoint");

	UEngine_ParticleSystemComponent_GetBeamEndPoint_Params params;
	params.EmitterIndex = EmitterIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutEndPoint != nullptr)
		*OutEndPoint = params.OutEndPoint;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.GenerateParticleEvent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   InEventName                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          InEmitterTime                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InLocation                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InDirection                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InVelocity                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::GenerateParticleEvent(const struct FName& InEventName, float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GenerateParticleEvent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GenerateParticleEvent");

	UEngine_ParticleSystemComponent_GenerateParticleEvent_Params params;
	params.InEventName = InEventName;
	params.InEmitterTime = InEmitterTime;
	params.InLocation = InLocation;
	params.InDirection = InDirection;
	params.InVelocity = InVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.EndTrails
// (Final, Native, Public, BlueprintCallable)

void UEngine_ParticleSystemComponent::EndTrails()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.EndTrails");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.EndTrails");

	UEngine_ParticleSystemComponent_EndTrails_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* SourceMaterial                 (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* UEngine_ParticleSystemComponent::CreateNamedDynamicMaterialInstance(const struct FName& InName, class UEngine_MaterialInterface* SourceMaterial)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance");

	UEngine_ParticleSystemComponent_CreateNamedDynamicMaterialInstance_Params params;
	params.InName = InName;
	params.SourceMaterial = SourceMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ParticleSystemComponent.BeginTrails
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   InFirstSocketName              (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   InSecondSocketName             (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETrailWidthMode> InWidthMode                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          InWidth                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ParticleSystemComponent::BeginTrails(const struct FName& InFirstSocketName, const struct FName& InSecondSocketName, TEnumAsByte<FEngine_Engine_ETrailWidthMode> InWidthMode, float InWidth)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.BeginTrails");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.BeginTrails");

	UEngine_ParticleSystemComponent_BeginTrails_Params params;
	params.InFirstSocketName = InFirstSocketName;
	params.InSecondSocketName = InSecondSocketName;
	params.InWidthMode = InWidthMode;
	params.InWidth = InWidth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.UnPossess
// (Final, Native, Public, BlueprintCallable)

void AEngine_Controller::UnPossess()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.UnPossess");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.UnPossess");

	AEngine_Controller_UnPossess_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.StopMovement
// (Native, Public, BlueprintCallable)

void AEngine_Controller::StopMovement()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.StopMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.StopMovement");

	AEngine_Controller_StopMovement_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetInitialLocationAndRotation
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                NewRotation                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void AEngine_Controller::SetInitialLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetInitialLocationAndRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetInitialLocationAndRotation");

	AEngine_Controller_SetInitialLocationAndRotation_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetIgnoreMoveInput
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewMoveInput                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::SetIgnoreMoveInput(bool bNewMoveInput)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetIgnoreMoveInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetIgnoreMoveInput");

	AEngine_Controller_SetIgnoreMoveInput_Params params;
	params.bNewMoveInput = bNewMoveInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetIgnoreLookInput
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewLookInput                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::SetIgnoreLookInput(bool bNewLookInput)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetIgnoreLookInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetIgnoreLookInput");

	AEngine_Controller_SetIgnoreLookInput_Params params;
	params.bNewLookInput = bNewLookInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.SetControlRotation
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                NewRotation                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void AEngine_Controller::SetControlRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetControlRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetControlRotation");

	AEngine_Controller_SetControlRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ResetIgnoreMoveInput
// (Native, Public, BlueprintCallable)

void AEngine_Controller::ResetIgnoreMoveInput()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreMoveInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreMoveInput");

	AEngine_Controller_ResetIgnoreMoveInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ResetIgnoreLookInput
// (Native, Public, BlueprintCallable)

void AEngine_Controller::ResetIgnoreLookInput()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreLookInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreLookInput");

	AEngine_Controller_ResetIgnoreLookInput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ResetIgnoreInputFlags
// (Native, Public, BlueprintCallable)

void AEngine_Controller::ResetIgnoreInputFlags()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreInputFlags");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ResetIgnoreInputFlags");

	AEngine_Controller_ResetIgnoreInputFlags_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ReceiveUnPossess
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AEngine_Pawn*            UnpossessedPawn                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::ReceiveUnPossess(class AEngine_Pawn* UnpossessedPawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveUnPossess");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveUnPossess");

	AEngine_Controller_ReceiveUnPossess_Params params;
	params.UnpossessedPawn = UnpossessedPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ReceivePossess
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AEngine_Pawn*            PossessedPawn                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::ReceivePossess(class AEngine_Pawn* PossessedPawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceivePossess");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceivePossess");

	AEngine_Controller_ReceivePossess_Params params;
	params.PossessedPawn = PossessedPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ReceiveInstigatedAnyDamage
// (BlueprintAuthorityOnly, Event, Protected, BlueprintEvent)
// Parameters:
// float                          Damage                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DamageType*      DamageType                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           DamagedActor                   (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::ReceiveInstigatedAnyDamage(float Damage, class UEngine_DamageType* DamageType, class AEngine_Actor* DamagedActor, class AEngine_Actor* DamageCauser)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveInstigatedAnyDamage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveInstigatedAnyDamage");

	AEngine_Controller_ReceiveInstigatedAnyDamage_Params params;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.DamagedActor = DamagedActor;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.Possess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Pawn*            InPawn                         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::Possess(class AEngine_Pawn* InPawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.Possess");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.Possess");

	AEngine_Controller_Possess_Params params;
	params.InPawn = InPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnRep_PlayerState
// (Native, Public)

void AEngine_Controller::OnRep_PlayerState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_PlayerState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_PlayerState");

	AEngine_Controller_OnRep_PlayerState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.OnRep_Pawn
// (Native, Public)

void AEngine_Controller::OnRep_Pawn()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_Pawn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_Pawn");

	AEngine_Controller_OnRep_Pawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.LineOfSightTo
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           Other                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ViewPoint                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAlternateChecks               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Controller::LineOfSightTo(class AEngine_Actor* Other, const struct FVector& ViewPoint, bool bAlternateChecks)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.LineOfSightTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.LineOfSightTo");

	AEngine_Controller_LineOfSightTo_Params params;
	params.Other = Other;
	params.ViewPoint = ViewPoint;
	params.bAlternateChecks = bAlternateChecks;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.K2_GetPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* AEngine_Controller::K2_GetPawn()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.K2_GetPawn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.K2_GetPawn");

	AEngine_Controller_K2_GetPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Controller::IsPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsPlayerController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsPlayerController");

	AEngine_Controller_IsPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsMoveInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Controller::IsMoveInputIgnored()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsMoveInputIgnored");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsMoveInputIgnored");

	AEngine_Controller_IsMoveInputIgnored_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsLookInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Controller::IsLookInputIgnored()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLookInputIgnored");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLookInputIgnored");

	AEngine_Controller_IsLookInputIgnored_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsLocalPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Controller::IsLocalPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalPlayerController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalPlayerController");

	AEngine_Controller_IsLocalPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.IsLocalController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Controller::IsLocalController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalController");

	AEngine_Controller_IsLocalController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.GetViewTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_Controller::GetViewTarget()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetViewTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetViewTarget");

	AEngine_Controller_GetViewTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.GetDesiredRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator AEngine_Controller::GetDesiredRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetDesiredRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetDesiredRotation");

	AEngine_Controller_GetDesiredRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.GetControlRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator AEngine_Controller::GetControlRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetControlRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetControlRotation");

	AEngine_Controller_GetControlRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Controller.ClientSetRotation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bResetCamera                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetRotation");

	AEngine_Controller_ClientSetRotation_Params params;
	params.NewRotation = NewRotation;
	params.bResetCamera = bResetCamera;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.ClientSetLocation
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Controller::ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetLocation");

	AEngine_Controller_ClientSetLocation_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Controller.CastToPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerController* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PlayerController* AEngine_Controller::CastToPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Controller.CastToPlayerController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Controller.CastToPlayerController");

	AEngine_Controller_CastToPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalActor.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* NewDecalMaterial               (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DecalActor::SetDecalMaterial(class UEngine_MaterialInterface* NewDecalMaterial)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.SetDecalMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.SetDecalMaterial");

	AEngine_DecalActor_SetDecalMaterial_Params params;
	params.NewDecalMaterial = NewDecalMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalActor.GetDecalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_MaterialInterface* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInterface* AEngine_DecalActor::GetDecalMaterial()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.GetDecalMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.GetDecalMaterial");

	AEngine_DecalActor_GetDecalMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalActor.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* AEngine_DecalActor::CreateDynamicMaterialInstance()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.CreateDynamicMaterialInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.CreateDynamicMaterialInstance");

	AEngine_DecalActor_CreateDynamicMaterialInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraActor.GetAutoActivatePlayerIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AEngine_CameraActor::GetAutoActivatePlayerIndex()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraActor.GetAutoActivatePlayerIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraActor.GetAutoActivatePlayerIndex");

	AEngine_CameraActor_GetAutoActivatePlayerIndex_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraComponent.SetUseFieldOfViewForLOD
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInUseFieldOfViewForLOD        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetUseFieldOfViewForLOD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetUseFieldOfViewForLOD");

	UEngine_CameraComponent_SetUseFieldOfViewForLOD_Params params;
	params.bInUseFieldOfViewForLOD = bInUseFieldOfViewForLOD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetProjectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECameraProjectionMode> InProjectionMode               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetProjectionMode(TEnumAsByte<FEngine_Engine_ECameraProjectionMode> InProjectionMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetProjectionMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetProjectionMode");

	UEngine_CameraComponent_SetProjectionMode_Params params;
	params.InProjectionMode = InProjectionMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetPostProcessBlendWeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InPostProcessBlendWeight       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetPostProcessBlendWeight(float InPostProcessBlendWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetPostProcessBlendWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetPostProcessBlendWeight");

	UEngine_CameraComponent_SetPostProcessBlendWeight_Params params;
	params.InPostProcessBlendWeight = InPostProcessBlendWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetOrthoWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InOrthoWidth                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetOrthoWidth(float InOrthoWidth)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoWidth");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoWidth");

	UEngine_CameraComponent_SetOrthoWidth_Params params;
	params.InOrthoWidth = InOrthoWidth;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetOrthoNearClipPlane
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InOrthoNearClipPlane           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetOrthoNearClipPlane(float InOrthoNearClipPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoNearClipPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoNearClipPlane");

	UEngine_CameraComponent_SetOrthoNearClipPlane_Params params;
	params.InOrthoNearClipPlane = InOrthoNearClipPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetOrthoFarClipPlane
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InOrthoFarClipPlane            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetOrthoFarClipPlane(float InOrthoFarClipPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoFarClipPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetOrthoFarClipPlane");

	UEngine_CameraComponent_SetOrthoFarClipPlane_Params params;
	params.InOrthoFarClipPlane = InOrthoFarClipPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetFieldOfView
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          InFieldOfView                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetFieldOfView(float InFieldOfView)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetFieldOfView");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetFieldOfView");

	UEngine_CameraComponent_SetFieldOfView_Params params;
	params.InFieldOfView = InFieldOfView;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetConstraintAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInConstrainAspectRatio        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetConstraintAspectRatio(bool bInConstrainAspectRatio)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetConstraintAspectRatio");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetConstraintAspectRatio");

	UEngine_CameraComponent_SetConstraintAspectRatio_Params params;
	params.bInConstrainAspectRatio = bInConstrainAspectRatio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.SetAspectRatio
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InAspectRatio                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::SetAspectRatio(float InAspectRatio)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetAspectRatio");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.SetAspectRatio");

	UEngine_CameraComponent_SetAspectRatio_Params params;
	params.InAspectRatio = InAspectRatio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.RemoveBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class UEngine_BlendableInterface> InBlendableObject              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::RemoveBlendable(const TScriptInterface<class UEngine_BlendableInterface>& InBlendableObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.RemoveBlendable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.RemoveBlendable");

	UEngine_CameraComponent_RemoveBlendable_Params params;
	params.InBlendableObject = InBlendableObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.OnCameraMeshHiddenChanged
// (Final, Native, Protected, BlueprintCallable)

void UEngine_CameraComponent::OnCameraMeshHiddenChanged()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.OnCameraMeshHiddenChanged");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.OnCameraMeshHiddenChanged");

	UEngine_CameraComponent_OnCameraMeshHiddenChanged_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraComponent.GetCameraView
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_MinimalViewInfo DesiredView                    (Parm, OutParm)

void UEngine_CameraComponent::GetCameraView(float DeltaTime, struct FEngine_MinimalViewInfo* DesiredView)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.GetCameraView");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.GetCameraView");

	UEngine_CameraComponent_GetCameraView_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DesiredView != nullptr)
		*DesiredView = params.DesiredView;
}


// Function Engine.CameraComponent.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class UEngine_BlendableInterface> InBlendableObject              (Parm, ZeroConstructor, IsPlainOldData)
// float                          InWeight                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraComponent::AddOrUpdateBlendable(const TScriptInterface<class UEngine_BlendableInterface>& InBlendableObject, float InWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.AddOrUpdateBlendable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.AddOrUpdateBlendable");

	UEngine_CameraComponent_AddOrUpdateBlendable_Params params;
	params.InBlendableObject = InBlendableObject;
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.WasInputKeyJustReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::WasInputKeyJustReleased(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustReleased");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustReleased");

	AEngine_PlayerController_WasInputKeyJustReleased_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.WasInputKeyJustPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::WasInputKeyJustPressed(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustPressed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustPressed");

	AEngine_PlayerController_WasInputKeyJustPressed_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ToggleSpeaking
// (Exec, Native, Public)
// Parameters:
// bool                           bInSpeaking                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ToggleSpeaking(bool bInSpeaking)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ToggleSpeaking");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ToggleSpeaking");

	AEngine_PlayerController_ToggleSpeaking_Params params;
	params.bInSpeaking = bInSpeaking;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.TestServerLevelVisibilityChange
// (Final, Exec, Native, Private)
// Parameters:
// struct FName                   PackageName                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Filename                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::TestServerLevelVisibilityChange(const struct FName& PackageName, const struct FName& Filename)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.TestServerLevelVisibilityChange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.TestServerLevelVisibilityChange");

	AEngine_PlayerController_TestServerLevelVisibilityChange_Params params;
	params.PackageName = PackageName;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SwitchLevel
// (Exec, Native, Public)
// Parameters:
// struct FString                 URL                            (Parm, ZeroConstructor)

void AEngine_PlayerController::SwitchLevel(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SwitchLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SwitchLevel");

	AEngine_PlayerController_SwitchLevel_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.StopHapticEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FInputCore_InputCore_EControllerHand Hand                           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::StopHapticEffect(FInputCore_InputCore_EControllerHand Hand)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.StopHapticEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.StopHapticEffect");

	AEngine_PlayerController_StopHapticEffect_Params params;
	params.Hand = Hand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.StartFire
// (Exec, Native, Public)
// Parameters:
// unsigned char                  FireModeNum                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::StartFire(unsigned char FireModeNum)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.StartFire");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.StartFire");

	AEngine_PlayerController_StartFire_Params params;
	params.FireModeNum = FireModeNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetVirtualJoystickVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bVisible                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetVirtualJoystickVisibility(bool bVisible)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetVirtualJoystickVisibility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetVirtualJoystickVisibility");

	AEngine_PlayerController_SetVirtualJoystickVisibility_Params params;
	params.bVisible = bVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetViewTargetWithBlend
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           NewViewTarget                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendTime                      (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EViewTargetBlendFunction> BlendFunc                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendExp                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLockOutgoing                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetViewTargetWithBlend(class AEngine_Actor* NewViewTarget, float BlendTime, TEnumAsByte<FEngine_Engine_EViewTargetBlendFunction> BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetViewTargetWithBlend");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetViewTargetWithBlend");

	AEngine_PlayerController_SetViewTargetWithBlend_Params params;
	params.NewViewTarget = NewViewTarget;
	params.BlendTime = BlendTime;
	params.BlendFunc = BlendFunc;
	params.BlendExp = BlendExp;
	params.bLockOutgoing = bLockOutgoing;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetName
// (Exec, Native, Public)
// Parameters:
// struct FString                 S                              (Parm, ZeroConstructor)

void AEngine_PlayerController::SetName(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetName");

	AEngine_PlayerController_SetName_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetMouseLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            X                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            Y                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetMouseLocation(int X, int Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetMouseLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetMouseLocation");

	AEngine_PlayerController_SetMouseLocation_Params params;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetMouseCursorWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FCoreUObject_EMouseCursor> Cursor                         (Parm, ZeroConstructor, IsPlainOldData)
// class UUMG_UserWidget*         CursorWidget                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void AEngine_PlayerController::SetMouseCursorWidget(TEnumAsByte<FCoreUObject_EMouseCursor> Cursor, class UUMG_UserWidget* CursorWidget)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetMouseCursorWidget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetMouseCursorWidget");

	AEngine_PlayerController_SetMouseCursorWidget_Params params;
	params.Cursor = Cursor;
	params.CursorWidget = CursorWidget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetHapticsByValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Frequency                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Amplitude                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// FInputCore_InputCore_EControllerHand Hand                           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetHapticsByValue(float Frequency, float Amplitude, FInputCore_InputCore_EControllerHand Hand)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetHapticsByValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetHapticsByValue");

	AEngine_PlayerController_SetHapticsByValue_Params params;
	params.Frequency = Frequency;
	params.Amplitude = Amplitude;
	params.Hand = Hand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetDisableHaptics
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewDisabled                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetDisableHaptics(bool bNewDisabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetDisableHaptics");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetDisableHaptics");

	AEngine_PlayerController_SetDisableHaptics_Params params;
	params.bNewDisabled = bNewDisabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetControllerLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                  Color                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetControllerLightColor(const struct FColor& Color)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetControllerLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetControllerLightColor");

	AEngine_PlayerController_SetControllerLightColor_Params params;
	params.Color = Color;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetCinematicMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInCinematicMode               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHidePlayer                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsHUD                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsMovement               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsTurning                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetCinematicMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetCinematicMode");

	AEngine_PlayerController_SetCinematicMode_Params params;
	params.bInCinematicMode = bInCinematicMode;
	params.bHidePlayer = bHidePlayer;
	params.bAffectsHUD = bAffectsHUD;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetAudioListenerOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  AttachToComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetAudioListenerOverride(class UEngine_SceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerOverride");

	AEngine_PlayerController_SetAudioListenerOverride_Params params;
	params.AttachToComponent = AttachToComponent;
	params.Location = Location;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SetAudioListenerAttenuationOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  AttachToComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 AttenuationLocationOVerride    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::SetAudioListenerAttenuationOverride(class UEngine_SceneComponent* AttachToComponent, const struct FVector& AttenuationLocationOVerride)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerAttenuationOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerAttenuationOverride");

	AEngine_PlayerController_SetAudioListenerAttenuationOverride_Params params;
	params.AttachToComponent = AttachToComponent;
	params.AttenuationLocationOVerride = AttenuationLocationOVerride;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerViewSelf
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEngine_ViewTargetTransitionParams TransitionParams               (Parm)

void AEngine_PlayerController::ServerViewSelf(const struct FEngine_ViewTargetTransitionParams& TransitionParams)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewSelf");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewSelf");

	AEngine_PlayerController_ServerViewSelf_Params params;
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerViewPrevPlayer
// (Net, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerViewPrevPlayer()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewPrevPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewPrevPlayer");

	AEngine_PlayerController_ServerViewPrevPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerViewNextPlayer
// (Net, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerViewNextPlayer()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewNextPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewNextPlayer");

	AEngine_PlayerController_ServerViewNextPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerVerifyViewTarget
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerVerifyViewTarget()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerVerifyViewTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerVerifyViewTarget");

	AEngine_PlayerController_ServerVerifyViewTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUpdateMultipleLevelsVisibility
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<struct FEngine_UpdateLevelVisibilityLevelInfo> LevelVisibilities              (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void AEngine_PlayerController::ServerUpdateMultipleLevelsVisibility(TArray<struct FEngine_UpdateLevelVisibilityLevelInfo> LevelVisibilities)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateMultipleLevelsVisibility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateMultipleLevelsVisibility");

	AEngine_PlayerController_ServerUpdateMultipleLevelsVisibility_Params params;
	params.LevelVisibilities = LevelVisibilities;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUpdateLevelVisibility
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEngine_UpdateLevelVisibilityLevelInfo LevelVisibility                (ConstParm, Parm, ReferenceParm)

void AEngine_PlayerController::ServerUpdateLevelVisibility(const struct FEngine_UpdateLevelVisibilityLevelInfo& LevelVisibility)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateLevelVisibility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateLevelVisibility");

	AEngine_PlayerController_ServerUpdateLevelVisibility_Params params;
	params.LevelVisibility = LevelVisibility;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUpdateCamera
// (Net, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEngine_Vector_NetQuantize CamLoc                         (Parm)
// int                            CamPitchAndYaw                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ServerUpdateCamera(const struct FEngine_Vector_NetQuantize& CamLoc, int CamPitchAndYaw)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateCamera");

	AEngine_PlayerController_ServerUpdateCamera_Params params;
	params.CamLoc = CamLoc;
	params.CamPitchAndYaw = CamPitchAndYaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerUnmutePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEngine_UniqueNetIdRepl PlayerId                       (Parm)

void AEngine_PlayerController::ServerUnmutePlayer(const struct FEngine_UniqueNetIdRepl& PlayerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUnmutePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUnmutePlayer");

	AEngine_PlayerController_ServerUnmutePlayer_Params params;
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerToggleAILogging
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerToggleAILogging()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerToggleAILogging");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerToggleAILogging");

	AEngine_PlayerController_ServerToggleAILogging_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerShortTimeout
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerShortTimeout()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerShortTimeout");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerShortTimeout");

	AEngine_PlayerController_ServerShortTimeout_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerSetSpectatorWaiting
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// bool                           bWaiting                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ServerSetSpectatorWaiting(bool bWaiting)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorWaiting");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorWaiting");

	AEngine_PlayerController_ServerSetSpectatorWaiting_Params params;
	params.bWaiting = bWaiting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerSetSpectatorLocation
// (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FVector                 NewLoc                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewRot                         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ServerSetSpectatorLocation(const struct FVector& NewLoc, const struct FRotator& NewRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorLocation");

	AEngine_PlayerController_ServerSetSpectatorLocation_Params params;
	params.NewLoc = NewLoc;
	params.NewRot = NewRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerRestartPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerRestartPlayer()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerRestartPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerRestartPlayer");

	AEngine_PlayerController_ServerRestartPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerPause
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerPause()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerPause");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerPause");

	AEngine_PlayerController_ServerPause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerNotifyLoadedWorld
// (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FName                   WorldPackageName               (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ServerNotifyLoadedWorld(const struct FName& WorldPackageName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerNotifyLoadedWorld");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerNotifyLoadedWorld");

	AEngine_PlayerController_ServerNotifyLoadedWorld_Params params;
	params.WorldPackageName = WorldPackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerMutePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FEngine_UniqueNetIdRepl PlayerId                       (Parm)

void AEngine_PlayerController::ServerMutePlayer(const struct FEngine_UniqueNetIdRepl& PlayerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerMutePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerMutePlayer");

	AEngine_PlayerController_ServerMutePlayer_Params params;
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerExecRPC
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FString                 Msg                            (Parm, ZeroConstructor)

void AEngine_PlayerController::ServerExecRPC(const struct FString& Msg)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerExecRPC");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerExecRPC");

	AEngine_PlayerController_ServerExecRPC_Params params;
	params.Msg = Msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerExec
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 Msg                            (Parm, ZeroConstructor)

void AEngine_PlayerController::ServerExec(const struct FString& Msg)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerExec");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerExec");

	AEngine_PlayerController_ServerExec_Params params;
	params.Msg = Msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerCheckClientPossessionReliable
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerCheckClientPossessionReliable()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossessionReliable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossessionReliable");

	AEngine_PlayerController_ServerCheckClientPossessionReliable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerCheckClientPossession
// (Net, Native, Event, Public, NetServer, NetValidate)

void AEngine_PlayerController::ServerCheckClientPossession()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossession");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossession");

	AEngine_PlayerController_ServerCheckClientPossession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerChangeName
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FString                 S                              (Parm, ZeroConstructor)

void AEngine_PlayerController::ServerChangeName(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerChangeName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerChangeName");

	AEngine_PlayerController_ServerChangeName_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerCamera
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// struct FName                   NewMode                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ServerCamera(const struct FName& NewMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCamera");

	AEngine_PlayerController_ServerCamera_Params params;
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ServerAcknowledgePossession
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class AEngine_Pawn*            P                              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ServerAcknowledgePossession(class AEngine_Pawn* P)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerAcknowledgePossession");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerAcknowledgePossession");

	AEngine_PlayerController_ServerAcknowledgePossession_Params params;
	params.P = P;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.SendToConsole
// (Exec, Native, Public)
// Parameters:
// struct FString                 Command                        (Parm, ZeroConstructor)

void AEngine_PlayerController::SendToConsole(const struct FString& Command)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SendToConsole");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SendToConsole");

	AEngine_PlayerController_SendToConsole_Params params;
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.RestartLevel
// (Exec, Native, Public)

void AEngine_PlayerController::RestartLevel()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.RestartLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.RestartLevel");

	AEngine_PlayerController_RestartLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ResetControllerLightColor
// (Final, Native, Public, BlueprintCallable)

void AEngine_PlayerController::ResetControllerLightColor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ResetControllerLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ResetControllerLightColor");

	AEngine_PlayerController_ResetControllerLightColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ProjectWorldLocationToScreen
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenLocation                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           bPlayerViewportRelative        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::ProjectWorldLocationToScreen(const struct FVector& WorldLocation, bool bPlayerViewportRelative, struct FVector2D* ScreenLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ProjectWorldLocationToScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ProjectWorldLocationToScreen");

	AEngine_PlayerController_ProjectWorldLocationToScreen_Params params;
	params.WorldLocation = WorldLocation;
	params.bPlayerViewportRelative = bPlayerViewportRelative;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ScreenLocation != nullptr)
		*ScreenLocation = params.ScreenLocation;

	return params.ReturnValue;
}


// Function Engine.PlayerController.PlayHapticEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_HapticFeedbackEffect_Base* HapticEffect                   (Parm, ZeroConstructor, IsPlainOldData)
// FInputCore_InputCore_EControllerHand Hand                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLoop                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::PlayHapticEffect(class UEngine_HapticFeedbackEffect_Base* HapticEffect, FInputCore_InputCore_EControllerHand Hand, float Scale, bool bLoop)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayHapticEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayHapticEffect");

	AEngine_PlayerController_PlayHapticEffect_Params params;
	params.HapticEffect = HapticEffect;
	params.Hand = Hand;
	params.Scale = Scale;
	params.bLoop = bLoop;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.PlayDynamicForceFeedback
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// float                          Intensity                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsLeftLarge              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsLeftSmall              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsRightLarge             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsRightSmall             (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EDynamicForceFeedbackAction> Action                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)

void AEngine_PlayerController::PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, TEnumAsByte<FEngine_Engine_EDynamicForceFeedbackAction> Action, const struct FEngine_LatentActionInfo& LatentInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayDynamicForceFeedback");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayDynamicForceFeedback");

	AEngine_PlayerController_PlayDynamicForceFeedback_Params params;
	params.Intensity = Intensity;
	params.Duration = Duration;
	params.bAffectsLeftLarge = bAffectsLeftLarge;
	params.bAffectsLeftSmall = bAffectsLeftSmall;
	params.bAffectsRightLarge = bAffectsRightLarge;
	params.bAffectsRightSmall = bAffectsRightSmall;
	params.Action = Action;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.Pause
// (Exec, Native, Public)

void AEngine_PlayerController::Pause()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Pause");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Pause");

	AEngine_PlayerController_Pause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.OnServerStartedVisualLogger
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bIsLogging                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::OnServerStartedVisualLogger(bool bIsLogging)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.OnServerStartedVisualLogger");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.OnServerStartedVisualLogger");

	AEngine_PlayerController_OnServerStartedVisualLogger_Params params;
	params.bIsLogging = bIsLogging;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.LocalTravel
// (Exec, Native, Public)
// Parameters:
// struct FString                 URL                            (Parm, ZeroConstructor)

void AEngine_PlayerController::LocalTravel(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.LocalTravel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.LocalTravel");

	AEngine_PlayerController_LocalTravel_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.K2_ClientPlayForceFeedback
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ForceFeedbackEffect* ForceFeedbackEffect            (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLooping                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIgnoreTimeDilation            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPlayWhilePaused               (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::K2_ClientPlayForceFeedback(class UEngine_ForceFeedbackEffect* ForceFeedbackEffect, const struct FName& Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.K2_ClientPlayForceFeedback");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.K2_ClientPlayForceFeedback");

	AEngine_PlayerController_K2_ClientPlayForceFeedback_Params params;
	params.ForceFeedbackEffect = ForceFeedbackEffect;
	params.Tag = Tag;
	params.bLooping = bLooping;
	params.bIgnoreTimeDilation = bIgnoreTimeDilation;
	params.bPlayWhilePaused = bPlayWhilePaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.IsInputKeyDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::IsInputKeyDown(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsInputKeyDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsInputKeyDown");

	AEngine_PlayerController_IsInputKeyDown_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetViewportSize
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            SizeX                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            SizeY                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::GetViewportSize(int* SizeX, int* SizeY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetViewportSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetViewportSize");

	AEngine_PlayerController_GetViewportSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SizeX != nullptr)
		*SizeX = params.SizeX;
	if (SizeY != nullptr)
		*SizeY = params.SizeY;
}


// Function Engine.PlayerController.GetSpectatorPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_SpectatorPawn*   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_SpectatorPawn* AEngine_PlayerController::GetSpectatorPawn()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetSpectatorPawn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetSpectatorPawn");

	AEngine_PlayerController_GetSpectatorPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetMousePosition
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          LocationX                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          LocationY                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::GetMousePosition(float* LocationX, float* LocationY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetMousePosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetMousePosition");

	AEngine_PlayerController_GetMousePosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LocationX != nullptr)
		*LocationX = params.LocationX;
	if (LocationY != nullptr)
		*LocationY = params.LocationY;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetInputVectorKeyState
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_PlayerController::GetInputVectorKeyState(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputVectorKeyState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputVectorKeyState");

	AEngine_PlayerController_GetInputVectorKeyState_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetInputTouchState
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          LocationX                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          LocationY                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           bIsCurrentlyPressed            (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::GetInputTouchState(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputTouchState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputTouchState");

	AEngine_PlayerController_GetInputTouchState_Params params;
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LocationX != nullptr)
		*LocationX = params.LocationX;
	if (LocationY != nullptr)
		*LocationY = params.LocationY;
	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = params.bIsCurrentlyPressed;
}


// Function Engine.PlayerController.GetInputMouseDelta
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          DeltaX                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          DeltaY                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::GetInputMouseDelta(float* DeltaX, float* DeltaY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMouseDelta");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMouseDelta");

	AEngine_PlayerController_GetInputMouseDelta_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DeltaX != nullptr)
		*DeltaX = params.DeltaX;
	if (DeltaY != nullptr)
		*DeltaY = params.DeltaY;
}


// Function Engine.PlayerController.GetInputMotionState
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Tilt                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 RotationRate                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Gravity                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Acceleration                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::GetInputMotionState(struct FVector* Tilt, struct FVector* RotationRate, struct FVector* Gravity, struct FVector* Acceleration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMotionState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMotionState");

	AEngine_PlayerController_GetInputMotionState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Tilt != nullptr)
		*Tilt = params.Tilt;
	if (RotationRate != nullptr)
		*RotationRate = params.RotationRate;
	if (Gravity != nullptr)
		*Gravity = params.Gravity;
	if (Acceleration != nullptr)
		*Acceleration = params.Acceleration;
}


// Function Engine.PlayerController.GetInputKeyTimeDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_PlayerController::GetInputKeyTimeDown(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputKeyTimeDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputKeyTimeDown");

	AEngine_PlayerController_GetInputKeyTimeDown_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetInputAnalogStickState
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_EControllerAnalogStick> WhichStick                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          StickX                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          StickY                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::GetInputAnalogStickState(TEnumAsByte<FEngine_Engine_EControllerAnalogStick> WhichStick, float* StickX, float* StickY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogStickState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogStickState");

	AEngine_PlayerController_GetInputAnalogStickState_Params params;
	params.WhichStick = WhichStick;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (StickX != nullptr)
		*StickX = params.StickX;
	if (StickY != nullptr)
		*StickY = params.StickY;
}


// Function Engine.PlayerController.GetInputAnalogKeyState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_PlayerController::GetInputAnalogKeyState(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogKeyState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogKeyState");

	AEngine_PlayerController_GetInputAnalogKeyState_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_HUD*             ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_HUD* AEngine_PlayerController::GetHUD()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHUD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHUD");

	AEngine_PlayerController_GetHUD_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderFingerForObjects
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitResult                      (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::GetHitResultUnderFingerForObjects(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, struct FEngine_HitResult* HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerForObjects");

	AEngine_PlayerController_GetHitResultUnderFingerForObjects_Params params;
	params.FingerIndex = FingerIndex;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderFingerByChannel
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitResult                      (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::GetHitResultUnderFingerByChannel(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, struct FEngine_HitResult* HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerByChannel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerByChannel");

	AEngine_PlayerController_GetHitResultUnderFingerByChannel_Params params;
	params.FingerIndex = FingerIndex;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderFinger
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECollisionChannel> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitResult                      (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::GetHitResultUnderFinger(TEnumAsByte<FInputCore_InputCore_ETouchIndex> FingerIndex, TEnumAsByte<FEngine_Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, struct FEngine_HitResult* HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFinger");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFinger");

	AEngine_PlayerController_GetHitResultUnderFinger_Params params;
	params.FingerIndex = FingerIndex;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderCursorForObjects
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitResult                      (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::GetHitResultUnderCursorForObjects(TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, struct FEngine_HitResult* HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorForObjects");

	AEngine_PlayerController_GetHitResultUnderCursorForObjects_Params params;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderCursorByChannel
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitResult                      (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::GetHitResultUnderCursorByChannel(TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, struct FEngine_HitResult* HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorByChannel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorByChannel");

	AEngine_PlayerController_GetHitResultUnderCursorByChannel_Params params;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetHitResultUnderCursor
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionChannel> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       HitResult                      (Parm, OutParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::GetHitResultUnderCursor(TEnumAsByte<FEngine_Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, struct FEngine_HitResult* HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursor");

	AEngine_PlayerController_GetHitResultUnderCursor_Params params;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HitResult != nullptr)
		*HitResult = params.HitResult;

	return params.ReturnValue;
}


// Function Engine.PlayerController.GetFocalLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_PlayerController::GetFocalLocation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetFocalLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetFocalLocation");

	AEngine_PlayerController_GetFocalLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.FOV
// (Exec, Native, Public)
// Parameters:
// float                          NewFOV                         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::FOV(float NewFOV)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.FOV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.FOV");

	AEngine_PlayerController_FOV_Params params;
	params.NewFOV = NewFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.EnableCheats
// (Exec, Native, Public)

void AEngine_PlayerController::EnableCheats()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.EnableCheats");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.EnableCheats");

	AEngine_PlayerController_EnableCheats_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.DeprojectScreenPositionToWorld
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldLocation                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldDirection                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectScreenPositionToWorld");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectScreenPositionToWorld");

	AEngine_PlayerController_DeprojectScreenPositionToWorld_Params params;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldLocation != nullptr)
		*WorldLocation = params.WorldLocation;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;

	return params.ReturnValue;
}


// Function Engine.PlayerController.DeprojectMousePositionToWorld
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 WorldLocation                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldDirection                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::DeprojectMousePositionToWorld(struct FVector* WorldLocation, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectMousePositionToWorld");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectMousePositionToWorld");

	AEngine_PlayerController_DeprojectMousePositionToWorld_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldLocation != nullptr)
		*WorldLocation = params.WorldLocation;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;

	return params.ReturnValue;
}


// Function Engine.PlayerController.ConsoleKey
// (Exec, Native, Public)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)

void AEngine_PlayerController::ConsoleKey(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ConsoleKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ConsoleKey");

	AEngine_PlayerController_ConsoleKey_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientWasKicked
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FText                   KickReason                     (ConstParm, Parm, ReferenceParm)

void AEngine_PlayerController::ClientWasKicked(const struct FText& KickReason)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientWasKicked");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientWasKicked");

	AEngine_PlayerController_ClientWasKicked_Params params;
	params.KickReason = KickReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientVoiceHandshakeComplete
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientVoiceHandshakeComplete()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientVoiceHandshakeComplete");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientVoiceHandshakeComplete");

	AEngine_PlayerController_ClientVoiceHandshakeComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientUpdateMultipleLevelsStreamingStatus
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TArray<struct FEngine_UpdateLevelStreamingLevelStatus> LevelStatuses                  (ConstParm, Parm, ZeroConstructor, ReferenceParm)

void AEngine_PlayerController::ClientUpdateMultipleLevelsStreamingStatus(TArray<struct FEngine_UpdateLevelStreamingLevelStatus> LevelStatuses)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateMultipleLevelsStreamingStatus");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateMultipleLevelsStreamingStatus");

	AEngine_PlayerController_ClientUpdateMultipleLevelsStreamingStatus_Params params;
	params.LevelStatuses = LevelStatuses;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FName                   PackageName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNewShouldBeLoaded             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNewShouldBeVisible            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bNewShouldBlockOnLoad          (Parm, ZeroConstructor, IsPlainOldData)
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientUpdateLevelStreamingStatus(const struct FName& PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateLevelStreamingStatus");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateLevelStreamingStatus");

	AEngine_PlayerController_ClientUpdateLevelStreamingStatus_Params params;
	params.PackageName = PackageName;
	params.bNewShouldBeLoaded = bNewShouldBeLoaded;
	params.bNewShouldBeVisible = bNewShouldBeVisible;
	params.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientUnmutePlayer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FEngine_UniqueNetIdRepl PlayerId                       (Parm)

void AEngine_PlayerController::ClientUnmutePlayer(const struct FEngine_UniqueNetIdRepl& PlayerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUnmutePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUnmutePlayer");

	AEngine_PlayerController_ClientUnmutePlayer_Params params;
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientTravelInternal
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FString                 URL                            (Parm, ZeroConstructor)
// TEnumAsByte<FEngine_Engine_ETravelType> TravelType                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSeamless                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FGuid                   MapPackageGuid                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientTravelInternal(const struct FString& URL, TEnumAsByte<FEngine_Engine_ETravelType> TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravelInternal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravelInternal");

	AEngine_PlayerController_ClientTravelInternal_Params params;
	params.URL = URL;
	params.TravelType = TravelType;
	params.bSeamless = bSeamless;
	params.MapPackageGuid = MapPackageGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientTravel
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FString                 URL                            (Parm, ZeroConstructor)
// TEnumAsByte<FEngine_Engine_ETravelType> TravelType                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSeamless                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FGuid                   MapPackageGuid                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientTravel(const struct FString& URL, TEnumAsByte<FEngine_Engine_ETravelType> TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravel");

	AEngine_PlayerController_ClientTravel_Params params;
	params.URL = URL;
	params.TravelType = TravelType;
	params.bSeamless = bSeamless;
	params.MapPackageGuid = MapPackageGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientTeamMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AEngine_PlayerState*     SenderPlayerState              (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 S                              (Parm, ZeroConstructor)
// struct FName                   Type                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          MsgLifeTime                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientTeamMessage(class AEngine_PlayerState* SenderPlayerState, const struct FString& S, const struct FName& Type, float MsgLifeTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTeamMessage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTeamMessage");

	AEngine_PlayerController_ClientTeamMessage_Params params;
	params.SenderPlayerState = SenderPlayerState;
	params.S = S;
	params.Type = Type;
	params.MsgLifeTime = MsgLifeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStopForceFeedback
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UEngine_ForceFeedbackEffect* ForceFeedbackEffect            (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientStopForceFeedback(class UEngine_ForceFeedbackEffect* ForceFeedbackEffect, const struct FName& Tag)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopForceFeedback");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopForceFeedback");

	AEngine_PlayerController_ClientStopForceFeedback_Params params;
	params.ForceFeedbackEffect = ForceFeedbackEffect;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStopCameraShake
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UClass*                  Shake                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bImmediately                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientStopCameraShake(class UClass* Shake, bool bImmediately)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraShake");

	AEngine_PlayerController_ClientStopCameraShake_Params params;
	params.Shake = Shake;
	params.bImmediately = bImmediately;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStopCameraAnim
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UEngine_CameraAnim*      AnimToStop                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientStopCameraAnim(class UEngine_CameraAnim* AnimToStop)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraAnim");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraAnim");

	AEngine_PlayerController_ClientStopCameraAnim_Params params;
	params.AnimToStop = AnimToStop;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientStartOnlineSession
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientStartOnlineSession()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStartOnlineSession");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStartOnlineSession");

	AEngine_PlayerController_ClientStartOnlineSession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSpawnCameraLensEffect
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UClass*                  LensEffectEmitterClass         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSpawnCameraLensEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSpawnCameraLensEffect");

	AEngine_PlayerController_ClientSpawnCameraLensEffect_Params params;
	params.LensEffectEmitterClass = LensEffectEmitterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetViewTarget
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AEngine_Actor*           A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_ViewTargetTransitionParams TransitionParams               (Parm)

void AEngine_PlayerController::ClientSetViewTarget(class AEngine_Actor* A, const struct FEngine_ViewTargetTransitionParams& TransitionParams)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetViewTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetViewTarget");

	AEngine_PlayerController_ClientSetViewTarget_Params params;
	params.A = A;
	params.TransitionParams = TransitionParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetSpectatorWaiting
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bWaiting                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientSetSpectatorWaiting(bool bWaiting)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetSpectatorWaiting");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetSpectatorWaiting");

	AEngine_PlayerController_ClientSetSpectatorWaiting_Params params;
	params.bWaiting = bWaiting;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetHUD
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class UClass*                  NewHUDClass                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientSetHUD(class UClass* NewHUDClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetHUD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetHUD");

	AEngine_PlayerController_ClientSetHUD_Params params;
	params.NewHUDClass = NewHUDClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ForceDuration                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            CinematicTextureGroups         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientSetForceMipLevelsToBeResident(class UEngine_MaterialInterface* Material, float ForceDuration, int CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident");

	AEngine_PlayerController_ClientSetForceMipLevelsToBeResident_Params params;
	params.Material = Material;
	params.ForceDuration = ForceDuration;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetCinematicMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bInCinematicMode               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsMovement               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsTurning                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsHUD                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCinematicMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCinematicMode");

	AEngine_PlayerController_ClientSetCinematicMode_Params params;
	params.bInCinematicMode = bInCinematicMode;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;
	params.bAffectsHUD = bAffectsHUD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetCameraMode
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FName                   NewCamMode                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientSetCameraMode(const struct FName& NewCamMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraMode");

	AEngine_PlayerController_ClientSetCameraMode_Params params;
	params.NewCamMode = NewCamMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetCameraFade
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// bool                           bEnableFading                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  FadeColor                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               FadeAlpha                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFadeAudio                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraFade");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraFade");

	AEngine_PlayerController_ClientSetCameraFade_Params params;
	params.bEnableFading = bEnableFading;
	params.FadeColor = FadeColor;
	params.FadeAlpha = FadeAlpha;
	params.FadeTime = FadeTime;
	params.bFadeAudio = bFadeAudio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientSetBlockOnAsyncLoading
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientSetBlockOnAsyncLoading()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetBlockOnAsyncLoading");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetBlockOnAsyncLoading");

	AEngine_PlayerController_ClientSetBlockOnAsyncLoading_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientReturnToMainMenuWithTextReason
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FText                   ReturnReason                   (ConstParm, Parm, ReferenceParm)

void AEngine_PlayerController::ClientReturnToMainMenuWithTextReason(const struct FText& ReturnReason)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenuWithTextReason");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenuWithTextReason");

	AEngine_PlayerController_ClientReturnToMainMenuWithTextReason_Params params;
	params.ReturnReason = ReturnReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientReturnToMainMenu
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FString                 ReturnReason                   (Parm, ZeroConstructor)

void AEngine_PlayerController::ClientReturnToMainMenu(const struct FString& ReturnReason)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenu");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenu");

	AEngine_PlayerController_ClientReturnToMainMenu_Params params;
	params.ReturnReason = ReturnReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientRetryClientRestart
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AEngine_Pawn*            NewPawn                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientRetryClientRestart(class AEngine_Pawn* NewPawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRetryClientRestart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRetryClientRestart");

	AEngine_PlayerController_ClientRetryClientRestart_Params params;
	params.NewPawn = NewPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientRestart
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AEngine_Pawn*            NewPawn                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientRestart(class AEngine_Pawn* NewPawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRestart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRestart");

	AEngine_PlayerController_ClientRestart_Params params;
	params.NewPawn = NewPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientReset
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientReset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReset");

	AEngine_PlayerController_ClientReset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientRepObjRef
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientRepObjRef(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRepObjRef");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRepObjRef");

	AEngine_PlayerController_ClientRepObjRef_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientReceiveLocalizedMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UClass*                  Message                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            Switch                         (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerState*     RelatedPlayerState_2           (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerState*     RelatedPlayerState_3           (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 OptionalObject                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientReceiveLocalizedMessage(class UClass* Message, int Switch, class AEngine_PlayerState* RelatedPlayerState_2, class AEngine_PlayerState* RelatedPlayerState_3, class UObject* OptionalObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReceiveLocalizedMessage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReceiveLocalizedMessage");

	AEngine_PlayerController_ClientReceiveLocalizedMessage_Params params;
	params.Message = Message;
	params.Switch = Switch;
	params.RelatedPlayerState_2 = RelatedPlayerState_2;
	params.RelatedPlayerState_3 = RelatedPlayerState_3;
	params.OptionalObject = OptionalObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPrestreamTextures
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AEngine_Actor*           ForcedActor                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          ForceDuration                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableStreaming               (Parm, ZeroConstructor, IsPlainOldData)
// int                            CinematicTextureGroups         (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientPrestreamTextures(class AEngine_Actor* ForcedActor, float ForceDuration, bool bEnableStreaming, int CinematicTextureGroups)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrestreamTextures");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrestreamTextures");

	AEngine_PlayerController_ClientPrestreamTextures_Params params;
	params.ForcedActor = ForcedActor;
	params.ForceDuration = ForceDuration;
	params.bEnableStreaming = bEnableStreaming;
	params.CinematicTextureGroups = CinematicTextureGroups;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPrepareMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FName                   LevelName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFirst                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLast                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientPrepareMapChange(const struct FName& LevelName, bool bFirst, bool bLast)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrepareMapChange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrepareMapChange");

	AEngine_PlayerController_ClientPrepareMapChange_Params params;
	params.LevelName = LevelName;
	params.bFirst = bFirst;
	params.bLast = bLast;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlaySoundAtLocation
// (Net, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientPlaySoundAtLocation(class UEngine_SoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySoundAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySoundAtLocation");

	AEngine_PlayerController_ClientPlaySoundAtLocation_Params params;
	params.Sound = Sound;
	params.Location = Location;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlaySound
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientPlaySound(class UEngine_SoundBase* Sound, float VolumeMultiplier, float PitchMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySound");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySound");

	AEngine_PlayerController_ClientPlaySound_Params params;
	params.Sound = Sound;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlayForceFeedback_Internal
// (Final, Net, Native, Event, Private, NetClient)
// Parameters:
// class UEngine_ForceFeedbackEffect* ForceFeedbackEffect            (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_ForceFeedbackParameters Params                         (Parm)

void AEngine_PlayerController::ClientPlayForceFeedback_Internal(class UEngine_ForceFeedbackEffect* ForceFeedbackEffect, const struct FEngine_ForceFeedbackParameters& Params)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayForceFeedback_Internal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayForceFeedback_Internal");

	AEngine_PlayerController_ClientPlayForceFeedback_Internal_Params params;
	params.ForceFeedbackEffect = ForceFeedbackEffect;
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlayCameraShake
// (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// class UClass*                  Shake                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> PlaySpace                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                UserPlaySpaceRot               (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientPlayCameraShake(class UClass* Shake, float Scale, TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraShake");

	AEngine_PlayerController_ClientPlayCameraShake_Params params;
	params.Shake = Shake;
	params.Scale = Scale;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientPlayCameraAnim
// (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
// Parameters:
// class UEngine_CameraAnim*      AnimToPlay                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Rate                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendInTime                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendOutTime                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLoop                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRandomStartTime               (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> Space                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                CustomPlaySpace                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientPlayCameraAnim(class UEngine_CameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> Space, const struct FRotator& CustomPlaySpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraAnim");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraAnim");

	AEngine_PlayerController_ClientPlayCameraAnim_Params params;
	params.AnimToPlay = AnimToPlay;
	params.Scale = Scale;
	params.Rate = Rate;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLoop = bLoop;
	params.bRandomStartTime = bRandomStartTime;
	params.Space = Space;
	params.CustomPlaySpace = CustomPlaySpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientMutePlayer
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FEngine_UniqueNetIdRepl PlayerId                       (Parm)

void AEngine_PlayerController::ClientMutePlayer(const struct FEngine_UniqueNetIdRepl& PlayerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMutePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMutePlayer");

	AEngine_PlayerController_ClientMutePlayer_Params params;
	params.PlayerId = PlayerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientMessage
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FString                 S                              (Parm, ZeroConstructor)
// struct FName                   Type                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          MsgLifeTime                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientMessage(const struct FString& S, const struct FName& Type, float MsgLifeTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMessage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMessage");

	AEngine_PlayerController_ClientMessage_Params params;
	params.S = S;
	params.Type = Type;
	params.MsgLifeTime = MsgLifeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientIgnoreMoveInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bIgnore                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientIgnoreMoveInput(bool bIgnore)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreMoveInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreMoveInput");

	AEngine_PlayerController_ClientIgnoreMoveInput_Params params;
	params.bIgnore = bIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientIgnoreLookInput
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bIgnore                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientIgnoreLookInput(bool bIgnore)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreLookInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreLookInput");

	AEngine_PlayerController_ClientIgnoreLookInput_Params params;
	params.bIgnore = bIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientGotoState
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// struct FName                   NewState                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientGotoState(const struct FName& NewState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGotoState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGotoState");

	AEngine_PlayerController_ClientGotoState_Params params;
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientGameEnded
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AEngine_Actor*           EndGameFocus                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsWinner                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientGameEnded(class AEngine_Actor* EndGameFocus, bool bIsWinner)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGameEnded");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGameEnded");

	AEngine_PlayerController_ClientGameEnded_Params params;
	params.EndGameFocus = EndGameFocus;
	params.bIsWinner = bIsWinner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientForceGarbageCollection
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientForceGarbageCollection()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientForceGarbageCollection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientForceGarbageCollection");

	AEngine_PlayerController_ClientForceGarbageCollection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientFlushLevelStreaming
// (Final, Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientFlushLevelStreaming()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientFlushLevelStreaming");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientFlushLevelStreaming");

	AEngine_PlayerController_ClientFlushLevelStreaming_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientEndOnlineSession
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientEndOnlineSession()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEndOnlineSession");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEndOnlineSession");

	AEngine_PlayerController_ClientEndOnlineSession_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientEnableNetworkVoice
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientEnableNetworkVoice(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEnableNetworkVoice");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEnableNetworkVoice");

	AEngine_PlayerController_ClientEnableNetworkVoice_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientCommitMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientCommitMapChange()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCommitMapChange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCommitMapChange");

	AEngine_PlayerController_ClientCommitMapChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientClearCameraLensEffects
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void AEngine_PlayerController::ClientClearCameraLensEffects()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientClearCameraLensEffects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientClearCameraLensEffects");

	AEngine_PlayerController_ClientClearCameraLensEffects_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientCapBandwidth
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// int                            Cap                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientCapBandwidth(int Cap)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCapBandwidth");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCapBandwidth");

	AEngine_PlayerController_ClientCapBandwidth_Params params;
	params.Cap = Cap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientCancelPendingMapChange
// (Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_PlayerController::ClientCancelPendingMapChange()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCancelPendingMapChange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCancelPendingMapChange");

	AEngine_PlayerController_ClientCancelPendingMapChange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClientAddTextureStreamingLoc
// (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FVector                 InLoc                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOverrideLocation              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientAddTextureStreamingLoc");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientAddTextureStreamingLoc");

	AEngine_PlayerController_ClientAddTextureStreamingLoc_Params params;
	params.InLoc = InLoc;
	params.Duration = Duration;
	params.bOverrideLocation = bOverrideLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClearAudioListenerOverride
// (Final, Native, Public, BlueprintCallable)

void AEngine_PlayerController::ClearAudioListenerOverride()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerOverride");

	AEngine_PlayerController_ClearAudioListenerOverride_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ClearAudioListenerAttenuationOverride
// (Final, Native, Public, BlueprintCallable)

void AEngine_PlayerController::ClearAudioListenerAttenuationOverride()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerAttenuationOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerAttenuationOverride");

	AEngine_PlayerController_ClearAudioListenerAttenuationOverride_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.CanRestartPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerController::CanRestartPlayer()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.CanRestartPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.CanRestartPlayer");

	AEngine_PlayerController_CanRestartPlayer_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerController.Camera
// (Exec, Native, Public)
// Parameters:
// struct FName                   NewMode                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::Camera(const struct FName& NewMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Camera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Camera");

	AEngine_PlayerController_Camera_Params params;
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AddYawInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::AddYawInput(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddYawInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddYawInput");

	AEngine_PlayerController_AddYawInput_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AddRollInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::AddRollInput(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddRollInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddRollInput");

	AEngine_PlayerController_AddRollInput_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.AddPitchInput
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::AddPitchInput(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddPitchInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddPitchInput");

	AEngine_PlayerController_AddPitchInput_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerController.ActivateTouchInterface
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_TouchInterface*  NewTouchInterface              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerController::ActivateTouchInterface(class UEngine_TouchInterface* NewTouchInterface)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ActivateTouchInterface");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ActivateTouchInterface");

	AEngine_PlayerController_ActivateTouchInterface_Params params;
	params.NewTouchInterface = NewTouchInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Walk
// (Exec, Native, Public, BlueprintCallable)

void UEngine_CheatManager::Walk()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Walk");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Walk");

	UEngine_CheatManager_Walk_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewSelf
// (Exec, Native, Public)

void UEngine_CheatManager::ViewSelf()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewSelf");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewSelf");

	UEngine_CheatManager_ViewSelf_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewPlayer
// (Exec, Native, Public)
// Parameters:
// struct FString                 S                              (Parm, ZeroConstructor)

void UEngine_CheatManager::ViewPlayer(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewPlayer");

	UEngine_CheatManager_ViewPlayer_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewClass
// (Exec, Native, Public)
// Parameters:
// class UClass*                  DesiredClass                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::ViewClass(class UClass* DesiredClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewClass");

	UEngine_CheatManager_ViewClass_Params params;
	params.DesiredClass = DesiredClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ViewActor
// (Exec, Native, Public)
// Parameters:
// struct FName                   ActorName                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::ViewActor(const struct FName& ActorName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewActor");

	UEngine_CheatManager_ViewActor_Params params;
	params.ActorName = ActorName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.UpdateSafeArea
// (Final, Exec, Native, Public)

void UEngine_CheatManager::UpdateSafeArea()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.UpdateSafeArea");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.UpdateSafeArea");

	UEngine_CheatManager_UpdateSafeArea_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ToggleServerStatReplicatorUpdateStatNet
// (Final, Exec, Native, Public)

void UEngine_CheatManager::ToggleServerStatReplicatorUpdateStatNet()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleServerStatReplicatorUpdateStatNet");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleServerStatReplicatorUpdateStatNet");

	UEngine_CheatManager_ToggleServerStatReplicatorUpdateStatNet_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ToggleServerStatReplicatorClientOverwrite
// (Final, Exec, Native, Public)

void UEngine_CheatManager::ToggleServerStatReplicatorClientOverwrite()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleServerStatReplicatorClientOverwrite");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleServerStatReplicatorClientOverwrite");

	UEngine_CheatManager_ToggleServerStatReplicatorClientOverwrite_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ToggleDebugCamera
// (Exec, Native, Public)

void UEngine_CheatManager::ToggleDebugCamera()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleDebugCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleDebugCamera");

	UEngine_CheatManager_ToggleDebugCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ToggleAILogging
// (Exec, Native, Public)

void UEngine_CheatManager::ToggleAILogging()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleAILogging");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleAILogging");

	UEngine_CheatManager_ToggleAILogging_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.TestCollisionDistance
// (Exec, Native, Public)

void UEngine_CheatManager::TestCollisionDistance()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.TestCollisionDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.TestCollisionDistance");

	UEngine_CheatManager_TestCollisionDistance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Teleport
// (Exec, Native, Public, BlueprintCallable)

void UEngine_CheatManager::Teleport()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Teleport");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Teleport");

	UEngine_CheatManager_Teleport_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Summon
// (Exec, Native, Public)
// Parameters:
// struct FString                 ClassName                      (Parm, ZeroConstructor)

void UEngine_CheatManager::Summon(const struct FString& ClassName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Summon");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Summon");

	UEngine_CheatManager_Summon_Params params;
	params.ClassName = ClassName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.StreamLevelOut
// (Exec, Native, Public)
// Parameters:
// struct FName                   PackageName                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::StreamLevelOut(const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelOut");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelOut");

	UEngine_CheatManager_StreamLevelOut_Params params;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.StreamLevelIn
// (Exec, Native, Public)
// Parameters:
// struct FName                   PackageName                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::StreamLevelIn(const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelIn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelIn");

	UEngine_CheatManager_StreamLevelIn_Params params;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SpawnServerStatReplicator
// (Final, Exec, Native, Public)

void UEngine_CheatManager::SpawnServerStatReplicator()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SpawnServerStatReplicator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SpawnServerStatReplicator");

	UEngine_CheatManager_SpawnServerStatReplicator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Slomo
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewTimeDilation                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::Slomo(float NewTimeDilation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Slomo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Slomo");

	UEngine_CheatManager_Slomo_Params params;
	params.NewTimeDilation = NewTimeDilation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetWorldOrigin
// (Final, Exec, Native, Public)

void UEngine_CheatManager::SetWorldOrigin()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetWorldOrigin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetWorldOrigin");

	UEngine_CheatManager_SetWorldOrigin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.SetMouseSensitivityToDefault
// (Exec, Native, Public)

void UEngine_CheatManager::SetMouseSensitivityToDefault()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetMouseSensitivityToDefault");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetMouseSensitivityToDefault");

	UEngine_CheatManager_SetMouseSensitivityToDefault_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ServerToggleAILogging
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UEngine_CheatManager::ServerToggleAILogging()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ServerToggleAILogging");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ServerToggleAILogging");

	UEngine_CheatManager_ServerToggleAILogging_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ReceiveInitCheatManager
// (Event, Public, BlueprintEvent)

void UEngine_CheatManager::ReceiveInitCheatManager()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ReceiveInitCheatManager");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ReceiveInitCheatManager");

	UEngine_CheatManager_ReceiveInitCheatManager_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ReceiveEndPlay
// (Event, Public, BlueprintEvent)

void UEngine_CheatManager::ReceiveEndPlay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ReceiveEndPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ReceiveEndPlay");

	UEngine_CheatManager_ReceiveEndPlay_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.PlayersOnly
// (Exec, Native, Public, BlueprintCallable)

void UEngine_CheatManager::PlayersOnly()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.PlayersOnly");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.PlayersOnly");

	UEngine_CheatManager_PlayersOnly_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.OnlyLoadLevel
// (Exec, Native, Public)
// Parameters:
// struct FName                   PackageName                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::OnlyLoadLevel(const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.OnlyLoadLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.OnlyLoadLevel");

	UEngine_CheatManager_OnlyLoadLevel_Params params;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.LogLoc
// (Exec, Native, Public)

void UEngine_CheatManager::LogLoc()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.LogLoc");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.LogLoc");

	UEngine_CheatManager_LogLoc_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.InvertMouse
// (Exec, Native, Public)

void UEngine_CheatManager::InvertMouse()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.InvertMouse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.InvertMouse");

	UEngine_CheatManager_InvertMouse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.God
// (Exec, Native, Public, BlueprintCallable)

void UEngine_CheatManager::God()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.God");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.God");

	UEngine_CheatManager_God_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Ghost
// (Exec, Native, Public, BlueprintCallable)

void UEngine_CheatManager::Ghost()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Ghost");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Ghost");

	UEngine_CheatManager_Ghost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.FreezeFrame
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                          Delay                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::FreezeFrame(float Delay)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FreezeFrame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FreezeFrame");

	UEngine_CheatManager_FreezeFrame_Params params;
	params.Delay = Delay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.Fly
// (Exec, Native, Public, BlueprintCallable)

void UEngine_CheatManager::Fly()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Fly");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Fly");

	UEngine_CheatManager_Fly_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.FlushLog
// (Exec, Native, Public)

void UEngine_CheatManager::FlushLog()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FlushLog");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FlushLog");

	UEngine_CheatManager_FlushLog_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.EnableDebugCamera
// (Native, Protected, BlueprintCallable)

void UEngine_CheatManager::EnableDebugCamera()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.EnableDebugCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.EnableDebugCamera");

	UEngine_CheatManager_EnableDebugCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DumpVoiceMutingState
// (Exec, Native, Public)

void UEngine_CheatManager::DumpVoiceMutingState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpVoiceMutingState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpVoiceMutingState");

	UEngine_CheatManager_DumpVoiceMutingState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DumpPartyState
// (Exec, Native, Public)

void UEngine_CheatManager::DumpPartyState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpPartyState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpPartyState");

	UEngine_CheatManager_DumpPartyState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DumpOnlineSessionState
// (Exec, Native, Public)

void UEngine_CheatManager::DumpOnlineSessionState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpOnlineSessionState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpOnlineSessionState");

	UEngine_CheatManager_DumpOnlineSessionState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DumpChatState
// (Exec, Native, Public)

void UEngine_CheatManager::DumpChatState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpChatState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpChatState");

	UEngine_CheatManager_DumpChatState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DisableDebugCamera
// (Native, Protected, BlueprintCallable)

void UEngine_CheatManager::DisableDebugCamera()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DisableDebugCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DisableDebugCamera");

	UEngine_CheatManager_DisableDebugCamera_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DestroyTarget
// (Exec, Native, Public, BlueprintCallable)

void UEngine_CheatManager::DestroyTarget()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyTarget");

	UEngine_CheatManager_DestroyTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DestroyServerStatReplicator
// (Final, Exec, Native, Public)

void UEngine_CheatManager::DestroyServerStatReplicator()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyServerStatReplicator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyServerStatReplicator");

	UEngine_CheatManager_DestroyServerStatReplicator_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DestroyPawns
// (Exec, Native, Public)
// Parameters:
// class UClass*                  aClass                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::DestroyPawns(class UClass* aClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyPawns");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyPawns");

	UEngine_CheatManager_DestroyPawns_Params params;
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DestroyAllPawnsExceptTarget
// (Exec, Native, Public)

void UEngine_CheatManager::DestroyAllPawnsExceptTarget()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAllPawnsExceptTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAllPawnsExceptTarget");

	UEngine_CheatManager_DestroyAllPawnsExceptTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DestroyAll
// (Exec, Native, Public)
// Parameters:
// class UClass*                  aClass                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::DestroyAll(class UClass* aClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAll");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAll");

	UEngine_CheatManager_DestroyAll_Params params;
	params.aClass = aClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugCapsuleSweepSize
// (Exec, Native, Public)
// Parameters:
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::DebugCapsuleSweepSize(float HalfHeight, float Radius)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepSize");

	UEngine_CheatManager_DebugCapsuleSweepSize_Params params;
	params.HalfHeight = HalfHeight;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugCapsuleSweepPawn
// (Exec, Native, Public)

void UEngine_CheatManager::DebugCapsuleSweepPawn()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepPawn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepPawn");

	UEngine_CheatManager_DebugCapsuleSweepPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugCapsuleSweepComplex
// (Exec, Native, Public)
// Parameters:
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::DebugCapsuleSweepComplex(bool bTraceComplex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepComplex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepComplex");

	UEngine_CheatManager_DebugCapsuleSweepComplex_Params params;
	params.bTraceComplex = bTraceComplex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugCapsuleSweepClear
// (Exec, Native, Public)

void UEngine_CheatManager::DebugCapsuleSweepClear()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepClear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepClear");

	UEngine_CheatManager_DebugCapsuleSweepClear_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugCapsuleSweepChannel
// (Exec, Native, Public)
// Parameters:
// TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::DebugCapsuleSweepChannel(TEnumAsByte<FEngine_Engine_ECollisionChannel> Channel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepChannel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepChannel");

	UEngine_CheatManager_DebugCapsuleSweepChannel_Params params;
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugCapsuleSweepCapture
// (Exec, Native, Public)

void UEngine_CheatManager::DebugCapsuleSweepCapture()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepCapture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepCapture");

	UEngine_CheatManager_DebugCapsuleSweepCapture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DebugCapsuleSweep
// (Exec, Native, Public)

void UEngine_CheatManager::DebugCapsuleSweep()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweep");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweep");

	UEngine_CheatManager_DebugCapsuleSweep_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.DamageTarget
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                          DamageAmount                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::DamageTarget(float DamageAmount)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DamageTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DamageTarget");

	UEngine_CheatManager_DamageTarget_Params params;
	params.DamageAmount = DamageAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.CheatScript
// (Final, Exec, Native, Public)
// Parameters:
// struct FString                 ScriptName                     (Parm, ZeroConstructor)

void UEngine_CheatManager::CheatScript(const struct FString& ScriptName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.CheatScript");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.CheatScript");

	UEngine_CheatManager_CheatScript_Params params;
	params.ScriptName = ScriptName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.ChangeSize
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                          F                              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::ChangeSize(float F)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ChangeSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ChangeSize");

	UEngine_CheatManager_ChangeSize_Params params;
	params.F = F;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.BugItStringCreator
// (Exec, Native, Public, HasOutParms, HasDefaults)
// Parameters:
// struct FVector                 ViewLocation                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ViewRotation                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 GoString                       (Parm, OutParm, ZeroConstructor)
// struct FString                 LocString                      (Parm, OutParm, ZeroConstructor)

void UEngine_CheatManager::BugItStringCreator(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, struct FString* GoString, struct FString* LocString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItStringCreator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItStringCreator");

	UEngine_CheatManager_BugItStringCreator_Params params;
	params.ViewLocation = ViewLocation;
	params.ViewRotation = ViewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (GoString != nullptr)
		*GoString = params.GoString;
	if (LocString != nullptr)
		*LocString = params.LocString;
}


// Function Engine.CheatManager.BugItGo
// (Exec, Native, Public)
// Parameters:
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Yaw                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Roll                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CheatManager::BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItGo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItGo");

	UEngine_CheatManager_BugItGo_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;
	params.Pitch = Pitch;
	params.Yaw = Yaw;
	params.Roll = Roll;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CheatManager.BugIt
// (Exec, Native, Public)
// Parameters:
// struct FString                 ScreenShotDescription          (Parm, ZeroConstructor)

void UEngine_CheatManager::BugIt(const struct FString& ScreenShotDescription)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugIt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugIt");

	UEngine_CheatManager_BugIt_Params params;
	params.ScreenShotDescription = ScreenShotDescription;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset
// (Native, Public)

void AEngine_SkeletalMeshActor::OnRep_ReplicatedPhysAsset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset");

	AEngine_SkeletalMeshActor_OnRep_ReplicatedPhysAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh
// (Native, Public)

void AEngine_SkeletalMeshActor::OnRep_ReplicatedMesh()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh");

	AEngine_SkeletalMeshActor_OnRep_ReplicatedMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1
// (Native, Public)

void AEngine_SkeletalMeshActor::OnRep_ReplicatedMaterial1()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1");

	AEngine_SkeletalMeshActor_OnRep_ReplicatedMaterial1_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0
// (Native, Public)

void AEngine_SkeletalMeshActor::OnRep_ReplicatedMaterial0()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0");

	AEngine_SkeletalMeshActor_OnRep_ReplicatedMaterial0_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInstance.ReceiveShutdown
// (Event, Public, BlueprintEvent)

void UEngine_GameInstance::ReceiveShutdown()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveShutdown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveShutdown");

	UEngine_GameInstance_ReceiveShutdown_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInstance.ReceiveInit
// (Event, Public, BlueprintEvent)

void UEngine_GameInstance::ReceiveInit()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveInit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.ReceiveInit");

	UEngine_GameInstance_ReceiveInit_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInstance.HandleTravelError
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FEngine_Engine_ETravelFailure> FailureType                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameInstance::HandleTravelError(TEnumAsByte<FEngine_Engine_ETravelFailure> FailureType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.HandleTravelError");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.HandleTravelError");

	UEngine_GameInstance_HandleTravelError_Params params;
	params.FailureType = FailureType;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInstance.HandleNetworkError
// (Event, Public, BlueprintEvent)
// Parameters:
// TEnumAsByte<FEngine_Engine_ENetworkFailure> FailureType                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsServer                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameInstance::HandleNetworkError(TEnumAsByte<FEngine_Engine_ENetworkFailure> FailureType, bool bIsServer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.HandleNetworkError");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.HandleNetworkError");

	UEngine_GameInstance_HandleNetworkError_Params params;
	params.FailureType = FailureType;
	params.bIsServer = bIsServer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInstance.DebugRemovePlayer
// (Exec, Native, Public)
// Parameters:
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameInstance::DebugRemovePlayer(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugRemovePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugRemovePlayer");

	UEngine_GameInstance_DebugRemovePlayer_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameInstance.DebugCreatePlayer
// (Exec, Native, Public)
// Parameters:
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameInstance::DebugCreatePlayer(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugCreatePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugCreatePlayer");

	UEngine_GameInstance_DebugCreatePlayer_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.StartPlay
// (Native, Public, BlueprintCallable)

void AEngine_GameModeBase::StartPlay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.StartPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.StartPlay");

	AEngine_GameModeBase_StartPlay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.SpawnDefaultPawnFor
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           StartSpot                      (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* AEngine_GameModeBase::SpawnDefaultPawnFor(class AEngine_Controller* NewPlayer, class AEngine_Actor* StartSpot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.SpawnDefaultPawnFor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.SpawnDefaultPawnFor");

	AEngine_GameModeBase_SpawnDefaultPawnFor_Params params;
	params.NewPlayer = NewPlayer;
	params.StartSpot = StartSpot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.SpawnDefaultPawnAtTransform
// (Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              SpawnTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* AEngine_GameModeBase::SpawnDefaultPawnAtTransform(class AEngine_Controller* NewPlayer, const struct FTransform& SpawnTransform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.SpawnDefaultPawnAtTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.SpawnDefaultPawnAtTransform");

	AEngine_GameModeBase_SpawnDefaultPawnAtTransform_Params params;
	params.NewPlayer = NewPlayer;
	params.SpawnTransform = SpawnTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.ShouldReset
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Actor*           ActorToReset                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameModeBase::ShouldReset(class AEngine_Actor* ActorToReset)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ShouldReset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ShouldReset");

	AEngine_GameModeBase_ShouldReset_Params params;
	params.ActorToReset = ActorToReset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.ReturnToMainMenuHost
// (Native, Public, BlueprintCallable)

void AEngine_GameModeBase::ReturnToMainMenuHost()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ReturnToMainMenuHost");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ReturnToMainMenuHost");

	AEngine_GameModeBase_ReturnToMainMenuHost_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.RestartPlayerAtTransform
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class AEngine_Controller*      NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              SpawnTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void AEngine_GameModeBase::RestartPlayerAtTransform(class AEngine_Controller* NewPlayer, const struct FTransform& SpawnTransform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayerAtTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayerAtTransform");

	AEngine_GameModeBase_RestartPlayerAtTransform_Params params;
	params.NewPlayer = NewPlayer;
	params.SpawnTransform = SpawnTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.RestartPlayerAtPlayerStart
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Controller*      NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           StartSpot                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::RestartPlayerAtPlayerStart(class AEngine_Controller* NewPlayer, class AEngine_Actor* StartSpot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayerAtPlayerStart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayerAtPlayerStart");

	AEngine_GameModeBase_RestartPlayerAtPlayerStart_Params params;
	params.NewPlayer = NewPlayer;
	params.StartSpot = StartSpot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.RestartPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Controller*      NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::RestartPlayer(class AEngine_Controller* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.RestartPlayer");

	AEngine_GameModeBase_RestartPlayer_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.ResetLevel
// (Native, Public, BlueprintCallable)

void AEngine_GameModeBase::ResetLevel()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ResetLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ResetLevel");

	AEngine_GameModeBase_ResetLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.PlayerCanRestart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* Player                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameModeBase::PlayerCanRestart(class AEngine_PlayerController* Player)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.PlayerCanRestart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.PlayerCanRestart");

	AEngine_GameModeBase_PlayerCanRestart_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.MustSpectate
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AEngine_PlayerController* NewPlayerController            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameModeBase::MustSpectate(class AEngine_PlayerController* NewPlayerController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.MustSpectate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.MustSpectate");

	AEngine_GameModeBase_MustSpectate_Params params;
	params.NewPlayerController = NewPlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.K2_PostLogin
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::K2_PostLogin(class AEngine_PlayerController* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_PostLogin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_PostLogin");

	AEngine_GameModeBase_K2_PostLogin_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.K2_OnSwapPlayerControllers
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* OldPC                          (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerController* NewPC                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::K2_OnSwapPlayerControllers(class AEngine_PlayerController* OldPC, class AEngine_PlayerController* NewPC)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnSwapPlayerControllers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnSwapPlayerControllers");

	AEngine_GameModeBase_K2_OnSwapPlayerControllers_Params params;
	params.OldPC = OldPC;
	params.NewPC = NewPC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.K2_OnRestartPlayer
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::K2_OnRestartPlayer(class AEngine_Controller* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnRestartPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnRestartPlayer");

	AEngine_GameModeBase_K2_OnRestartPlayer_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.K2_OnLogout
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      ExitingController              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::K2_OnLogout(class AEngine_Controller* ExitingController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnLogout");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnLogout");

	AEngine_GameModeBase_K2_OnLogout_Params params;
	params.ExitingController = ExitingController;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.K2_OnChangeName
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      Other                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 NewName                        (Parm, ZeroConstructor)
// bool                           bNameChange                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::K2_OnChangeName(class AEngine_Controller* Other, const struct FString& NewName, bool bNameChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnChangeName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_OnChangeName");

	AEngine_GameModeBase_K2_OnChangeName_Params params;
	params.Other = Other;
	params.NewName = NewName;
	params.bNameChange = bNameChange;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.K2_FindPlayerStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_Controller*      Player                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 IncomingName                   (Parm, ZeroConstructor)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_GameModeBase::K2_FindPlayerStart(class AEngine_Controller* Player, const struct FString& IncomingName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_FindPlayerStart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.K2_FindPlayerStart");

	AEngine_GameModeBase_K2_FindPlayerStart_Params params;
	params.Player = Player;
	params.IncomingName = IncomingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.InitStartSpot
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Actor*           StartSpot                      (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Controller*      NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::InitStartSpot(class AEngine_Actor* StartSpot, class AEngine_Controller* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.InitStartSpot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.InitStartSpot");

	AEngine_GameModeBase_InitStartSpot_Params params;
	params.StartSpot = StartSpot;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.InitializeHUDForPlayer
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::InitializeHUDForPlayer(class AEngine_PlayerController* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.InitializeHUDForPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.InitializeHUDForPlayer");

	AEngine_GameModeBase_InitializeHUDForPlayer_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.HasMatchStarted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameModeBase::HasMatchStarted()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.HasMatchStarted");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.HasMatchStarted");

	AEngine_GameModeBase_HasMatchStarted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.HandleStartingNewPlayer
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* NewPlayer                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::HandleStartingNewPlayer(class AEngine_PlayerController* NewPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.HandleStartingNewPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.HandleStartingNewPlayer");

	AEngine_GameModeBase_HandleStartingNewPlayer_Params params;
	params.NewPlayer = NewPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.GetNumSpectators
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AEngine_GameModeBase::GetNumSpectators()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetNumSpectators");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetNumSpectators");

	AEngine_GameModeBase_GetNumSpectators_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.GetNumPlayers
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int AEngine_GameModeBase::GetNumPlayers()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetNumPlayers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetNumPlayers");

	AEngine_GameModeBase_GetNumPlayers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.GetDefaultPawnClassForController
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      InController                   (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* AEngine_GameModeBase::GetDefaultPawnClassForController(class AEngine_Controller* InController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetDefaultPawnClassForController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.GetDefaultPawnClassForController");

	AEngine_GameModeBase_GetDefaultPawnClassForController_Params params;
	params.InController = InController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.FindPlayerStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      Player                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 IncomingName                   (Parm, ZeroConstructor)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_GameModeBase::FindPlayerStart(class AEngine_Controller* Player, const struct FString& IncomingName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.FindPlayerStart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.FindPlayerStart");

	AEngine_GameModeBase_FindPlayerStart_Params params;
	params.Player = Player;
	params.IncomingName = IncomingName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.ChoosePlayerStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_Controller*      Player                         (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_GameModeBase::ChoosePlayerStart(class AEngine_Controller* Player)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ChoosePlayerStart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ChoosePlayerStart");

	AEngine_GameModeBase_ChoosePlayerStart_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameModeBase.ChangeName
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Controller*      Controller                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 NewName                        (Parm, ZeroConstructor)
// bool                           bNameChange                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameModeBase::ChangeName(class AEngine_Controller* Controller, const struct FString& NewName, bool bNameChange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ChangeName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.ChangeName");

	AEngine_GameModeBase_ChangeName_Params params;
	params.Controller = Controller;
	params.NewName = NewName;
	params.bNameChange = bNameChange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameModeBase.CanSpectate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* Viewer                         (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerState*     ViewTarget                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameModeBase::CanSpectate(class AEngine_PlayerController* Viewer, class AEngine_PlayerState* ViewTarget)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.CanSpectate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameModeBase.CanSpectate");

	AEngine_GameModeBase_CanSpectate_Params params;
	params.Viewer = Viewer;
	params.ViewTarget = ViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.UnloadStreamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   LevelName                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)
// bool                           bShouldBlockOnUnload           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_UnloadStreamLevel(class UObject* WorldContextObject, const struct FName& LevelName, const struct FEngine_LatentActionInfo& LatentInfo, bool bShouldBlockOnUnload)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.UnloadStreamLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.UnloadStreamLevel");

	UEngine_GameplayStatics_UnloadStreamLevel_Params params;
	params.WorldContextObject = WorldContextObject;
	params.LevelName = LevelName;
	params.LatentInfo = LatentInfo;
	params.bShouldBlockOnUnload = bShouldBlockOnUnload;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutLaunchVelocity              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 StartPos                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 EndPos                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          OverrideGravityZ               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ArcParam                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_SuggestProjectileVelocity_CustomArc(class UObject* WorldContextObject, const struct FVector& StartPos, const struct FVector& EndPos, float OverrideGravityZ, float ArcParam, struct FVector* OutLaunchVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc");

	UEngine_GameplayStatics_SuggestProjectileVelocity_CustomArc_Params params;
	params.WorldContextObject = WorldContextObject;
	params.StartPos = StartPos;
	params.EndPos = EndPos;
	params.OverrideGravityZ = OverrideGravityZ;
	params.ArcParam = ArcParam;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutLaunchVelocity != nullptr)
		*OutLaunchVelocity = params.OutLaunchVelocity;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnSoundAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SceneComponent*  AttachToComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   AttachPointName                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bStopWhenAttachedToDestroyed   (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundConcurrency* ConcurrencySettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AudioComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_AudioComponent* UEngine_GameplayStatics::STATIC_SpawnSoundAttached(class UEngine_SoundBase* Sound, class UEngine_SceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundAttenuation* AttenuationSettings, class UEngine_SoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAttached");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAttached");

	UEngine_GameplayStatics_SpawnSoundAttached_Params params;
	params.Sound = Sound;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;
	params.ConcurrencySettings = ConcurrencySettings;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnSoundAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundConcurrency* ConcurrencySettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AudioComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_AudioComponent* UEngine_GameplayStatics::STATIC_SpawnSoundAtLocation(class UObject* WorldContextObject, class UEngine_SoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundAttenuation* AttenuationSettings, class UEngine_SoundConcurrency* ConcurrencySettings, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSoundAtLocation");

	UEngine_GameplayStatics_SpawnSoundAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;
	params.ConcurrencySettings = ConcurrencySettings;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnSound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundConcurrency* ConcurrencySettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPersistAcrossLevelTransition  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AudioComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_AudioComponent* UEngine_GameplayStatics::STATIC_SpawnSound2D(class UObject* WorldContextObject, class UEngine_SoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSound2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnSound2D");

	UEngine_GameplayStatics_SpawnSound2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.ConcurrencySettings = ConcurrencySettings;
	params.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ObjectClass                    (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 Outer                          (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UEngine_GameplayStatics::STATIC_SpawnObject(class UClass* ObjectClass, class UObject* Outer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnObject");

	UEngine_GameplayStatics_SpawnObject_Params params;
	params.ObjectClass = ObjectClass;
	params.Outer = Outer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnForceFeedbackAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_ForceFeedbackEffect* ForceFeedbackEffect            (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SceneComponent*  AttachToComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   AttachPointName                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bStopWhenAttachedToDestroyed   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLooping                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          IntensityMultiplier            (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ForceFeedbackAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ForceFeedbackComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_ForceFeedbackComponent* UEngine_GameplayStatics::STATIC_SpawnForceFeedbackAttached(class UEngine_ForceFeedbackEffect* ForceFeedbackEffect, class UEngine_SceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UEngine_ForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnForceFeedbackAttached");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnForceFeedbackAttached");

	UEngine_GameplayStatics_SpawnForceFeedbackAttached_Params params;
	params.ForceFeedbackEffect = ForceFeedbackEffect;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	params.bLooping = bLooping;
	params.IntensityMultiplier = IntensityMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnForceFeedbackAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ForceFeedbackEffect* ForceFeedbackEffect            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLooping                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          IntensityMultiplier            (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ForceFeedbackAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ForceFeedbackComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_ForceFeedbackComponent* UEngine_GameplayStatics::STATIC_SpawnForceFeedbackAtLocation(class UObject* WorldContextObject, class UEngine_ForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, const struct FRotator& Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UEngine_ForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnForceFeedbackAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnForceFeedbackAtLocation");

	UEngine_GameplayStatics_SpawnForceFeedbackAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ForceFeedbackEffect = ForceFeedbackEffect;
	params.Location = Location;
	params.Rotation = Rotation;
	params.bLooping = bLooping;
	params.IntensityMultiplier = IntensityMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnEmitterAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_ParticleSystem*  EmitterTemplate                (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SceneComponent*  AttachToComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   AttachPointName                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EPSCPoolMethod  PoolingMethod                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoActivate                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ParticleSystemComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_ParticleSystemComponent* UEngine_GameplayStatics::STATIC_SpawnEmitterAttached(class UEngine_ParticleSystem* EmitterTemplate, class UEngine_SceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType, bool bAutoDestroy, FEngine_Engine_EPSCPoolMethod PoolingMethod, bool bAutoActivate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAttached");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAttached");

	UEngine_GameplayStatics_SpawnEmitterAttached_Params params;
	params.EmitterTemplate = EmitterTemplate;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.Scale = Scale;
	params.LocationType = LocationType;
	params.bAutoDestroy = bAutoDestroy;
	params.PoolingMethod = PoolingMethod;
	params.bAutoActivate = bAutoActivate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnEmitterAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ParticleSystem*  EmitterTemplate                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EPSCPoolMethod  PoolingMethod                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoActivateSystem            (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ParticleSystemComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_ParticleSystemComponent* UEngine_GameplayStatics::STATIC_SpawnEmitterAtLocation(class UObject* WorldContextObject, class UEngine_ParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale, bool bAutoDestroy, FEngine_Engine_EPSCPoolMethod PoolingMethod, bool bAutoActivateSystem)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAtLocation");

	UEngine_GameplayStatics_SpawnEmitterAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.EmitterTemplate = EmitterTemplate;
	params.Location = Location;
	params.Rotation = Rotation;
	params.Scale = Scale;
	params.bAutoDestroy = bAutoDestroy;
	params.PoolingMethod = PoolingMethod;
	params.bAutoActivateSystem = bAutoActivateSystem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDialogueAttached
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_DialogueWave*    Dialogue                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DialogueContext Context                        (ConstParm, Parm, OutParm, ReferenceParm)
// class UEngine_SceneComponent*  AttachToComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   AttachPointName                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bStopWhenAttachedToDestroyed   (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AudioComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_AudioComponent* UEngine_GameplayStatics::STATIC_SpawnDialogueAttached(class UEngine_DialogueWave* Dialogue, const struct FEngine_DialogueContext& Context, class UEngine_SceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAttached");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAttached");

	UEngine_GameplayStatics_SpawnDialogueAttached_Params params;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDialogueAtLocation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DialogueWave*    Dialogue                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DialogueContext Context                        (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AudioComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_AudioComponent* UEngine_GameplayStatics::STATIC_SpawnDialogueAtLocation(class UObject* WorldContextObject, class UEngine_DialogueWave* Dialogue, const struct FEngine_DialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundAttenuation* AttenuationSettings, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogueAtLocation");

	UEngine_GameplayStatics_SpawnDialogueAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDialogue2D
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DialogueWave*    Dialogue                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DialogueContext Context                        (ConstParm, Parm, OutParm, ReferenceParm)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AudioComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_AudioComponent* UEngine_GameplayStatics::STATIC_SpawnDialogue2D(class UObject* WorldContextObject, class UEngine_DialogueWave* Dialogue, const struct FEngine_DialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogue2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDialogue2D");

	UEngine_GameplayStatics_SpawnDialogue2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDecalAttached
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* DecalMaterial                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 DecalSize                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SceneComponent*  AttachToComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   AttachPointName                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          LifeSpan                       (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DecalComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_DecalComponent* UEngine_GameplayStatics::STATIC_SpawnDecalAttached(class UEngine_MaterialInterface* DecalMaterial, const struct FVector& DecalSize, class UEngine_SceneComponent* AttachToComponent, const struct FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, TEnumAsByte<FEngine_Engine_EAttachLocation> LocationType, float LifeSpan)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAttached");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAttached");

	UEngine_GameplayStatics_SpawnDecalAttached_Params params;
	params.DecalMaterial = DecalMaterial;
	params.DecalSize = DecalSize;
	params.AttachToComponent = AttachToComponent;
	params.AttachPointName = AttachPointName;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LocationType = LocationType;
	params.LifeSpan = LifeSpan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SpawnDecalAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* DecalMaterial                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 DecalSize                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          LifeSpan                       (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DecalComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_DecalComponent* UEngine_GameplayStatics::STATIC_SpawnDecalAtLocation(class UObject* WorldContextObject, class UEngine_MaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAtLocation");

	UEngine_GameplayStatics_SpawnDecalAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.DecalMaterial = DecalMaterial;
	params.DecalSize = DecalSize;
	params.Location = Location;
	params.Rotation = Rotation;
	params.LifeSpan = LifeSpan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SetWorldOriginLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FIntVector              NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetWorldOriginLocation(class UObject* WorldContextObject, const struct FIntVector& NewLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetWorldOriginLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetWorldOriginLocation");

	UEngine_GameplayStatics_SetWorldOriginLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.NewLocation = NewLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetViewportMouseCaptureMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EMouseCaptureMode MouseCaptureMode               (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetViewportMouseCaptureMode(class UObject* WorldContextObject, FEngine_Engine_EMouseCaptureMode MouseCaptureMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetViewportMouseCaptureMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetViewportMouseCaptureMode");

	UEngine_GameplayStatics_SetViewportMouseCaptureMode_Params params;
	params.WorldContextObject = WorldContextObject;
	params.MouseCaptureMode = MouseCaptureMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetSubtitlesEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetSubtitlesEnabled(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSubtitlesEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSubtitlesEnabled");

	UEngine_GameplayStatics_SetSubtitlesEnabled_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetSoundMixClassOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundMix*        InSoundMixModifier             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundClass*      InSoundClass                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          Volume                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeInTime                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bApplyToChildren               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetSoundMixClassOverride(class UObject* WorldContextObject, class UEngine_SoundMix* InSoundMixModifier, class UEngine_SoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSoundMixClassOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSoundMixClassOverride");

	UEngine_GameplayStatics_SetSoundMixClassOverride_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InSoundMixModifier = InSoundMixModifier;
	params.InSoundClass = InSoundClass;
	params.Volume = Volume;
	params.Pitch = Pitch;
	params.FadeInTime = FadeInTime;
	params.bApplyToChildren = bApplyToChildren;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetPlayerControllerID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerController* Player                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetPlayerControllerID(class AEngine_PlayerController* Player, int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetPlayerControllerID");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetPlayerControllerID");

	UEngine_GameplayStatics_SetPlayerControllerID_Params params;
	params.Player = Player;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetMaxAudioChannelsScaled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxChannelCountScale           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetMaxAudioChannelsScaled(class UObject* WorldContextObject, float MaxChannelCountScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetMaxAudioChannelsScaled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetMaxAudioChannelsScaled");

	UEngine_GameplayStatics_SetMaxAudioChannelsScaled_Params params;
	params.WorldContextObject = WorldContextObject;
	params.MaxChannelCountScale = MaxChannelCountScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetGlobalTimeDilation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          timeDilation                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetGlobalTimeDilation(class UObject* WorldContextObject, float timeDilation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalTimeDilation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalTimeDilation");

	UEngine_GameplayStatics_SetGlobalTimeDilation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.timeDilation = timeDilation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetGlobalPitchModulation
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchModulation                (Parm, ZeroConstructor, IsPlainOldData)
// float                          TimeSec                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetGlobalPitchModulation(class UObject* WorldContextObject, float PitchModulation, float TimeSec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalPitchModulation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalPitchModulation");

	UEngine_GameplayStatics_SetGlobalPitchModulation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PitchModulation = PitchModulation;
	params.TimeSec = TimeSec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetGlobalListenerFocusParameters
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          FocusAzimuthScale              (Parm, ZeroConstructor, IsPlainOldData)
// float                          NonFocusAzimuthScale           (Parm, ZeroConstructor, IsPlainOldData)
// float                          FocusDistanceScale             (Parm, ZeroConstructor, IsPlainOldData)
// float                          NonFocusDistanceScale          (Parm, ZeroConstructor, IsPlainOldData)
// float                          FocusVolumeScale               (Parm, ZeroConstructor, IsPlainOldData)
// float                          NonFocusVolumeScale            (Parm, ZeroConstructor, IsPlainOldData)
// float                          FocusPriorityScale             (Parm, ZeroConstructor, IsPlainOldData)
// float                          NonFocusPriorityScale          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetGlobalListenerFocusParameters(class UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalListenerFocusParameters");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalListenerFocusParameters");

	UEngine_GameplayStatics_SetGlobalListenerFocusParameters_Params params;
	params.WorldContextObject = WorldContextObject;
	params.FocusAzimuthScale = FocusAzimuthScale;
	params.NonFocusAzimuthScale = NonFocusAzimuthScale;
	params.FocusDistanceScale = FocusDistanceScale;
	params.NonFocusDistanceScale = NonFocusDistanceScale;
	params.FocusVolumeScale = FocusVolumeScale;
	params.NonFocusVolumeScale = NonFocusVolumeScale;
	params.FocusPriorityScale = FocusPriorityScale;
	params.NonFocusPriorityScale = NonFocusPriorityScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetGamePaused
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPaused                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_SetGamePaused(class UObject* WorldContextObject, bool bPaused)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGamePaused");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGamePaused");

	UEngine_GameplayStatics_SetGamePaused_Params params;
	params.WorldContextObject = WorldContextObject;
	params.bPaused = bPaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.SetForceDisableSplitscreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDisable                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetForceDisableSplitscreen(class UObject* WorldContextObject, bool bDisable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetForceDisableSplitscreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetForceDisableSplitscreen");

	UEngine_GameplayStatics_SetForceDisableSplitscreen_Params params;
	params.WorldContextObject = WorldContextObject;
	params.bDisable = bDisable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetEnableWorldRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetEnableWorldRendering(class UObject* WorldContextObject, bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetEnableWorldRendering");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetEnableWorldRendering");

	UEngine_GameplayStatics_SetEnableWorldRendering_Params params;
	params.WorldContextObject = WorldContextObject;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SetBaseSoundMix
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundMix*        InSoundMix                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_SetBaseSoundMix(class UObject* WorldContextObject, class UEngine_SoundMix* InSoundMix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetBaseSoundMix");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetBaseSoundMix");

	UEngine_GameplayStatics_SetBaseSoundMix_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InSoundMix = InSoundMix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.SaveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_SaveGame*        SaveGameObject                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 SlotName                       (Parm, ZeroConstructor)
// int                            UserIndex                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_SaveGameToSlot(class UEngine_SaveGame* SaveGameObject, const struct FString& SlotName, int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SaveGameToSlot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SaveGameToSlot");

	UEngine_GameplayStatics_SaveGameToSlot_Params params;
	params.SaveGameObject = SaveGameObject;
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.RemovePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerController* Player                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDestroyPawn                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_RemovePlayer(class AEngine_PlayerController* Player, bool bDestroyPawn)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RemovePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RemovePlayer");

	UEngine_GameplayStatics_RemovePlayer_Params params;
	params.Player = Player;
	params.bDestroyPawn = bDestroyPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_GameplayStatics::STATIC_RebaseZeroOriginOntoLocal(class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal");

	UEngine_GameplayStatics_RebaseZeroOriginOntoLocal_Params params;
	params.WorldContextObject = WorldContextObject;
	params.WorldLocation = WorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.RebaseLocalOriginOntoZero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_GameplayStatics::STATIC_RebaseLocalOriginOntoZero(class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RebaseLocalOriginOntoZero");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.RebaseLocalOriginOntoZero");

	UEngine_GameplayStatics_RebaseLocalOriginOntoZero_Params params;
	params.WorldContextObject = WorldContextObject;
	params.WorldLocation = WorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.PushSoundMixModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundMix*        InSoundMixModifier             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PushSoundMixModifier(class UObject* WorldContextObject, class UEngine_SoundMix* InSoundMixModifier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PushSoundMixModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PushSoundMixModifier");

	UEngine_GameplayStatics_PushSoundMixModifier_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InSoundMixModifier = InSoundMixModifier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.ProjectWorldToScreen
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_PlayerController* Player                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldPosition                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector2D               ScreenPosition                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           bPlayerViewportRelative        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_ProjectWorldToScreen(class AEngine_PlayerController* Player, const struct FVector& WorldPosition, bool bPlayerViewportRelative, struct FVector2D* ScreenPosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ProjectWorldToScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ProjectWorldToScreen");

	UEngine_GameplayStatics_ProjectWorldToScreen_Params params;
	params.Player = Player;
	params.WorldPosition = WorldPosition;
	params.bPlayerViewportRelative = bPlayerViewportRelative;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ScreenPosition != nullptr)
		*ScreenPosition = params.ScreenPosition;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.PrimeSound
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_SoundBase*       InSound                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PrimeSound(class UEngine_SoundBase* InSound)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PrimeSound");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PrimeSound");

	UEngine_GameplayStatics_PrimeSound_Params params;
	params.InSound = InSound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.PopSoundMixModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundMix*        InSoundMixModifier             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PopSoundMixModifier(class UObject* WorldContextObject, class UEngine_SoundMix* InSoundMixModifier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PopSoundMixModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PopSoundMixModifier");

	UEngine_GameplayStatics_PopSoundMixModifier_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InSoundMixModifier = InSoundMixModifier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.PlayWorldCameraShake
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Shake                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Epicenter                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InnerRadius                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          OuterRadius                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Falloff                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOrientShakeTowardsEpicenter   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PlayWorldCameraShake(class UObject* WorldContextObject, class UClass* Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayWorldCameraShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayWorldCameraShake");

	UEngine_GameplayStatics_PlayWorldCameraShake_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Shake = Shake;
	params.Epicenter = Epicenter;
	params.InnerRadius = InnerRadius;
	params.OuterRadius = OuterRadius;
	params.Falloff = Falloff;
	params.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.PlaySoundAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundConcurrency* ConcurrencySettings            (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           OwningActor                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PlaySoundAtLocation(class UObject* WorldContextObject, class UEngine_SoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundAttenuation* AttenuationSettings, class UEngine_SoundConcurrency* ConcurrencySettings, class AEngine_Actor* OwningActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySoundAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySoundAtLocation");

	UEngine_GameplayStatics_PlaySoundAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;
	params.ConcurrencySettings = ConcurrencySettings;
	params.OwningActor = OwningActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.PlaySound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundConcurrency* ConcurrencySettings            (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           OwningActor                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PlaySound2D(class UObject* WorldContextObject, class UEngine_SoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundConcurrency* ConcurrencySettings, class AEngine_Actor* OwningActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySound2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySound2D");

	UEngine_GameplayStatics_PlaySound2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.ConcurrencySettings = ConcurrencySettings;
	params.OwningActor = OwningActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.PlayDialogueAtLocation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DialogueWave*    Dialogue                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DialogueContext Context                        (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundAttenuation* AttenuationSettings            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PlayDialogueAtLocation(class UObject* WorldContextObject, class UEngine_DialogueWave* Dialogue, const struct FEngine_DialogueContext& Context, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundAttenuation* AttenuationSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogueAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogueAtLocation");

	UEngine_GameplayStatics_PlayDialogueAtLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.Location = Location;
	params.Rotation = Rotation;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.AttenuationSettings = AttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.PlayDialogue2D
// (Final, BlueprintCosmetic, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_DialogueWave*    Dialogue                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DialogueContext Context                        (ConstParm, Parm, OutParm, ReferenceParm)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_PlayDialogue2D(class UObject* WorldContextObject, class UEngine_DialogueWave* Dialogue, const struct FEngine_DialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogue2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogue2D");

	UEngine_GameplayStatics_PlayDialogue2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Dialogue = Dialogue;
	params.Context = Context;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.ParseOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Options                        (Parm, ZeroConstructor)
// struct FString                 Key                            (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_GameplayStatics::STATIC_ParseOption(const struct FString& Options, const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ParseOption");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ParseOption");

	UEngine_GameplayStatics_ParseOption_Params params;
	params.Options = Options;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.OpenLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   LevelName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAbsolute                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Options                        (Parm, ZeroConstructor)

void UEngine_GameplayStatics::STATIC_OpenLevel(class UObject* WorldContextObject, const struct FName& LevelName, bool bAbsolute, const struct FString& Options)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.OpenLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.OpenLevel");

	UEngine_GameplayStatics_OpenLevel_Params params;
	params.WorldContextObject = WorldContextObject;
	params.LevelName = LevelName;
	params.bAbsolute = bAbsolute;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.MakeHitResult
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           bBlockingHit                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bInitialOverlap                (Parm, ZeroConstructor, IsPlainOldData)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Distance                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ImpactPoint                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Normal                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ImpactNormal                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PhysicalMaterial* PhysMat                        (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           HitActor                       (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* HitComponent                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   HitBoneName                    (Parm, ZeroConstructor, IsPlainOldData)
// int                            HitItem                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            FaceIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TraceStart                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TraceEnd                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FEngine_HitResult UEngine_GameplayStatics::STATIC_MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, float Distance, const struct FVector& Location, const struct FVector& ImpactPoint, const struct FVector& Normal, const struct FVector& ImpactNormal, class UEngine_PhysicalMaterial* PhysMat, class AEngine_Actor* HitActor, class UEngine_PrimitiveComponent* HitComponent, const struct FName& HitBoneName, int HitItem, int FaceIndex, const struct FVector& TraceStart, const struct FVector& TraceEnd)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.MakeHitResult");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.MakeHitResult");

	UEngine_GameplayStatics_MakeHitResult_Params params;
	params.bBlockingHit = bBlockingHit;
	params.bInitialOverlap = bInitialOverlap;
	params.Time = Time;
	params.Distance = Distance;
	params.Location = Location;
	params.ImpactPoint = ImpactPoint;
	params.Normal = Normal;
	params.ImpactNormal = ImpactNormal;
	params.PhysMat = PhysMat;
	params.HitActor = HitActor;
	params.HitComponent = HitComponent;
	params.HitBoneName = HitBoneName;
	params.HitItem = HitItem;
	params.FaceIndex = FaceIndex;
	params.TraceStart = TraceStart;
	params.TraceEnd = TraceEnd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.LoadStreamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   LevelName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bMakeVisibleAfterLoad          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShouldBlockOnLoad             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)

void UEngine_GameplayStatics::STATIC_LoadStreamLevel(class UObject* WorldContextObject, const struct FName& LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FEngine_LatentActionInfo& LatentInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadStreamLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadStreamLevel");

	UEngine_GameplayStatics_LoadStreamLevel_Params params;
	params.WorldContextObject = WorldContextObject;
	params.LevelName = LevelName;
	params.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
	params.bShouldBlockOnLoad = bShouldBlockOnLoad;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.LoadGameFromSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 SlotName                       (Parm, ZeroConstructor)
// int                            UserIndex                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SaveGame*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_SaveGame* UEngine_GameplayStatics::STATIC_LoadGameFromSlot(const struct FString& SlotName, int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadGameFromSlot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadGameFromSlot");

	UEngine_GameplayStatics_LoadGameFromSlot_Params params;
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.LH_DisableUpdateStreamingState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           disableUpdateStreamingState    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_LH_DisableUpdateStreamingState(class UObject* WorldContextObject, bool disableUpdateStreamingState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LH_DisableUpdateStreamingState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LH_DisableUpdateStreamingState");

	UEngine_GameplayStatics_LH_DisableUpdateStreamingState_Params params;
	params.WorldContextObject = WorldContextObject;
	params.disableUpdateStreamingState = disableUpdateStreamingState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.IsSplitscreenForceDisabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_IsSplitscreenForceDisabled(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsSplitscreenForceDisabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsSplitscreenForceDisabled");

	UEngine_GameplayStatics_IsSplitscreenForceDisabled_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.IsGamePaused
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_IsGamePaused(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsGamePaused");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsGamePaused");

	UEngine_GameplayStatics_IsGamePaused_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.HasOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Options                        (Parm, ZeroConstructor)
// struct FString                 InKey                          (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_HasOption(const struct FString& Options, const struct FString& InKey)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.HasOption");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.HasOption");

	UEngine_GameplayStatics_HasOption_Params params;
	params.Options = Options;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.HasLaunchOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 OptionToCheck                  (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_HasLaunchOption(const struct FString& OptionToCheck)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.HasLaunchOption");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.HasLaunchOption");

	UEngine_GameplayStatics_HasLaunchOption_Params params;
	params.OptionToCheck = OptionToCheck;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GrassOverlappingSphereCount
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_StaticMesh*      StaticMesh                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 CenterPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameplayStatics::STATIC_GrassOverlappingSphereCount(class UObject* WorldContextObject, class UEngine_StaticMesh* StaticMesh, const struct FVector& CenterPosition, float Radius)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GrassOverlappingSphereCount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GrassOverlappingSphereCount");

	UEngine_GameplayStatics_GrassOverlappingSphereCount_Params params;
	params.WorldContextObject = WorldContextObject;
	params.StaticMesh = StaticMesh;
	params.CenterPosition = CenterPosition;
	params.Radius = Radius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetWorldOriginLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FIntVector              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntVector UEngine_GameplayStatics::STATIC_GetWorldOriginLocation(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldOriginLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldOriginLocation");

	UEngine_GameplayStatics_GetWorldOriginLocation_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetWorldDeltaSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_GetWorldDeltaSeconds(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldDeltaSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldDeltaSeconds");

	UEngine_GameplayStatics_GetWorldDeltaSeconds_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetViewProjectionMatrix
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_MinimalViewInfo DesiredView                    (Parm)
// struct FMatrix                 ViewMatrix                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ProjectionMatrix               (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ViewProjectionMatrix           (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_GetViewProjectionMatrix(const struct FEngine_MinimalViewInfo& DesiredView, struct FMatrix* ViewMatrix, struct FMatrix* ProjectionMatrix, struct FMatrix* ViewProjectionMatrix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetViewProjectionMatrix");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetViewProjectionMatrix");

	UEngine_GameplayStatics_GetViewProjectionMatrix_Params params;
	params.DesiredView = DesiredView;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ViewMatrix != nullptr)
		*ViewMatrix = params.ViewMatrix;
	if (ProjectionMatrix != nullptr)
		*ProjectionMatrix = params.ProjectionMatrix;
	if (ViewProjectionMatrix != nullptr)
		*ViewProjectionMatrix = params.ViewProjectionMatrix;
}


// Function Engine.GameplayStatics.GetViewportMouseCaptureMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EMouseCaptureMode ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FEngine_Engine_EMouseCaptureMode UEngine_GameplayStatics::STATIC_GetViewportMouseCaptureMode(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetViewportMouseCaptureMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetViewportMouseCaptureMode");

	UEngine_GameplayStatics_GetViewportMouseCaptureMode_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetUnpausedTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_GetUnpausedTimeSeconds(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetUnpausedTimeSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetUnpausedTimeSeconds");

	UEngine_GameplayStatics_GetUnpausedTimeSeconds_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_GetTimeSeconds(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetTimeSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetTimeSeconds");

	UEngine_GameplayStatics_GetTimeSeconds_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetSurfaceType
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_HitResult       Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EPhysicalSurface> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_EPhysicalSurface> UEngine_GameplayStatics::STATIC_GetSurfaceType(const struct FEngine_HitResult& Hit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetSurfaceType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetSurfaceType");

	UEngine_GameplayStatics_GetSurfaceType_Params params;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetStreamingLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PackageName                    (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_LevelStreaming*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_LevelStreaming* UEngine_GameplayStatics::STATIC_GetStreamingLevel(class UObject* WorldContextObject, const struct FName& PackageName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetStreamingLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetStreamingLevel");

	UEngine_GameplayStatics_GetStreamingLevel_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PackageName = PackageName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetRealTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_GetRealTimeSeconds(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetRealTimeSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetRealTimeSeconds");

	UEngine_GameplayStatics_GetRealTimeSeconds_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            PlayerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* UEngine_GameplayStatics::STATIC_GetPlayerPawn(class UObject* WorldContextObject, int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerPawn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerPawn");

	UEngine_GameplayStatics_GetPlayerPawn_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerControllerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_PlayerController* Player                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameplayStatics::STATIC_GetPlayerControllerID(class AEngine_PlayerController* Player)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerControllerID");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerControllerID");

	UEngine_GameplayStatics_GetPlayerControllerID_Params params;
	params.Player = Player;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerControllerFromID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerController* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PlayerController* UEngine_GameplayStatics::STATIC_GetPlayerControllerFromID(class UObject* WorldContextObject, int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerControllerFromID");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerControllerFromID");

	UEngine_GameplayStatics_GetPlayerControllerFromID_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            PlayerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerController* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PlayerController* UEngine_GameplayStatics::STATIC_GetPlayerController(class UObject* WorldContextObject, int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerController");

	UEngine_GameplayStatics_GetPlayerController_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerCharacter
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            PlayerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Character*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Character* UEngine_GameplayStatics::STATIC_GetPlayerCharacter(class UObject* WorldContextObject, int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCharacter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCharacter");

	UEngine_GameplayStatics_GetPlayerCharacter_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlayerCameraManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            PlayerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerCameraManager* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PlayerCameraManager* UEngine_GameplayStatics::STATIC_GetPlayerCameraManager(class UObject* WorldContextObject, int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCameraManager");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCameraManager");

	UEngine_GameplayStatics_GetPlayerCameraManager_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetPlatformName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_GameplayStatics::STATIC_GetPlatformName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlatformName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlatformName");

	UEngine_GameplayStatics_GetPlatformName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetObjectClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UEngine_GameplayStatics::STATIC_GetObjectClass(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetObjectClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetObjectClass");

	UEngine_GameplayStatics_GetObjectClass_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetMaxAudioChannelCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameplayStatics::STATIC_GetMaxAudioChannelCount(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetMaxAudioChannelCount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetMaxAudioChannelCount");

	UEngine_GameplayStatics_GetMaxAudioChannelCount_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetKeyValue
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Pair                           (Parm, ZeroConstructor)
// struct FString                 Key                            (Parm, OutParm, ZeroConstructor)
// struct FString                 Value                          (Parm, OutParm, ZeroConstructor)

void UEngine_GameplayStatics::STATIC_GetKeyValue(const struct FString& Pair, struct FString* Key, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetKeyValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetKeyValue");

	UEngine_GameplayStatics_GetKeyValue_Params params;
	params.Pair = Pair;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Key != nullptr)
		*Key = params.Key;
	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.GameplayStatics.GetIntOption
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Options                        (Parm, ZeroConstructor)
// struct FString                 Key                            (Parm, ZeroConstructor)
// int                            DefaultValue                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameplayStatics::STATIC_GetIntOption(const struct FString& Options, const struct FString& Key, int DefaultValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetIntOption");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetIntOption");

	UEngine_GameplayStatics_GetIntOption_Params params;
	params.Options = Options;
	params.Key = Key;
	params.DefaultValue = DefaultValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetGlobalTimeDilation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_GetGlobalTimeDilation(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGlobalTimeDilation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGlobalTimeDilation");

	UEngine_GameplayStatics_GetGlobalTimeDilation_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetGameState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_GameStateBase*   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_GameStateBase* UEngine_GameplayStatics::STATIC_GetGameState(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameState");

	UEngine_GameplayStatics_GetGameState_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetGameMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_GameModeBase*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_GameModeBase* UEngine_GameplayStatics::STATIC_GetGameMode(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameMode");

	UEngine_GameplayStatics_GetGameMode_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_GameInstance*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_GameInstance* UEngine_GameplayStatics::STATIC_GetGameInstance(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameInstance");

	UEngine_GameplayStatics_GetGameInstance_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetEnableWorldRendering
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_GetEnableWorldRendering(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetEnableWorldRendering");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetEnableWorldRendering");

	UEngine_GameplayStatics_GetEnableWorldRendering_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetCurrentReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ReverbEffect*    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_ReverbEffect* UEngine_GameplayStatics::STATIC_GetCurrentReverbEffect(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetCurrentReverbEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetCurrentReverbEffect");

	UEngine_GameplayStatics_GetCurrentReverbEffect_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetCurrentLevelName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRemovePrefixString            (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_GameplayStatics::STATIC_GetCurrentLevelName(class UObject* WorldContextObject, bool bRemovePrefixString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetCurrentLevelName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetCurrentLevelName");

	UEngine_GameplayStatics_GetCurrentLevelName_Params params;
	params.WorldContextObject = WorldContextObject;
	params.bRemovePrefixString = bRemovePrefixString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetAudioTimeSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_GetAudioTimeSeconds(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAudioTimeSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAudioTimeSeconds");

	UEngine_GameplayStatics_GetAudioTimeSeconds_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetAllActorsWithTag
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)

void UEngine_GameplayStatics::STATIC_GetAllActorsWithTag(class UObject* WorldContextObject, const struct FName& Tag, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithTag");

	UEngine_GameplayStatics_GetAllActorsWithTag_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;
}


// Function Engine.GameplayStatics.GetAllActorsWithInterface
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Interface                      (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)

void UEngine_GameplayStatics::STATIC_GetAllActorsWithInterface(class UObject* WorldContextObject, class UClass* Interface, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithInterface");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithInterface");

	UEngine_GameplayStatics_GetAllActorsWithInterface_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Interface = Interface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;
}


// Function Engine.GameplayStatics.GetAllActorsOfClassWithTag
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ActorClass                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Tag                            (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)

void UEngine_GameplayStatics::STATIC_GetAllActorsOfClassWithTag(class UObject* WorldContextObject, class UClass* ActorClass, const struct FName& Tag, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClassWithTag");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClassWithTag");

	UEngine_GameplayStatics_GetAllActorsOfClassWithTag_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;
	params.Tag = Tag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;
}


// Function Engine.GameplayStatics.GetAllActorsOfClass
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ActorClass                     (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)

void UEngine_GameplayStatics::STATIC_GetAllActorsOfClass(class UObject* WorldContextObject, class UClass* ActorClass, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClass");

	UEngine_GameplayStatics_GetAllActorsOfClass_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;
}


// Function Engine.GameplayStatics.GetActorOfClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ActorClass                     (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_GameplayStatics::STATIC_GetActorOfClass(class UObject* WorldContextObject, class UClass* ActorClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorOfClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorOfClass");

	UEngine_GameplayStatics_GetActorOfClass_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetActorArrayBounds
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AEngine_Actor*>   Actors                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bOnlyCollidingComponents       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Center                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_GetActorArrayBounds(TArray<class AEngine_Actor*> Actors, bool bOnlyCollidingComponents, struct FVector* Center, struct FVector* BoxExtent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayBounds");

	UEngine_GameplayStatics_GetActorArrayBounds_Params params;
	params.Actors = Actors;
	params.bOnlyCollidingComponents = bOnlyCollidingComponents;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Center != nullptr)
		*Center = params.Center;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;
}


// Function Engine.GameplayStatics.GetActorArrayAverageLocation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// TArray<class AEngine_Actor*>   Actors                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_GameplayStatics::STATIC_GetActorArrayAverageLocation(TArray<class AEngine_Actor*> Actors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayAverageLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayAverageLocation");

	UEngine_GameplayStatics_GetActorArrayAverageLocation_Params params;
	params.Actors = Actors;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.GetAccurateRealTime
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            Seconds                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          PartialSeconds                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_GetAccurateRealTime(class UObject* WorldContextObject, int* Seconds, float* PartialSeconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAccurateRealTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAccurateRealTime");

	UEngine_GameplayStatics_GetAccurateRealTime_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Seconds != nullptr)
		*Seconds = params.Seconds;
	if (PartialSeconds != nullptr)
		*PartialSeconds = params.PartialSeconds;
}


// Function Engine.GameplayStatics.FlushLevelStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_FlushLevelStreaming(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FlushLevelStreaming");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FlushLevelStreaming");

	UEngine_GameplayStatics_FlushLevelStreaming_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.FinishSpawningActor
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           Actor                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              SpawnTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_GameplayStatics::STATIC_FinishSpawningActor(class AEngine_Actor* Actor, const struct FTransform& SpawnTransform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FinishSpawningActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FinishSpawningActor");

	UEngine_GameplayStatics_FinishSpawningActor_Params params;
	params.Actor = Actor;
	params.SpawnTransform = SpawnTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.FindCollisionUV
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_HitResult       Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// int                            UVChannel                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               UV                             (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_FindCollisionUV(const struct FEngine_HitResult& Hit, int UVChannel, struct FVector2D* UV)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FindCollisionUV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FindCollisionUV");

	UEngine_GameplayStatics_FindCollisionUV_Params params;
	params.Hit = Hit;
	params.UVChannel = UVChannel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (UV != nullptr)
		*UV = params.UV;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.EnableLiveStreaming
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           Enable                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_EnableLiveStreaming(bool Enable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.EnableLiveStreaming");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.EnableLiveStreaming");

	UEngine_GameplayStatics_EnableLiveStreaming_Params params;
	params.Enable = Enable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.DoesSaveGameExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 SlotName                       (Parm, ZeroConstructor)
// int                            UserIndex                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_DoesSaveGameExist(const struct FString& SlotName, int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DoesSaveGameExist");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DoesSaveGameExist");

	UEngine_GameplayStatics_DoesSaveGameExist_Params params;
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.DeprojectScreenToWorld
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_PlayerController* Player                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenPosition                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 WorldPosition                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldDirection                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_DeprojectScreenToWorld(class AEngine_PlayerController* Player, const struct FVector2D& ScreenPosition, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeprojectScreenToWorld");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeprojectScreenToWorld");

	UEngine_GameplayStatics_DeprojectScreenToWorld_Params params;
	params.Player = Player;
	params.ScreenPosition = ScreenPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldPosition != nullptr)
		*WorldPosition = params.WorldPosition;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.DeleteGameInSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 SlotName                       (Parm, ZeroConstructor)
// int                            UserIndex                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_DeleteGameInSlot(const struct FString& SlotName, int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeleteGameInSlot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeleteGameInSlot");

	UEngine_GameplayStatics_DeleteGameInSlot_Params params;
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.DeactivateReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   TagName                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_DeactivateReverbEffect(class UObject* WorldContextObject, const struct FName& TagName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeactivateReverbEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeactivateReverbEffect");

	UEngine_GameplayStatics_DeactivateReverbEffect_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TagName = TagName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.CreateSound2D
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundBase*       Sound                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          VolumeMultiplier               (Parm, ZeroConstructor, IsPlainOldData)
// float                          PitchMultiplier                (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundConcurrency* ConcurrencySettings            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPersistAcrossLevelTransition  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoDestroy                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AudioComponent*  ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_AudioComponent* UEngine_GameplayStatics::STATIC_CreateSound2D(class UObject* WorldContextObject, class UEngine_SoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class UEngine_SoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSound2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSound2D");

	UEngine_GameplayStatics_CreateSound2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Sound = Sound;
	params.VolumeMultiplier = VolumeMultiplier;
	params.PitchMultiplier = PitchMultiplier;
	params.StartTime = StartTime;
	params.ConcurrencySettings = ConcurrencySettings;
	params.bPersistAcrossLevelTransition = bPersistAcrossLevelTransition;
	params.bAutoDestroy = bAutoDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.CreateSaveGameObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                  SaveGameClass                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SaveGame*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_SaveGame* UEngine_GameplayStatics::STATIC_CreateSaveGameObject(class UClass* SaveGameClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSaveGameObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSaveGameObject");

	UEngine_GameplayStatics_CreateSaveGameObject_Params params;
	params.SaveGameClass = SaveGameClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.CreatePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSpawnPlayerController         (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerController* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PlayerController* UEngine_GameplayStatics::STATIC_CreatePlayer(class UObject* WorldContextObject, int ControllerId, bool bSpawnPlayerController)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreatePlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreatePlayer");

	UEngine_GameplayStatics_CreatePlayer_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ControllerId = ControllerId;
	params.bSpawnPlayerController = bSpawnPlayerController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.ClearSoundMixModifiers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_ClearSoundMixModifiers(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixModifiers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixModifiers");

	UEngine_GameplayStatics_ClearSoundMixModifiers_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.ClearSoundMixClassOverride
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundMix*        InSoundMixModifier             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SoundClass*      InSoundClass                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeOutTime                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_ClearSoundMixClassOverride(class UObject* WorldContextObject, class UEngine_SoundMix* InSoundMixModifier, class UEngine_SoundClass* InSoundClass, float FadeOutTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixClassOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixClassOverride");

	UEngine_GameplayStatics_ClearSoundMixClassOverride_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InSoundMixModifier = InSoundMixModifier;
	params.InSoundClass = InSoundClass;
	params.FadeOutTime = FadeOutTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.CancelAsyncLoading
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_GameplayStatics::STATIC_CancelAsyncLoading()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CancelAsyncLoading");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CancelAsyncLoading");

	UEngine_GameplayStatics_CancelAsyncLoading_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameplayStatics.BreakHitResult
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_HitResult       Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bBlockingHit                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           bInitialOverlap                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Time                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Distance                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ImpactPoint                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Normal                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ImpactNormal                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_PhysicalMaterial* PhysMat                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           HitActor                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* HitComponent                   (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   HitBoneName                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            HitItem                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            FaceIndex                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TraceStart                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TraceEnd                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_BreakHitResult(const struct FEngine_HitResult& Hit, bool* bBlockingHit, bool* bInitialOverlap, float* Time, float* Distance, struct FVector* Location, struct FVector* ImpactPoint, struct FVector* Normal, struct FVector* ImpactNormal, class UEngine_PhysicalMaterial** PhysMat, class AEngine_Actor** HitActor, class UEngine_PrimitiveComponent** HitComponent, struct FName* HitBoneName, int* HitItem, int* FaceIndex, struct FVector* TraceStart, struct FVector* TraceEnd)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BreakHitResult");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BreakHitResult");

	UEngine_GameplayStatics_BreakHitResult_Params params;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bBlockingHit != nullptr)
		*bBlockingHit = params.bBlockingHit;
	if (bInitialOverlap != nullptr)
		*bInitialOverlap = params.bInitialOverlap;
	if (Time != nullptr)
		*Time = params.Time;
	if (Distance != nullptr)
		*Distance = params.Distance;
	if (Location != nullptr)
		*Location = params.Location;
	if (ImpactPoint != nullptr)
		*ImpactPoint = params.ImpactPoint;
	if (Normal != nullptr)
		*Normal = params.Normal;
	if (ImpactNormal != nullptr)
		*ImpactNormal = params.ImpactNormal;
	if (PhysMat != nullptr)
		*PhysMat = params.PhysMat;
	if (HitActor != nullptr)
		*HitActor = params.HitActor;
	if (HitComponent != nullptr)
		*HitComponent = params.HitComponent;
	if (HitBoneName != nullptr)
		*HitBoneName = params.HitBoneName;
	if (HitItem != nullptr)
		*HitItem = params.HitItem;
	if (FaceIndex != nullptr)
		*FaceIndex = params.FaceIndex;
	if (TraceStart != nullptr)
		*TraceStart = params.TraceStart;
	if (TraceEnd != nullptr)
		*TraceEnd = params.TraceEnd;
}


// Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TossVelocity                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 StartLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 EndLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          LaunchSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          OverrideGravityZ               (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ESuggestProjVelocityTraceOption> TraceOption                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          CollisionRadius                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFavorHighArc                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDrawDebug                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_BlueprintSuggestProjectileVelocity(class UObject* WorldContextObject, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, TEnumAsByte<FEngine_Engine_ESuggestProjVelocityTraceOption> TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug, struct FVector* TossVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity");

	UEngine_GameplayStatics_BlueprintSuggestProjectileVelocity_Params params;
	params.WorldContextObject = WorldContextObject;
	params.StartLocation = StartLocation;
	params.EndLocation = EndLocation;
	params.LaunchSpeed = LaunchSpeed;
	params.OverrideGravityZ = OverrideGravityZ;
	params.TraceOption = TraceOption;
	params.CollisionRadius = CollisionRadius;
	params.bFavorHighArc = bFavorHighArc;
	params.bDrawDebug = bDrawDebug;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (TossVelocity != nullptr)
		*TossVelocity = params.TossVelocity;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// TArray<struct FVector>         OutPathPositions               (Parm, OutParm, ZeroConstructor)
// struct FVector                 OutLastTraceDestination        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 StartPos                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LaunchVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTracePath                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ProjectileRadius               (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECollisionChannel> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawDebugTime                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          SimFrequency                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxSimTime                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          OverrideGravityZ               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_Blueprint_PredictProjectilePath_ByTraceChannel(class UObject* WorldContextObject, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, TEnumAsByte<FEngine_Engine_ECollisionChannel> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ, struct FEngine_HitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel");

	UEngine_GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel_Params params;
	params.WorldContextObject = WorldContextObject;
	params.StartPos = StartPos;
	params.LaunchVelocity = LaunchVelocity;
	params.bTracePath = bTracePath;
	params.ProjectileRadius = ProjectileRadius;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.DrawDebugTime = DrawDebugTime;
	params.SimFrequency = SimFrequency;
	params.MaxSimTime = MaxSimTime;
	params.OverrideGravityZ = OverrideGravityZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;
	if (OutPathPositions != nullptr)
		*OutPathPositions = params.OutPathPositions;
	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = params.OutLastTraceDestination;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByObjectType
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// TArray<struct FVector>         OutPathPositions               (Parm, OutParm, ZeroConstructor)
// struct FVector                 OutLastTraceDestination        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 StartPos                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LaunchVelocity                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTracePath                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ProjectileRadius               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawDebugTime                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          SimFrequency                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxSimTime                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          OverrideGravityZ               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_Blueprint_PredictProjectilePath_ByObjectType(class UObject* WorldContextObject, const struct FVector& StartPos, const struct FVector& LaunchVelocity, bool bTracePath, float ProjectileRadius, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ, struct FEngine_HitResult* OutHit, TArray<struct FVector>* OutPathPositions, struct FVector* OutLastTraceDestination)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByObjectType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByObjectType");

	UEngine_GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType_Params params;
	params.WorldContextObject = WorldContextObject;
	params.StartPos = StartPos;
	params.LaunchVelocity = LaunchVelocity;
	params.bTracePath = bTracePath;
	params.ProjectileRadius = ProjectileRadius;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.DrawDebugTime = DrawDebugTime;
	params.SimFrequency = SimFrequency;
	params.MaxSimTime = MaxSimTime;
	params.OverrideGravityZ = OverrideGravityZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;
	if (OutPathPositions != nullptr)
		*OutPathPositions = params.OutPathPositions;
	if (OutLastTraceDestination != nullptr)
		*OutLastTraceDestination = params.OutLastTraceDestination;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_Advanced
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_PredictProjectilePathParams PredictParams                  (ConstParm, Parm, OutParm, ReferenceParm)
// struct FEngine_PredictProjectilePathResult PredictResult                  (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_Blueprint_PredictProjectilePath_Advanced(class UObject* WorldContextObject, const struct FEngine_PredictProjectilePathParams& PredictParams, struct FEngine_PredictProjectilePathResult* PredictResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_Advanced");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_Advanced");

	UEngine_GameplayStatics_Blueprint_PredictProjectilePath_Advanced_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PredictParams = PredictParams;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PredictResult != nullptr)
		*PredictResult = params.PredictResult;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.BeginSpawningActorFromClass
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ActorClass                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              SpawnTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bNoCollisionFail               (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           Owner                          (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_GameplayStatics::STATIC_BeginSpawningActorFromClass(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, bool bNoCollisionFail, class AEngine_Actor* Owner)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromClass");

	UEngine_GameplayStatics_BeginSpawningActorFromClass_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;
	params.SpawnTransform = SpawnTransform;
	params.bNoCollisionFail = bNoCollisionFail;
	params.Owner = Owner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Blueprint*       Blueprint                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              SpawnTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bNoCollisionFail               (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_GameplayStatics::STATIC_BeginSpawningActorFromBlueprint(class UObject* WorldContextObject, class UEngine_Blueprint* Blueprint, const struct FTransform& SpawnTransform, bool bNoCollisionFail)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint");

	UEngine_GameplayStatics_BeginSpawningActorFromBlueprint_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Blueprint = Blueprint;
	params.SpawnTransform = SpawnTransform;
	params.bNoCollisionFail = bNoCollisionFail;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ActorClass                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              SpawnTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// FEngine_Engine_ESpawnActorCollisionHandlingMethod CollisionHandlingOverride      (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           Owner                          (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_GameplayStatics::STATIC_BeginDeferredActorSpawnFromClass(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, FEngine_Engine_ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AEngine_Actor* Owner)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass");

	UEngine_GameplayStatics_BeginDeferredActorSpawnFromClass_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ActorClass = ActorClass;
	params.SpawnTransform = SpawnTransform;
	params.CollisionHandlingOverride = CollisionHandlingOverride;
	params.Owner = Owner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.AreSubtitlesEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_AreSubtitlesEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreSubtitlesEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreSubtitlesEnabled");

	UEngine_GameplayStatics_AreSubtitlesEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.AreAnyListenersWithinRange
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaximumRange                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_AreAnyListenersWithinRange(class UObject* WorldContextObject, const struct FVector& Location, float MaximumRange)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreAnyListenersWithinRange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreAnyListenersWithinRange");

	UEngine_GameplayStatics_AreAnyListenersWithinRange_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Location = Location;
	params.MaximumRange = MaximumRange;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinimumDamage                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          DamageInnerRadius              (Parm, ZeroConstructor, IsPlainOldData)
// float                          DamageOuterRadius              (Parm, ZeroConstructor, IsPlainOldData)
// float                          DamageFalloff                  (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   IgnoreActors                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Controller*      InstigatedByController         (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECollisionChannel> DamagePreventionChannel        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_ApplyRadialDamageWithFalloff(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, class UClass* DamageTypeClass, TArray<class AEngine_Actor*> IgnoreActors, class AEngine_Actor* DamageCauser, class AEngine_Controller* InstigatedByController, TEnumAsByte<FEngine_Engine_ECollisionChannel> DamagePreventionChannel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff");

	UEngine_GameplayStatics_ApplyRadialDamageWithFalloff_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.MinimumDamage = MinimumDamage;
	params.Origin = Origin;
	params.DamageInnerRadius = DamageInnerRadius;
	params.DamageOuterRadius = DamageOuterRadius;
	params.DamageFalloff = DamageFalloff;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.DamagePreventionChannel = DamagePreventionChannel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.ApplyRadialDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          DamageRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   IgnoreActors                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Controller*      InstigatedByController         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDoFullDamage                  (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECollisionChannel> DamagePreventionChannel        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameplayStatics::STATIC_ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, class UClass* DamageTypeClass, TArray<class AEngine_Actor*> IgnoreActors, class AEngine_Actor* DamageCauser, class AEngine_Controller* InstigatedByController, bool bDoFullDamage, TEnumAsByte<FEngine_Engine_ECollisionChannel> DamagePreventionChannel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamage");

	UEngine_GameplayStatics_ApplyRadialDamage_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.Origin = Origin;
	params.DamageRadius = DamageRadius;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.bDoFullDamage = bDoFullDamage;
	params.DamagePreventionChannel = DamagePreventionChannel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.ApplyPointDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           DamagedActor                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HitFromDirection               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FEngine_HitResult       HitInfo                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// class AEngine_Controller*      EventInstigator                (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_ApplyPointDamage(class AEngine_Actor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FEngine_HitResult& HitInfo, class AEngine_Controller* EventInstigator, class AEngine_Actor* DamageCauser, class UClass* DamageTypeClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyPointDamage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyPointDamage");

	UEngine_GameplayStatics_ApplyPointDamage_Params params;
	params.DamagedActor = DamagedActor;
	params.BaseDamage = BaseDamage;
	params.HitFromDirection = HitFromDirection;
	params.HitInfo = HitInfo;
	params.EventInstigator = EventInstigator;
	params.DamageCauser = DamageCauser;
	params.DamageTypeClass = DamageTypeClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.ApplyDamage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           DamagedActor                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseDamage                     (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Controller*      EventInstigator                (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           DamageCauser                   (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  DamageTypeClass                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameplayStatics::STATIC_ApplyDamage(class AEngine_Actor* DamagedActor, float BaseDamage, class AEngine_Controller* EventInstigator, class AEngine_Actor* DamageCauser, class UClass* DamageTypeClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyDamage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyDamage");

	UEngine_GameplayStatics_ApplyDamage_Params params;
	params.DamagedActor = DamagedActor;
	params.BaseDamage = BaseDamage;
	params.EventInstigator = EventInstigator;
	params.DamageCauser = DamageCauser;
	params.DamageTypeClass = DamageTypeClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameplayStatics.ActivateReverbEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ReverbEffect*    ReverbEffect                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   TagName                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Priority                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Volume                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeTime                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameplayStatics::STATIC_ActivateReverbEffect(class UObject* WorldContextObject, class UEngine_ReverbEffect* ReverbEffect, const struct FName& TagName, float Priority, float Volume, float FadeTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ActivateReverbEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ActivateReverbEffect");

	UEngine_GameplayStatics_ActivateReverbEffect_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ReverbEffect = ReverbEffect;
	params.TagName = TagName;
	params.Priority = Priority;
	params.Volume = Volume;
	params.FadeTime = FadeTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.SSSwapControllers
// (Exec, Native, Public)

void UEngine_GameViewportClient::SSSwapControllers()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SSSwapControllers");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SSSwapControllers");

	UEngine_GameViewportClient_SSSwapControllers_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.ShowTitleSafeArea
// (Exec, Native, Public)

void UEngine_GameViewportClient::ShowTitleSafeArea()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.ShowTitleSafeArea");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.ShowTitleSafeArea");

	UEngine_GameViewportClient_ShowTitleSafeArea_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameViewportClient.SetConsoleTarget
// (Exec, Native, Public)
// Parameters:
// int                            PlayerIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameViewportClient::SetConsoleTarget(int PlayerIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SetConsoleTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SetConsoleTarget");

	UEngine_GameViewportClient_SetConsoleTarget_Params params;
	params.PlayerIndex = PlayerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshActor.SetMobility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EComponentMobility> InMobility                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_StaticMeshActor::SetMobility(TEnumAsByte<FEngine_Engine_EComponentMobility> InMobility)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshActor.SetMobility");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshActor.SetMobility");

	AEngine_StaticMeshActor_SetMobility_Params params;
	params.InMobility = InMobility;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShowHUD
// (Exec, Native, Public)

void AEngine_HUD::ShowHUD()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowHUD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowHUD");

	AEngine_HUD_ShowHUD_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShowDebugToggleSubCategory
// (Final, Exec, Native, Public)
// Parameters:
// struct FName                   Category                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ShowDebugToggleSubCategory(const struct FName& Category)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugToggleSubCategory");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugToggleSubCategory");

	AEngine_HUD_ShowDebugToggleSubCategory_Params params;
	params.Category = Category;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShowDebugForReticleTargetToggle
// (Final, Exec, Native, Public)
// Parameters:
// class UClass*                  DesiredClass                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ShowDebugForReticleTargetToggle(class UClass* DesiredClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugForReticleTargetToggle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugForReticleTargetToggle");

	AEngine_HUD_ShowDebugForReticleTargetToggle_Params params;
	params.DesiredClass = DesiredClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ShowDebug
// (Exec, Native, Public)
// Parameters:
// struct FName                   DebugType                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ShowDebug(const struct FName& DebugType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebug");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebug");

	AEngine_HUD_ShowDebug_Params params;
	params.DebugType = DebugType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.RemoveDebugText
// (Final, Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AEngine_Actor*           SrcActor                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLeaveDurationText             (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::RemoveDebugText(class AEngine_Actor* SrcActor, bool bLeaveDurationText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveDebugText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveDebugText");

	AEngine_HUD_RemoveDebugText_Params params;
	params.SrcActor = SrcActor;
	params.bLeaveDurationText = bLeaveDurationText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.RemoveAllDebugStrings
// (Final, Net, NetReliable, Native, Event, Public, NetClient)

void AEngine_HUD::RemoveAllDebugStrings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveAllDebugStrings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveAllDebugStrings");

	AEngine_HUD_RemoveAllDebugStrings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ReceiveHitBoxRelease
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FName                   BoxName                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ReceiveHitBoxRelease(const struct FName& BoxName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxRelease");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxRelease");

	AEngine_HUD_ReceiveHitBoxRelease_Params params;
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ReceiveHitBoxEndCursorOver
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FName                   BoxName                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ReceiveHitBoxEndCursorOver(const struct FName& BoxName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxEndCursorOver");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxEndCursorOver");

	AEngine_HUD_ReceiveHitBoxEndCursorOver_Params params;
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ReceiveHitBoxClick
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FName                   BoxName                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ReceiveHitBoxClick(const struct FName& BoxName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxClick");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxClick");

	AEngine_HUD_ReceiveHitBoxClick_Params params;
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ReceiveHitBoxBeginCursorOver
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// struct FName                   BoxName                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ReceiveHitBoxBeginCursorOver(const struct FName& BoxName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxBeginCursorOver");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxBeginCursorOver");

	AEngine_HUD_ReceiveHitBoxBeginCursorOver_Params params;
	params.BoxName = BoxName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.ReceiveDrawHUD
// (BlueprintCosmetic, Event, Public, BlueprintEvent)
// Parameters:
// int                            SizeX                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            SizeY                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::ReceiveDrawHUD(int SizeX, int SizeY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveDrawHUD");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveDrawHUD");

	AEngine_HUD_ReceiveDrawHUD_Params params;
	params.SizeX = SizeX;
	params.SizeY = SizeY;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.Project
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_HUD::Project(const struct FVector& Location)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.Project");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.Project");

	AEngine_HUD_Project_Params params;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HUD.PreviousDebugTarget
// (Exec, Native, Public)

void AEngine_HUD::PreviousDebugTarget()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.PreviousDebugTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.PreviousDebugTarget");

	AEngine_HUD_PreviousDebugTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.NextDebugTarget
// (Exec, Native, Public)

void AEngine_HUD::NextDebugTarget()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.NextDebugTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.NextDebugTarget");

	AEngine_HUD_NextDebugTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.GetTextSize
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 Text                           (Parm, ZeroConstructor)
// float                          OutWidth                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutHeight                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_Font*            Font                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::GetTextSize(const struct FString& Text, class UEngine_Font* Font, float Scale, float* OutWidth, float* OutHeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetTextSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetTextSize");

	AEngine_HUD_GetTextSize_Params params;
	params.Text = Text;
	params.Font = Font;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutWidth != nullptr)
		*OutWidth = params.OutWidth;
	if (OutHeight != nullptr)
		*OutHeight = params.OutHeight;
}


// Function Engine.HUD.GetOwningPlayerController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_PlayerController* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PlayerController* AEngine_HUD::GetOwningPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPlayerController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPlayerController");

	AEngine_HUD_GetOwningPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HUD.GetOwningPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Pawn*            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Pawn* AEngine_HUD::GetOwningPawn()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPawn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPawn");

	AEngine_HUD_GetOwningPawn_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HUD.GetActorsInSelectionRectangle
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  ClassFilter                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               FirstPoint                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector2D               SecondPoint                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)
// bool                           bIncludeNonCollidingComponents (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bActorMustBeFullyEnclosed      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::GetActorsInSelectionRectangle(class UClass* ClassFilter, const struct FVector2D& FirstPoint, const struct FVector2D& SecondPoint, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetActorsInSelectionRectangle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetActorsInSelectionRectangle");

	AEngine_HUD_GetActorsInSelectionRectangle_Params params;
	params.ClassFilter = ClassFilter;
	params.FirstPoint = FirstPoint;
	params.SecondPoint = SecondPoint;
	params.bIncludeNonCollidingComponents = bIncludeNonCollidingComponents;
	params.bActorMustBeFullyEnclosed = bActorMustBeFullyEnclosed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;
}


// Function Engine.HUD.DrawTextureSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         Texture                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bScalePosition                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawTextureSimple(class UEngine_Texture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTextureSimple");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTextureSimple");

	AEngine_HUD_DrawTextureSimple_Params params;
	params.Texture = Texture;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         Texture                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenW                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenH                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          TextureU                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          TextureV                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          TextureUWidth                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          TextureVHeight                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TintColor                      (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBlendMode> BlendMode                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bScalePosition                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               RotPivot                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawTexture(class UEngine_Texture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, const struct FLinearColor& TintColor, TEnumAsByte<FEngine_Engine_EBlendMode> BlendMode, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTexture");

	AEngine_HUD_DrawTexture_Params params;
	params.Texture = Texture;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;
	params.TextureU = TextureU;
	params.TextureV = TextureV;
	params.TextureUWidth = TextureUWidth;
	params.TextureVHeight = TextureVHeight;
	params.TintColor = TintColor;
	params.BlendMode = BlendMode;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;
	params.Rotation = Rotation;
	params.RotPivot = RotPivot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FString                 Text                           (Parm, ZeroConstructor)
// struct FLinearColor            TextColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Font*            Font                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bScalePosition                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawText(const struct FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UEngine_Font* Font, float Scale, bool bScalePosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawText");

	AEngine_HUD_DrawText_Params params;
	params.Text = Text;
	params.TextColor = TextColor;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.Font = Font;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawRect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            RectColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenW                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenH                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawRect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawRect");

	AEngine_HUD_DrawRect_Params params;
	params.RectColor = RectColor;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawMaterialTriangle
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               V0_Pos                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               V1_Pos                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               V2_Pos                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               V0_UV                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               V1_UV                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               V2_UV                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            V0_Color                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            V1_Color                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            V2_Color                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawMaterialTriangle(class UEngine_MaterialInterface* Material, const struct FVector2D& V0_Pos, const struct FVector2D& V1_Pos, const struct FVector2D& V2_Pos, const struct FVector2D& V0_UV, const struct FVector2D& V1_UV, const struct FVector2D& V2_UV, const struct FLinearColor& V0_Color, const struct FLinearColor& V1_Color, const struct FLinearColor& V2_Color)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialTriangle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialTriangle");

	AEngine_HUD_DrawMaterialTriangle_Params params;
	params.Material = Material;
	params.V0_Pos = V0_Pos;
	params.V1_Pos = V1_Pos;
	params.V2_Pos = V2_Pos;
	params.V0_UV = V0_UV;
	params.V1_UV = V1_UV;
	params.V2_UV = V2_UV;
	params.V0_Color = V0_Color;
	params.V1_Color = V1_Color;
	params.V2_Color = V2_Color;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawMaterialSimple
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenW                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenH                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bScalePosition                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawMaterialSimple(class UEngine_MaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialSimple");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialSimple");

	AEngine_HUD_DrawMaterialSimple_Params params;
	params.Material = Material;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawMaterial
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenW                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenH                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaterialU                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaterialV                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaterialUWidth                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaterialVHeight                (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bScalePosition                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               RotPivot                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawMaterial(class UEngine_MaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterial");

	AEngine_HUD_DrawMaterial_Params params;
	params.Material = Material;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;
	params.ScreenW = ScreenW;
	params.ScreenH = ScreenH;
	params.MaterialU = MaterialU;
	params.MaterialV = MaterialV;
	params.MaterialUWidth = MaterialUWidth;
	params.MaterialVHeight = MaterialVHeight;
	params.Scale = Scale;
	params.bScalePosition = bScalePosition;
	params.Rotation = Rotation;
	params.RotPivot = RotPivot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.DrawLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                          StartScreenX                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          StartScreenY                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          EndScreenX                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          EndScreenY                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          LineThickness                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor, float LineThickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawLine");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawLine");

	AEngine_HUD_DrawLine_Params params;
	params.StartScreenX = StartScreenX;
	params.StartScreenY = StartScreenY;
	params.EndScreenX = EndScreenX;
	params.EndScreenY = EndScreenY;
	params.LineColor = LineColor;
	params.LineThickness = LineThickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.Deproject
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ScreenX                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ScreenY                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldPosition                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldDirection                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::Deproject(float ScreenX, float ScreenY, struct FVector* WorldPosition, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.Deproject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.Deproject");

	AEngine_HUD_Deproject_Params params;
	params.ScreenX = ScreenX;
	params.ScreenY = ScreenY;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldPosition != nullptr)
		*WorldPosition = params.WorldPosition;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;
}


// Function Engine.HUD.AddHitBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               Position                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Size                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bConsumesInput                 (Parm, ZeroConstructor, IsPlainOldData)
// int                            Priority                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::AddHitBox(const struct FVector2D& Position, const struct FVector2D& Size, const struct FName& InName, bool bConsumesInput, int Priority)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddHitBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddHitBox");

	AEngine_HUD_AddHitBox_Params params;
	params.Position = Position;
	params.Size = Size;
	params.InName = InName;
	params.bConsumesInput = bConsumesInput;
	params.Priority = Priority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HUD.AddDebugText
// (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// struct FString                 DebugText                      (Parm, ZeroConstructor)
// class AEngine_Actor*           SrcActor                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Offset                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 DesiredOffset                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  TextColor                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSkipOverwriteCheck            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAbsoluteLocation              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bKeepAttachedToActor           (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Font*            InFont                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          FontScale                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDrawShadow                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_HUD::AddDebugText(const struct FString& DebugText, class AEngine_Actor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UEngine_Font* InFont, float FontScale, bool bDrawShadow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddDebugText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddDebugText");

	AEngine_HUD_AddDebugText_Params params;
	params.DebugText = DebugText;
	params.SrcActor = SrcActor;
	params.Duration = Duration;
	params.Offset = Offset;
	params.DesiredOffset = DesiredOffset;
	params.TextColor = TextColor;
	params.bSkipOverwriteCheck = bSkipOverwriteCheck;
	params.bAbsoluteLocation = bAbsoluteLocation;
	params.bKeepAttachedToActor = bKeepAttachedToActor;
	params.InFont = InFont;
	params.FontScale = FontScale;
	params.bDrawShadow = bDrawShadow;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ChildActorComponent.SetChildActorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  InClass                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ChildActorComponent::SetChildActorClass(class UClass* InClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ChildActorComponent.SetChildActorClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ChildActorComponent.SetChildActorClass");

	UEngine_ChildActorComponent_SetChildActorClass_Params params;
	params.InClass = InClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelScriptActor.WorldOriginLocationChanged
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// struct FIntVector              OldOriginLocation              (Parm, ZeroConstructor, IsPlainOldData)
// struct FIntVector              NewOriginLocation              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_LevelScriptActor::WorldOriginLocationChanged(const struct FIntVector& OldOriginLocation, const struct FIntVector& NewOriginLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.WorldOriginLocationChanged");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.WorldOriginLocationChanged");

	AEngine_LevelScriptActor_WorldOriginLocationChanged_Params params;
	params.OldOriginLocation = OldOriginLocation;
	params.NewOriginLocation = NewOriginLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelScriptActor.SetCinematicMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bCinematicMode                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHidePlayer                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsHUD                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsMovement               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAffectsTurning                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_LevelScriptActor::SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.SetCinematicMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.SetCinematicMode");

	AEngine_LevelScriptActor_SetCinematicMode_Params params;
	params.bCinematicMode = bCinematicMode;
	params.bHidePlayer = bHidePlayer;
	params.bAffectsHUD = bAffectsHUD;
	params.bAffectsMovement = bAffectsMovement;
	params.bAffectsTurning = bAffectsTurning;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelScriptActor.RemoteEvent
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   EventName                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_LevelScriptActor::RemoteEvent(const struct FName& EventName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.RemoteEvent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.RemoteEvent");

	AEngine_LevelScriptActor_RemoteEvent_Params params;
	params.EventName = EventName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelScriptActor.LevelReset
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)

void AEngine_LevelScriptActor::LevelReset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.LevelReset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.LevelReset");

	AEngine_LevelScriptActor_LevelReset_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StopCameraShake
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_CameraShake*     ShakeInstance                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bImmediately                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::StopCameraShake(class UEngine_CameraShake* ShakeInstance, bool bImmediately)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraShake");

	AEngine_PlayerCameraManager_StopCameraShake_Params params;
	params.ShakeInstance = ShakeInstance;
	params.bImmediately = bImmediately;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StopCameraFade
// (Native, Public, BlueprintCallable)

void AEngine_PlayerCameraManager::StopCameraFade()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraFade");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraFade");

	AEngine_PlayerCameraManager_StopCameraFade_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StopCameraAnimInst
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_CameraAnimInst*  AnimInst                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bImmediate                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::StopCameraAnimInst(class UEngine_CameraAnimInst* AnimInst, bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraAnimInst");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraAnimInst");

	AEngine_PlayerCameraManager_StopCameraAnimInst_Params params;
	params.AnimInst = AnimInst;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake
// (Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  Shake                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bImmediately                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::StopAllInstancesOfCameraShake(class UClass* Shake, bool bImmediately)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake");

	AEngine_PlayerCameraManager_StopAllInstancesOfCameraShake_Params params;
	params.Shake = Shake;
	params.bImmediately = bImmediately;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_CameraAnim*      Anim                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bImmediate                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::StopAllInstancesOfCameraAnim(class UEngine_CameraAnim* Anim, bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim");

	AEngine_PlayerCameraManager_StopAllInstancesOfCameraAnim_Params params;
	params.Anim = Anim;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StopAllCameraShakes
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bImmediately                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::StopAllCameraShakes(bool bImmediately)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraShakes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraShakes");

	AEngine_PlayerCameraManager_StopAllCameraShakes_Params params;
	params.bImmediately = bImmediately;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StopAllCameraAnims
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bImmediate                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::StopAllCameraAnims(bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraAnims");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraAnims");

	AEngine_PlayerCameraManager_StopAllCameraAnims_Params params;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.StartCameraFade
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                          FromAlpha                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ToAlpha                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Color                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShouldFadeAudio               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bHoldWhenFinished              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::StartCameraFade(float FromAlpha, float ToAlpha, float Duration, const struct FLinearColor& Color, bool bShouldFadeAudio, bool bHoldWhenFinished)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StartCameraFade");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StartCameraFade");

	AEngine_PlayerCameraManager_StartCameraFade_Params params;
	params.FromAlpha = FromAlpha;
	params.ToAlpha = ToAlpha;
	params.Duration = Duration;
	params.Color = Color;
	params.bShouldFadeAudio = bShouldFadeAudio;
	params.bHoldWhenFinished = bHoldWhenFinished;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.SetManualCameraFade
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                          InFadeAmount                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Color                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bInFadeAudio                   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::SetManualCameraFade(float InFadeAmount, const struct FLinearColor& Color, bool bInFadeAudio)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SetManualCameraFade");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SetManualCameraFade");

	AEngine_PlayerCameraManager_SetManualCameraFade_Params params;
	params.InFadeAmount = InFadeAmount;
	params.Color = Color;
	params.bInFadeAudio = bInFadeAudio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.SetGameCameraCutThisFrame
// (Final, Native, Public, BlueprintCallable)

void AEngine_PlayerCameraManager::SetGameCameraCutThisFrame()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SetGameCameraCutThisFrame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.SetGameCameraCutThisFrame");

	AEngine_PlayerCameraManager_SetGameCameraCutThisFrame_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.RemoveCameraModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_CameraModifier*  ModifierToRemove               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerCameraManager::RemoveCameraModifier(class UEngine_CameraModifier* ModifierToRemove)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraModifier");

	AEngine_PlayerCameraManager_RemoveCameraModifier_Params params;
	params.ModifierToRemove = ModifierToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.RemoveCameraLensEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_EmitterCameraLensEffectBase* Emitter                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::RemoveCameraLensEffect(class AEngine_EmitterCameraLensEffectBase* Emitter)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraLensEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraLensEffect");

	AEngine_PlayerCameraManager_RemoveCameraLensEffect_Params params;
	params.Emitter = Emitter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.PlayCameraShake
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UClass*                  ShakeClass                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> PlaySpace                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                UserPlaySpaceRot               (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_CameraShake*     ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_CameraShake* AEngine_PlayerCameraManager::PlayCameraShake(class UClass* ShakeClass, float Scale, TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PlayCameraShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PlayCameraShake");

	AEngine_PlayerCameraManager_PlayCameraShake_Params params;
	params.ShakeClass = ShakeClass;
	params.Scale = Scale;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.PlayCameraAnim
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_CameraAnim*      Anim                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Rate                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendInTime                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendOutTime                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLoop                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRandomStartTime               (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> PlaySpace                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                UserPlaySpaceRot               (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_CameraAnimInst*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_CameraAnimInst* AEngine_PlayerCameraManager::PlayCameraAnim(class UEngine_CameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, TEnumAsByte<FEngine_Engine_ECameraAnimPlaySpace> PlaySpace, const struct FRotator& UserPlaySpaceRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PlayCameraAnim");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PlayCameraAnim");

	AEngine_PlayerCameraManager_PlayCameraAnim_Params params;
	params.Anim = Anim;
	params.Rate = Rate;
	params.Scale = Scale;
	params.BlendInTime = BlendInTime;
	params.BlendOutTime = BlendOutTime;
	params.bLoop = bLoop;
	params.bRandomStartTime = bRandomStartTime;
	params.Duration = Duration;
	params.PlaySpace = PlaySpace;
	params.UserPlaySpaceRot = UserPlaySpaceRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.PhotographyCameraModify
// (BlueprintCosmetic, Native, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                 NewCameraLocation              (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PreviousCameraLocation         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OriginalCameraLocation         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ResultCameraLocation           (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerCameraManager::PhotographyCameraModify(const struct FVector& NewCameraLocation, const struct FVector& PreviousCameraLocation, const struct FVector& OriginalCameraLocation, struct FVector* ResultCameraLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PhotographyCameraModify");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PhotographyCameraModify");

	AEngine_PlayerCameraManager_PhotographyCameraModify_Params params;
	params.NewCameraLocation = NewCameraLocation;
	params.PreviousCameraLocation = PreviousCameraLocation;
	params.OriginalCameraLocation = OriginalCameraLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ResultCameraLocation != nullptr)
		*ResultCameraLocation = params.ResultCameraLocation;
}


// Function Engine.PlayerCameraManager.OnPhotographySessionStart
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void AEngine_PlayerCameraManager::OnPhotographySessionStart()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographySessionStart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographySessionStart");

	AEngine_PlayerCameraManager_OnPhotographySessionStart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.OnPhotographySessionEnd
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void AEngine_PlayerCameraManager::OnPhotographySessionEnd()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographySessionEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographySessionEnd");

	AEngine_PlayerCameraManager_OnPhotographySessionEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureStart
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void AEngine_PlayerCameraManager::OnPhotographyMultiPartCaptureStart()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureStart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureStart");

	AEngine_PlayerCameraManager_OnPhotographyMultiPartCaptureStart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureEnd
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void AEngine_PlayerCameraManager::OnPhotographyMultiPartCaptureEnd()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.OnPhotographyMultiPartCaptureEnd");

	AEngine_PlayerCameraManager_OnPhotographyMultiPartCaptureEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.GetOwningPlayerController
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_PlayerController* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_PlayerController* AEngine_PlayerCameraManager::GetOwningPlayerController()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetOwningPlayerController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetOwningPlayerController");

	AEngine_PlayerCameraManager_GetOwningPlayerController_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.GetFOVAngle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_PlayerCameraManager::GetFOVAngle()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetFOVAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetFOVAngle");

	AEngine_PlayerCameraManager_GetFOVAngle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.GetCameraRotation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator AEngine_PlayerCameraManager::GetCameraRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraRotation");

	AEngine_PlayerCameraManager_GetCameraRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.GetCameraLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector AEngine_PlayerCameraManager::GetCameraLocation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraLocation");

	AEngine_PlayerCameraManager_GetCameraLocation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.FindCameraModifierByClass
// (Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ModifierClass                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_CameraModifier*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_CameraModifier* AEngine_PlayerCameraManager::FindCameraModifierByClass(class UClass* ModifierClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.FindCameraModifierByClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.FindCameraModifierByClass");

	AEngine_PlayerCameraManager_FindCameraModifierByClass_Params params;
	params.ModifierClass = ModifierClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.ClearCameraLensEffects
// (Native, Public, BlueprintCallable)

void AEngine_PlayerCameraManager::ClearCameraLensEffects()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.ClearCameraLensEffects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.ClearCameraLensEffects");

	AEngine_PlayerCameraManager_ClearCameraLensEffects_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerCameraManager.BlueprintUpdateCamera
// (BlueprintCosmetic, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// class AEngine_Actor*           CameraTarget                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewCameraLocation              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewCameraRotation              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          NewCameraFOV                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_PlayerCameraManager::BlueprintUpdateCamera(class AEngine_Actor* CameraTarget, struct FVector* NewCameraLocation, struct FRotator* NewCameraRotation, float* NewCameraFOV)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.BlueprintUpdateCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.BlueprintUpdateCamera");

	AEngine_PlayerCameraManager_BlueprintUpdateCamera_Params params;
	params.CameraTarget = CameraTarget;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewCameraLocation != nullptr)
		*NewCameraLocation = params.NewCameraLocation;
	if (NewCameraRotation != nullptr)
		*NewCameraRotation = params.NewCameraRotation;
	if (NewCameraFOV != nullptr)
		*NewCameraFOV = params.NewCameraFOV;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.AddNewCameraModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ModifierClass                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_CameraModifier*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_CameraModifier* AEngine_PlayerCameraManager::AddNewCameraModifier(class UClass* ModifierClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddNewCameraModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddNewCameraModifier");

	AEngine_PlayerCameraManager_AddNewCameraModifier_Params params;
	params.ModifierClass = ModifierClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlayerCameraManager.AddCameraLensEffect
// (Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  LensEffectEmitterClass         (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_EmitterCameraLensEffectBase* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_EmitterCameraLensEffectBase* AEngine_PlayerCameraManager::AddCameraLensEffect(class UClass* LensEffectEmitterClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddCameraLensEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddCameraLensEffect");

	AEngine_PlayerCameraManager_AddCameraLensEffect_Params params;
	params.LensEffectEmitterClass = LensEffectEmitterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.WorldSettings.OnRep_WorldGravityZ
// (Native, Public)

void AEngine_WorldSettings::OnRep_WorldGravityZ()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.WorldSettings.OnRep_WorldGravityZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.WorldSettings.OnRep_WorldGravityZ");

	AEngine_WorldSettings_OnRep_WorldGravityZ_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMode.StartMatch
// (Native, Public, BlueprintCallable)

void AEngine_GameMode::StartMatch()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.StartMatch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.StartMatch");

	AEngine_GameMode_StartMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMode.SetBandwidthLimit
// (Exec, Native, Public)
// Parameters:
// float                          AsyncIOBandwidthLimit          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameMode::SetBandwidthLimit(float AsyncIOBandwidthLimit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.SetBandwidthLimit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.SetBandwidthLimit");

	AEngine_GameMode_SetBandwidthLimit_Params params;
	params.AsyncIOBandwidthLimit = AsyncIOBandwidthLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMode.Say
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 Msg                            (Parm, ZeroConstructor)

void AEngine_GameMode::Say(const struct FString& Msg)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.Say");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.Say");

	AEngine_GameMode_Say_Params params;
	params.Msg = Msg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMode.RestartGame
// (Native, Public, BlueprintCallable)

void AEngine_GameMode::RestartGame()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.RestartGame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.RestartGame");

	AEngine_GameMode_RestartGame_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMode.ReadyToStartMatch
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameMode::ReadyToStartMatch()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToStartMatch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToStartMatch");

	AEngine_GameMode_ReadyToStartMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameMode.ReadyToEndMatch
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameMode::ReadyToEndMatch()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToEndMatch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ReadyToEndMatch");

	AEngine_GameMode_ReadyToEndMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameMode.K2_OnSetMatchState
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FName                   NewState                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_GameMode::K2_OnSetMatchState(const struct FName& NewState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnSetMatchState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_OnSetMatchState");

	AEngine_GameMode_K2_OnSetMatchState_Params params;
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMode.IsMatchInProgress
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameMode::IsMatchInProgress()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.IsMatchInProgress");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.IsMatchInProgress");

	AEngine_GameMode_IsMatchInProgress_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameMode.HasMatchEnded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameMode::HasMatchEnded()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.HasMatchEnded");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.HasMatchEnded");

	AEngine_GameMode_HasMatchEnded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameMode.GetMatchState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName AEngine_GameMode::GetMatchState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.GetMatchState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.GetMatchState");

	AEngine_GameMode_GetMatchState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameMode.EndMatch
// (Native, Public, BlueprintCallable)

void AEngine_GameMode::EndMatch()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.EndMatch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.EndMatch");

	AEngine_GameMode_EndMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameMode.AbortMatch
// (Native, Public, BlueprintCallable)

void AEngine_GameMode::AbortMatch()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameMode.AbortMatch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameMode.AbortMatch");

	AEngine_GameMode_AbortMatch_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameStateBase.OnRep_SpectatorClass
// (Native, Protected)

void AEngine_GameStateBase::OnRep_SpectatorClass()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_SpectatorClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_SpectatorClass");

	AEngine_GameStateBase_OnRep_SpectatorClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameStateBase.OnRep_ReplicatedWorldTimeSeconds
// (Native, Protected)

void AEngine_GameStateBase::OnRep_ReplicatedWorldTimeSeconds()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_ReplicatedWorldTimeSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_ReplicatedWorldTimeSeconds");

	AEngine_GameStateBase_OnRep_ReplicatedWorldTimeSeconds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameStateBase.OnRep_ReplicatedHasBegunPlay
// (Native, Protected)

void AEngine_GameStateBase::OnRep_ReplicatedHasBegunPlay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_ReplicatedHasBegunPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_ReplicatedHasBegunPlay");

	AEngine_GameStateBase_OnRep_ReplicatedHasBegunPlay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameStateBase.OnRep_GameModeClass
// (Native, Protected)

void AEngine_GameStateBase::OnRep_GameModeClass()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_GameModeClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.OnRep_GameModeClass");

	AEngine_GameStateBase_OnRep_GameModeClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameStateBase.HasMatchStarted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameStateBase::HasMatchStarted()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.HasMatchStarted");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.HasMatchStarted");

	AEngine_GameStateBase_HasMatchStarted_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameStateBase.HasBegunPlay
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_GameStateBase::HasBegunPlay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.HasBegunPlay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.HasBegunPlay");

	AEngine_GameStateBase_HasBegunPlay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameStateBase.GetServerWorldTimeSeconds
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_GameStateBase::GetServerWorldTimeSeconds()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetServerWorldTimeSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetServerWorldTimeSeconds");

	AEngine_GameStateBase_GetServerWorldTimeSeconds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameStateBase.GetPlayerStartTime
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Controller*      Controller                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_GameStateBase::GetPlayerStartTime(class AEngine_Controller* Controller)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetPlayerStartTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetPlayerStartTime");

	AEngine_GameStateBase_GetPlayerStartTime_Params params;
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameStateBase.GetPlayerRespawnDelay
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Controller*      Controller                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_GameStateBase::GetPlayerRespawnDelay(class AEngine_Controller* Controller)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetPlayerRespawnDelay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameStateBase.GetPlayerRespawnDelay");

	AEngine_GameStateBase_GetPlayerRespawnDelay_Params params;
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameState.OnRep_MatchState
// (Native, Public)

void AEngine_GameState::OnRep_MatchState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_MatchState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_MatchState");

	AEngine_GameState_OnRep_MatchState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameState.OnRep_ElapsedTime
// (Native, Public)

void AEngine_GameState::OnRep_ElapsedTime()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_ElapsedTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_ElapsedTime");

	AEngine_GameState_OnRep_ElapsedTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLight.OnRep_bEnabled
// (Native, Public)

void AEngine_SkyLight::OnRep_bEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLight.OnRep_bEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLight.OnRep_bEnabled");

	AEngine_SkyLight_OnRep_bEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshComponent.SetStaticMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_StaticMesh*      NewMesh                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_StaticMeshComponent::SetStaticMesh(class UEngine_StaticMesh* NewMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetStaticMesh");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetStaticMesh");

	UEngine_StaticMeshComponent_SetStaticMesh_Params params;
	params.NewMesh = NewMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMeshComponent.SetReverseCulling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReverseCulling                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StaticMeshComponent::SetReverseCulling(bool ReverseCulling)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetReverseCulling");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetReverseCulling");

	UEngine_StaticMeshComponent_SetReverseCulling_Params params;
	params.ReverseCulling = ReverseCulling;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshComponent.SetForcedLodModel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            NewForcedLodModel              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StaticMeshComponent::SetForcedLodModel(int NewForcedLodModel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetForcedLodModel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetForcedLodModel");

	UEngine_StaticMeshComponent_SetForcedLodModel_Params params;
	params.NewForcedLodModel = NewForcedLodModel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshComponent.SetDistanceFieldSelfShadowBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StaticMeshComponent::SetDistanceFieldSelfShadowBias(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetDistanceFieldSelfShadowBias");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetDistanceFieldSelfShadowBias");

	UEngine_StaticMeshComponent_SetDistanceFieldSelfShadowBias_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshComponent.OnRep_StaticMesh
// (Final, Native, Public)
// Parameters:
// class UEngine_StaticMesh*      OldStaticMesh                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StaticMeshComponent::OnRep_StaticMesh(class UEngine_StaticMesh* OldStaticMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.OnRep_StaticMesh");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.OnRep_StaticMesh");

	UEngine_StaticMeshComponent_OnRep_StaticMesh_Params params;
	params.OldStaticMesh = OldStaticMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMeshComponent.GetLocalBounds
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Min                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Max                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_StaticMeshComponent::GetLocalBounds(struct FVector* Min, struct FVector* Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.GetLocalBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.GetLocalBounds");

	UEngine_StaticMeshComponent_GetLocalBounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Min != nullptr)
		*Min = params.Min;
	if (Max != nullptr)
		*Max = params.Max;
}


// Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            InstanceIndex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              NewInstanceTransform           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bWorldSpace                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bMarkRenderStateDirty          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InstancedStaticMeshComponent::UpdateInstanceTransform(int InstanceIndex, const struct FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform");

	UEngine_InstancedStaticMeshComponent_UpdateInstanceTransform_Params params;
	params.InstanceIndex = InstanceIndex;
	params.NewInstanceTransform = NewInstanceTransform;
	params.bWorldSpace = bWorldSpace;
	params.bMarkRenderStateDirty = bMarkRenderStateDirty;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.SetCullDistances
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            StartCullDistance              (Parm, ZeroConstructor, IsPlainOldData)
// int                            EndCullDistance                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InstancedStaticMeshComponent::SetCullDistances(int StartCullDistance, int EndCullDistance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.SetCullDistances");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.SetCullDistances");

	UEngine_InstancedStaticMeshComponent_SetCullDistances_Params params;
	params.StartCullDistance = StartCullDistance;
	params.EndCullDistance = EndCullDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InstancedStaticMeshComponent.RemoveInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            InstanceIndex                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InstancedStaticMeshComponent::RemoveInstance(int InstanceIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.RemoveInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.RemoveInstance");

	UEngine_InstancedStaticMeshComponent_RemoveInstance_Params params;
	params.InstanceIndex = InstanceIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstanceTransform
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            InstanceIndex                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              OutInstanceTransform           (Parm, OutParm, IsPlainOldData)
// bool                           bWorldSpace                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InstancedStaticMeshComponent::GetInstanceTransform(int InstanceIndex, bool bWorldSpace, struct FTransform* OutInstanceTransform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceTransform");

	UEngine_InstancedStaticMeshComponent_GetInstanceTransform_Params params;
	params.InstanceIndex = InstanceIndex;
	params.bWorldSpace = bWorldSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutInstanceTransform != nullptr)
		*OutInstanceTransform = params.OutInstanceTransform;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 Center                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSphereInWorldSpace            (Parm, ZeroConstructor, IsPlainOldData)
// TArray<int>                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<int> UEngine_InstancedStaticMeshComponent::GetInstancesOverlappingSphere(const struct FVector& Center, float Radius, bool bSphereInWorldSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere");

	UEngine_InstancedStaticMeshComponent_GetInstancesOverlappingSphere_Params params;
	params.Center = Center;
	params.Radius = Radius;
	params.bSphereInWorldSpace = bSphereInWorldSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                    Box                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           bBoxInWorldSpace               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<int>                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<int> UEngine_InstancedStaticMeshComponent::GetInstancesOverlappingBox(const struct FBox& Box, bool bBoxInWorldSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox");

	UEngine_InstancedStaticMeshComponent_GetInstancesOverlappingBox_Params params;
	params.Box = Box;
	params.bBoxInWorldSpace = bBoxInWorldSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.GetInstanceCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_InstancedStaticMeshComponent::GetInstanceCount()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceCount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceCount");

	UEngine_InstancedStaticMeshComponent_GetInstanceCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.ClearInstances
// (Native, Public, BlueprintCallable)

void UEngine_InstancedStaticMeshComponent::ClearInstances()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.ClearInstances");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.ClearInstances");

	UEngine_InstancedStaticMeshComponent_ClearInstances_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransforms
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            StartInstanceIndex             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FTransform>      NewInstancesTransforms         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bWorldSpace                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bMarkRenderStateDirty          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InstancedStaticMeshComponent::BatchUpdateInstancesTransforms(int StartInstanceIndex, TArray<struct FTransform> NewInstancesTransforms, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransforms");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransforms");

	UEngine_InstancedStaticMeshComponent_BatchUpdateInstancesTransforms_Params params;
	params.StartInstanceIndex = StartInstanceIndex;
	params.NewInstancesTransforms = NewInstancesTransforms;
	params.bWorldSpace = bWorldSpace;
	params.bMarkRenderStateDirty = bMarkRenderStateDirty;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransform
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            StartInstanceIndex             (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumInstances                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              NewInstancesTransform          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bWorldSpace                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bMarkRenderStateDirty          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTeleport                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InstancedStaticMeshComponent::BatchUpdateInstancesTransform(int StartInstanceIndex, int NumInstances, const struct FTransform& NewInstancesTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.BatchUpdateInstancesTransform");

	UEngine_InstancedStaticMeshComponent_BatchUpdateInstancesTransform_Params params;
	params.StartInstanceIndex = StartInstanceIndex;
	params.NumInstances = NumInstances;
	params.NewInstancesTransform = NewInstancesTransform;
	params.bWorldSpace = bWorldSpace;
	params.bMarkRenderStateDirty = bMarkRenderStateDirty;
	params.bTeleport = bTeleport;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              WorldTransform                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_InstancedStaticMeshComponent::AddInstanceWorldSpace(const struct FTransform& WorldTransform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace");

	UEngine_InstancedStaticMeshComponent_AddInstanceWorldSpace_Params params;
	params.WorldTransform = WorldTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InstancedStaticMeshComponent.AddInstance
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform              InstanceTransform              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_InstancedStaticMeshComponent::AddInstance(const struct FTransform& InstanceTransform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstance");

	UEngine_InstancedStaticMeshComponent_AddInstance_Params params;
	params.InstanceTransform = InstanceTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    InstancesToRemove              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_HierarchicalInstancedStaticMeshComponent::RemoveInstances(TArray<int> InstancesToRemove)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances");

	UEngine_HierarchicalInstancedStaticMeshComponent_RemoveInstances_Params params;
	params.InstancesToRemove = InstancesToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.SetForceMipLevelsToBeResident
// (RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                           OverrideForceMiplevelsToBeResident (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForceMiplevelsToBeResidentValue (Parm, ZeroConstructor, IsPlainOldData)
// float                          ForceDuration                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            CinematicTextureGroups         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFastResponse                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInterface::SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int CinematicTextureGroups, bool bFastResponse)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.SetForceMipLevelsToBeResident");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.SetForceMipLevelsToBeResident");

	UEngine_MaterialInterface_SetForceMipLevelsToBeResident_Params params;
	params.OverrideForceMiplevelsToBeResident = OverrideForceMiplevelsToBeResident;
	params.bForceMiplevelsToBeResidentValue = bForceMiplevelsToBeResidentValue;
	params.ForceDuration = ForceDuration;
	params.CinematicTextureGroups = CinematicTextureGroups;
	params.bFastResponse = bFastResponse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInterface.GetPhysicalMaterial
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_PhysicalMaterial* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_PhysicalMaterial* UEngine_MaterialInterface::GetPhysicalMaterial()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetPhysicalMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetPhysicalMaterial");

	UEngine_MaterialInterface_GetPhysicalMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInterface.GetBaseMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Material*        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Material* UEngine_MaterialInterface::GetBaseMaterial()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetBaseMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetBaseMaterial");

	UEngine_MaterialInterface_GetBaseMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.K2_GetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_MaterialInstanceConstant::K2_GetVectorParameterValue(const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetVectorParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetVectorParameterValue");

	UEngine_MaterialInstanceConstant_K2_GetVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.K2_GetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Texture* UEngine_MaterialInstanceConstant::K2_GetTextureParameterValue(const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetTextureParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetTextureParameterValue");

	UEngine_MaterialInstanceConstant_K2_GetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceConstant.K2_GetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_MaterialInstanceConstant::K2_GetScalarParameterValue(const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetScalarParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceConstant.K2_GetScalarParameterValue");

	UEngine_MaterialInstanceConstant_K2_GetScalarParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AmbientSound.Stop
// (Final, Native, Public, BlueprintCallable)

void AEngine_AmbientSound::Stop()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Stop");

	AEngine_AmbientSound_Stop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSound.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_AmbientSound::Play(float StartTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Play");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Play");

	AEngine_AmbientSound_Play_Params params;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSound.FadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          FadeOutDuration                (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeVolumeLevel                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_AmbientSound::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeOut");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeOut");

	AEngine_AmbientSound_FadeOut_Params params;
	params.FadeOutDuration = FadeOutDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSound.FadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          FadeInDuration                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          FadeVolumeLevel                (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_AmbientSound::FadeIn(float FadeInDuration, float FadeVolumeLevel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeIn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeIn");

	AEngine_AmbientSound_FadeIn_Params params;
	params.FadeInDuration = FadeInDuration;
	params.FadeVolumeLevel = FadeVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AmbientSound.AdjustVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          AdjustVolumeDuration           (Parm, ZeroConstructor, IsPlainOldData)
// float                          AdjustVolumeLevel              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_AmbientSound::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.AdjustVolume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.AdjustVolume");

	AEngine_AmbientSound_AdjustVolume_Params params;
	params.AdjustVolumeDuration = AdjustVolumeDuration;
	params.AdjustVolumeLevel = AdjustVolumeLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSequenceBase.GetPlayLength
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimSequenceBase::GetPlayLength()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSequenceBase.GetPlayLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSequenceBase.GetPlayLength");

	UEngine_AnimSequenceBase_GetPlayLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimMontage.GetDefaultBlendOutTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimMontage::GetDefaultBlendOutTime()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetDefaultBlendOutTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimMontage.GetDefaultBlendOutTime");

	UEngine_AnimMontage_GetDefaultBlendOutTime_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimNotifyState_Trail.OverridePSTemplate
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UEngine_SkeletalMeshComponent* MeshComp                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// class UEngine_AnimSequenceBase* Animation                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_ParticleSystem*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_ParticleSystem* UEngine_AnimNotifyState_Trail::OverridePSTemplate(class UEngine_SkeletalMeshComponent* MeshComp, class UEngine_AnimSequenceBase* Animation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState_Trail.OverridePSTemplate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState_Trail.OverridePSTemplate");

	UEngine_AnimNotifyState_Trail_OverridePSTemplate_Params params;
	params.MeshComp = MeshComp;
	params.Animation = Animation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimSingleNodeInstance.StopAnim
// (Final, Native, Public, BlueprintCallable)

void UEngine_AnimSingleNodeInstance::StopAnim()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.StopAnim");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.StopAnim");

	UEngine_AnimSingleNodeInstance_StopAnim_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetReverse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInReverse                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetReverse(bool bInReverse)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetReverse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetReverse");

	UEngine_AnimSingleNodeInstance_SetReverse_Params params;
	params.bInReverse = bInReverse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   PoseName                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRemoveIfZero                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetPreviewCurveOverride(const struct FName& PoseName, float Value, bool bRemoveIfZero)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride");

	UEngine_AnimSingleNodeInstance_SetPreviewCurveOverride_Params params;
	params.PoseName = PoseName;
	params.Value = Value;
	params.bRemoveIfZero = bRemoveIfZero;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InPosition                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPreviousTime                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFireNotifies                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime");

	UEngine_AnimSingleNodeInstance_SetPositionWithPreviousTime_Params params;
	params.InPosition = InPosition;
	params.InPreviousTime = InPreviousTime;
	params.bFireNotifies = bFireNotifies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InPosition                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFireNotifies                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetPosition(float InPosition, bool bFireNotifies)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPosition");

	UEngine_AnimSingleNodeInstance_SetPosition_Params params;
	params.InPosition = InPosition;
	params.bFireNotifies = bFireNotifies;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetPlayRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InPlayRate                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetPlayRate(float InPlayRate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlayRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlayRate");

	UEngine_AnimSingleNodeInstance_SetPlayRate_Params params;
	params.InPlayRate = InPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bIsPlaying                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetPlaying(bool bIsPlaying)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlaying");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlaying");

	UEngine_AnimSingleNodeInstance_SetPlaying_Params params;
	params.bIsPlaying = bIsPlaying;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetLooping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bIsLooping                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetLooping(bool bIsLooping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetLooping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetLooping");

	UEngine_AnimSingleNodeInstance_SetLooping_Params params;
	params.bIsLooping = bIsLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InBlendInput                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetBlendSpaceInput(const struct FVector& InBlendInput)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput");

	UEngine_AnimSingleNodeInstance_SetBlendSpaceInput_Params params;
	params.InBlendInput = InBlendInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.SetAnimationAsset
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_AnimationAsset*  NewAsset                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIsLooping                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPlayRate                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::SetAnimationAsset(class UEngine_AnimationAsset* NewAsset, bool bIsLooping, float InPlayRate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetAnimationAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetAnimationAsset");

	UEngine_AnimSingleNodeInstance_SetAnimationAsset_Params params;
	params.NewAsset = NewAsset;
	params.bIsLooping = bIsLooping;
	params.InPlayRate = InPlayRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.PlayAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bIsLooping                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPlayRate                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          InStartPosition                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AnimSingleNodeInstance::PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.PlayAnim");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.PlayAnim");

	UEngine_AnimSingleNodeInstance_PlayAnim_Params params;
	params.bIsLooping = bIsLooping;
	params.InPlayRate = InPlayRate;
	params.InStartPosition = InStartPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AnimSingleNodeInstance.GetLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_AnimSingleNodeInstance::GetLength()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetLength");

	UEngine_AnimSingleNodeInstance_GetLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AnimSingleNodeInstance.GetAnimationAsset
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_AnimationAsset*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AnimationAsset* UEngine_AnimSingleNodeInstance::GetAnimationAsset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetAnimationAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetAnimationAsset");

	UEngine_AnimSingleNodeInstance_GetAnimationAsset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ArrowComponent.SetArrowColor
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewColor                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ArrowComponent::SetArrowColor(const struct FLinearColor& NewColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ArrowComponent.SetArrowColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ArrowComponent.SetArrowColor");

	UEngine_ArrowComponent_SetArrowColor_Params params;
	params.NewColor = NewColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AsyncActionHandleSaveGame.AsyncSaveGameToSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SaveGame*        SaveGameObject                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 SlotName                       (Parm, ZeroConstructor)
// int                            UserIndex                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AsyncActionHandleSaveGame* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionHandleSaveGame* UEngine_AsyncActionHandleSaveGame::STATIC_AsyncSaveGameToSlot(class UObject* WorldContextObject, class UEngine_SaveGame* SaveGameObject, const struct FString& SlotName, int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionHandleSaveGame.AsyncSaveGameToSlot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionHandleSaveGame.AsyncSaveGameToSlot");

	UEngine_AsyncActionHandleSaveGame_AsyncSaveGameToSlot_Params params;
	params.WorldContextObject = WorldContextObject;
	params.SaveGameObject = SaveGameObject;
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AsyncActionHandleSaveGame.AsyncLoadGameFromSlot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 SlotName                       (Parm, ZeroConstructor)
// int                            UserIndex                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_AsyncActionHandleSaveGame* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionHandleSaveGame* UEngine_AsyncActionHandleSaveGame::STATIC_AsyncLoadGameFromSlot(class UObject* WorldContextObject, const struct FString& SlotName, int UserIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionHandleSaveGame.AsyncLoadGameFromSlot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionHandleSaveGame.AsyncLoadGameFromSlot");

	UEngine_AsyncActionHandleSaveGame_AsyncLoadGameFromSlot_Params params;
	params.WorldContextObject = WorldContextObject;
	params.SlotName = SlotName;
	params.UserIndex = UserIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AsyncActionLoadPrimaryAssetClass.AsyncLoadPrimaryAssetClass
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FPrimaryAssetId         PrimaryAsset                   (Parm, ZeroConstructor)
// TArray<struct FName>           LoadBundles                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UEngine_AsyncActionLoadPrimaryAssetClass* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionLoadPrimaryAssetClass* UEngine_AsyncActionLoadPrimaryAssetClass::STATIC_AsyncLoadPrimaryAssetClass(class UObject* WorldContextObject, const struct FPrimaryAssetId& PrimaryAsset, TArray<struct FName> LoadBundles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetClass.AsyncLoadPrimaryAssetClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetClass.AsyncLoadPrimaryAssetClass");

	UEngine_AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PrimaryAsset = PrimaryAsset;
	params.LoadBundles = LoadBundles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AsyncActionLoadPrimaryAssetList.AsyncLoadPrimaryAssetList
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FPrimaryAssetId> PrimaryAssetList               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FName>           LoadBundles                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UEngine_AsyncActionLoadPrimaryAssetList* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionLoadPrimaryAssetList* UEngine_AsyncActionLoadPrimaryAssetList::STATIC_AsyncLoadPrimaryAssetList(class UObject* WorldContextObject, TArray<struct FPrimaryAssetId> PrimaryAssetList, TArray<struct FName> LoadBundles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetList.AsyncLoadPrimaryAssetList");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetList.AsyncLoadPrimaryAssetList");

	UEngine_AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PrimaryAssetList = PrimaryAssetList;
	params.LoadBundles = LoadBundles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AsyncActionLoadPrimaryAssetClassList.AsyncLoadPrimaryAssetClassList
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FPrimaryAssetId> PrimaryAssetList               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FName>           LoadBundles                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UEngine_AsyncActionLoadPrimaryAssetClassList* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionLoadPrimaryAssetClassList* UEngine_AsyncActionLoadPrimaryAssetClassList::STATIC_AsyncLoadPrimaryAssetClassList(class UObject* WorldContextObject, TArray<struct FPrimaryAssetId> PrimaryAssetList, TArray<struct FName> LoadBundles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetClassList.AsyncLoadPrimaryAssetClassList");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAssetClassList.AsyncLoadPrimaryAssetClassList");

	UEngine_AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PrimaryAssetList = PrimaryAssetList;
	params.LoadBundles = LoadBundles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForPrimaryAssetList
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FPrimaryAssetId> PrimaryAssetList               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FName>           AddBundles                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FName>           RemoveBundles                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UEngine_AsyncActionChangePrimaryAssetBundles* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionChangePrimaryAssetBundles* UEngine_AsyncActionChangePrimaryAssetBundles::STATIC_AsyncChangeBundleStateForPrimaryAssetList(class UObject* WorldContextObject, TArray<struct FPrimaryAssetId> PrimaryAssetList, TArray<struct FName> AddBundles, TArray<struct FName> RemoveBundles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForPrimaryAssetList");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForPrimaryAssetList");

	UEngine_AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PrimaryAssetList = PrimaryAssetList;
	params.AddBundles = AddBundles;
	params.RemoveBundles = RemoveBundles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForMatchingPrimaryAssets
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FName>           NewBundles                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FName>           OldBundles                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UEngine_AsyncActionChangePrimaryAssetBundles* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionChangePrimaryAssetBundles* UEngine_AsyncActionChangePrimaryAssetBundles::STATIC_AsyncChangeBundleStateForMatchingPrimaryAssets(class UObject* WorldContextObject, TArray<struct FName> NewBundles, TArray<struct FName> OldBundles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForMatchingPrimaryAssets");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForMatchingPrimaryAssets");

	UEngine_AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets_Params params;
	params.WorldContextObject = WorldContextObject;
	params.NewBundles = NewBundles;
	params.OldBundles = OldBundles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AtmosphericFogComponent.StartPrecompute
// (Final, Native, Public, BlueprintCallable)

void UEngine_AtmosphericFogComponent::StartPrecompute()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.StartPrecompute");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.StartPrecompute");

	UEngine_AtmosphericFogComponent_StartPrecompute_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetSunMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewSunMultiplier               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetSunMultiplier(float NewSunMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetSunMultiplier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetSunMultiplier");

	UEngine_AtmosphericFogComponent_SetSunMultiplier_Params params;
	params.NewSunMultiplier = NewSunMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetStartDistance
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewStartDistance               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetStartDistance(float NewStartDistance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetStartDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetStartDistance");

	UEngine_AtmosphericFogComponent_SetStartDistance_Params params;
	params.NewStartDistance = NewStartDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetPrecomputeParams
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          DensityHeight                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaxScatteringOrder             (Parm, ZeroConstructor, IsPlainOldData)
// int                            InscatterAltitudeSampleNum     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetPrecomputeParams(float DensityHeight, int MaxScatteringOrder, int InscatterAltitudeSampleNum)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetPrecomputeParams");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetPrecomputeParams");

	UEngine_AtmosphericFogComponent_SetPrecomputeParams_Params params;
	params.DensityHeight = DensityHeight;
	params.MaxScatteringOrder = MaxScatteringOrder;
	params.InscatterAltitudeSampleNum = InscatterAltitudeSampleNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetFogMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewFogMultiplier               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetFogMultiplier(float NewFogMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetFogMultiplier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetFogMultiplier");

	UEngine_AtmosphericFogComponent_SetFogMultiplier_Params params;
	params.NewFogMultiplier = NewFogMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetDistanceScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewDistanceScale               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetDistanceScale(float NewDistanceScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceScale");

	UEngine_AtmosphericFogComponent_SetDistanceScale_Params params;
	params.NewDistanceScale = NewDistanceScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetDistanceOffset
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewDistanceOffset              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetDistanceOffset(float NewDistanceOffset)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceOffset");

	UEngine_AtmosphericFogComponent_SetDistanceOffset_Params params;
	params.NewDistanceOffset = NewDistanceOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetDensityOffset
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewDensityOffset               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetDensityOffset(float NewDensityOffset)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityOffset");

	UEngine_AtmosphericFogComponent_SetDensityOffset_Params params;
	params.NewDensityOffset = NewDensityOffset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetDensityMultiplier
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewDensityMultiplier           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetDensityMultiplier(float NewDensityMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityMultiplier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityMultiplier");

	UEngine_AtmosphericFogComponent_SetDensityMultiplier_Params params;
	params.NewDensityMultiplier = NewDensityMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetDefaultLightColor
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewLightColor                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetDefaultLightColor(const struct FLinearColor& NewLightColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultLightColor");

	UEngine_AtmosphericFogComponent_SetDefaultLightColor_Params params;
	params.NewLightColor = NewLightColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetDefaultBrightness
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewBrightness                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetDefaultBrightness(float NewBrightness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultBrightness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultBrightness");

	UEngine_AtmosphericFogComponent_SetDefaultBrightness_Params params;
	params.NewBrightness = NewBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.SetAltitudeScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewAltitudeScale               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::SetAltitudeScale(float NewAltitudeScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetAltitudeScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetAltitudeScale");

	UEngine_AtmosphericFogComponent_SetAltitudeScale_Params params;
	params.NewAltitudeScale = NewAltitudeScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.DisableSunDisk
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                           NewSunDisk                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::DisableSunDisk(bool NewSunDisk)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableSunDisk");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableSunDisk");

	UEngine_AtmosphericFogComponent_DisableSunDisk_Params params;
	params.NewSunDisk = NewSunDisk;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AtmosphericFogComponent.DisableGroundScattering
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                           NewGroundScattering            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_AtmosphericFogComponent::DisableGroundScattering(bool NewGroundScattering)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableGroundScattering");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableGroundScattering");

	UEngine_AtmosphericFogComponent_DisableGroundScattering_Params params;
	params.NewGroundScattering = NewGroundScattering;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FPrimaryAssetId         PrimaryAsset                   (Parm, ZeroConstructor)
// TArray<struct FName>           LoadBundles                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UEngine_AsyncActionLoadPrimaryAsset* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_AsyncActionLoadPrimaryAsset* UEngine_AsyncActionLoadPrimaryAsset::STATIC_AsyncLoadPrimaryAsset(class UObject* WorldContextObject, const struct FPrimaryAssetId& PrimaryAsset, TArray<struct FName> LoadBundles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset");

	UEngine_AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PrimaryAsset = PrimaryAsset;
	params.LoadBundles = LoadBundles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AvoidanceManager.RegisterMovementComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MovementComponent* MovementComp                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// float                          AvoidanceWeight                (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_AvoidanceManager::RegisterMovementComponent(class UEngine_MovementComponent* MovementComp, float AvoidanceWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.RegisterMovementComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.RegisterMovementComponent");

	UEngine_AvoidanceManager_RegisterMovementComponent_Params params;
	params.MovementComp = MovementComp;
	params.AvoidanceWeight = AvoidanceWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AvoidanceManager.GetObjectCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_AvoidanceManager::GetObjectCount()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetObjectCount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetObjectCount");

	UEngine_AvoidanceManager_GetObjectCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AvoidanceManager.GetNewAvoidanceUID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_AvoidanceManager::GetNewAvoidanceUID()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetNewAvoidanceUID");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetNewAvoidanceUID");

	UEngine_AvoidanceManager_GetNewAvoidanceUID_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_MovementComponent* MovementComp                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_AvoidanceManager::GetAvoidanceVelocityForComponent(class UEngine_MovementComponent* MovementComp)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent");

	UEngine_AvoidanceManager_GetAvoidanceVelocityForComponent_Params params;
	params.MovementComp = MovementComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BillboardComponent.SetUV
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            NewU                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            NewUL                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            NewV                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            NewVL                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_BillboardComponent::SetUV(int NewU, int NewUL, int NewV, int NewVL)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetUV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetUV");

	UEngine_BillboardComponent_SetUV_Params params;
	params.NewU = NewU;
	params.NewUL = NewUL;
	params.NewV = NewV;
	params.NewVL = NewVL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BillboardComponent.SetSpriteAndUV
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Texture2D*       NewSprite                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            NewU                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            NewUL                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            NewV                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            NewVL                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_BillboardComponent::SetSpriteAndUV(class UEngine_Texture2D* NewSprite, int NewU, int NewUL, int NewV, int NewVL)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSpriteAndUV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSpriteAndUV");

	UEngine_BillboardComponent_SetSpriteAndUV_Params params;
	params.NewSprite = NewSprite;
	params.NewU = NewU;
	params.NewUL = NewUL;
	params.NewV = NewV;
	params.NewVL = NewVL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BillboardComponent.SetSprite
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Texture2D*       NewSprite                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_BillboardComponent::SetSprite(class UEngine_Texture2D* NewSprite)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSprite");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSprite");

	UEngine_BillboardComponent_SetSprite_Params params;
	params.NewSprite = NewSprite;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintMapLibrary.SetMapPropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// TMap<int, int>                 Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_BlueprintMapLibrary::STATIC_SetMapPropertyByName(class UObject* Object, const struct FName& PropertyName, TMap<int, int> Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.SetMapPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.SetMapPropertyByName");

	UEngine_BlueprintMapLibrary_SetMapPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintMapLibrary.Map_Values
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<int>                    Values                         (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintMapLibrary::STATIC_Map_Values(TMap<int, int> TargetMap, TArray<int>* Values)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Values");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Values");

	UEngine_BlueprintMapLibrary_Map_Values_Params params;
	params.TargetMap = TargetMap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Values != nullptr)
		*Values = params.Values;
}


// Function Engine.BlueprintMapLibrary.Map_Remove
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintMapLibrary::STATIC_Map_Remove(TMap<int, int> TargetMap, int Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Remove");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Remove");

	UEngine_BlueprintMapLibrary_Map_Remove_Params params;
	params.TargetMap = TargetMap;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Length
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_BlueprintMapLibrary::STATIC_Map_Length(TMap<int, int> TargetMap)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Length");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Length");

	UEngine_BlueprintMapLibrary_Map_Length_Params params;
	params.TargetMap = TargetMap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Keys
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<int>                    Keys                           (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintMapLibrary::STATIC_Map_Keys(TMap<int, int> TargetMap, TArray<int>* Keys)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Keys");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Keys");

	UEngine_BlueprintMapLibrary_Map_Keys_Params params;
	params.TargetMap = TargetMap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Keys != nullptr)
		*Keys = params.Keys;
}


// Function Engine.BlueprintMapLibrary.Map_Find
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            Value                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintMapLibrary::STATIC_Map_Find(TMap<int, int> TargetMap, int Key, int* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Find");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Find");

	UEngine_BlueprintMapLibrary_Map_Find_Params params;
	params.TargetMap = TargetMap;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Value != nullptr)
		*Value = params.Value;

	return params.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Contains
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintMapLibrary::STATIC_Map_Contains(TMap<int, int> TargetMap, int Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Contains");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Contains");

	UEngine_BlueprintMapLibrary_Map_Contains_Params params;
	params.TargetMap = TargetMap;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintMapLibrary.Map_Clear
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_BlueprintMapLibrary::STATIC_Map_Clear(TMap<int, int> TargetMap)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Clear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Clear");

	UEngine_BlueprintMapLibrary_Map_Clear_Params params;
	params.TargetMap = TargetMap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintMapLibrary.Map_Add
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TMap<int, int>                 TargetMap                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Key                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_BlueprintMapLibrary::STATIC_Map_Add(TMap<int, int> TargetMap, int Key, int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Add");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintMapLibrary.Map_Add");

	UEngine_BlueprintMapLibrary_Map_Add_Params params;
	params.TargetMap = TargetMap;
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintPathsLibrary.VideoCaptureDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_VideoCaptureDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.VideoCaptureDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.VideoCaptureDir");

	UEngine_BlueprintPathsLibrary_VideoCaptureDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ValidatePath
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           bDidSucceed                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FText                   OutReason                      (Parm, OutParm)

void UEngine_BlueprintPathsLibrary::STATIC_ValidatePath(const struct FString& InPath, bool* bDidSucceed, struct FText* OutReason)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ValidatePath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ValidatePath");

	UEngine_BlueprintPathsLibrary_ValidatePath_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bDidSucceed != nullptr)
		*bDidSucceed = params.bDidSucceed;
	if (OutReason != nullptr)
		*OutReason = params.OutReason;
}


// Function Engine.BlueprintPathsLibrary.Split
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 PathPart                       (Parm, OutParm, ZeroConstructor)
// struct FString                 FilenamePart                   (Parm, OutParm, ZeroConstructor)
// struct FString                 ExtensionPart                  (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintPathsLibrary::STATIC_Split(const struct FString& InPath, struct FString* PathPart, struct FString* FilenamePart, struct FString* ExtensionPart)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.Split");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.Split");

	UEngine_BlueprintPathsLibrary_Split_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PathPart != nullptr)
		*PathPart = params.PathPart;
	if (FilenamePart != nullptr)
		*FilenamePart = params.FilenamePart;
	if (ExtensionPart != nullptr)
		*ExtensionPart = params.ExtensionPart;
}


// Function Engine.BlueprintPathsLibrary.SourceConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_SourceConfigDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SourceConfigDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SourceConfigDir");

	UEngine_BlueprintPathsLibrary_SourceConfigDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ShouldSaveToUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_ShouldSaveToUserDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ShouldSaveToUserDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ShouldSaveToUserDir");

	UEngine_BlueprintPathsLibrary_ShouldSaveToUserDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ShaderWorkingDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ShaderWorkingDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ShaderWorkingDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ShaderWorkingDir");

	UEngine_BlueprintPathsLibrary_ShaderWorkingDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.SetProjectFilePath
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 NewGameProjectFilePath         (Parm, ZeroConstructor)

void UEngine_BlueprintPathsLibrary::STATIC_SetProjectFilePath(const struct FString& NewGameProjectFilePath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SetProjectFilePath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SetProjectFilePath");

	UEngine_BlueprintPathsLibrary_SetProjectFilePath_Params params;
	params.NewGameProjectFilePath = NewGameProjectFilePath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintPathsLibrary.SetExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 InNewExtension                 (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_SetExtension(const struct FString& InPath, const struct FString& InNewExtension)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SetExtension");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SetExtension");

	UEngine_BlueprintPathsLibrary_SetExtension_Params params;
	params.InPath = InPath;
	params.InNewExtension = InNewExtension;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ScreenShotDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ScreenShotDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ScreenShotDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ScreenShotDir");

	UEngine_BlueprintPathsLibrary_ScreenShotDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.SandboxesDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_SandboxesDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SandboxesDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.SandboxesDir");

	UEngine_BlueprintPathsLibrary_SandboxesDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.RootDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_RootDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.RootDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.RootDir");

	UEngine_BlueprintPathsLibrary_RootDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.RemoveDuplicateSlashes
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 OutPath                        (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintPathsLibrary::STATIC_RemoveDuplicateSlashes(const struct FString& InPath, struct FString* OutPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.RemoveDuplicateSlashes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.RemoveDuplicateSlashes");

	UEngine_BlueprintPathsLibrary_RemoveDuplicateSlashes_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPath != nullptr)
		*OutPath = params.OutPath;
}


// Function Engine.BlueprintPathsLibrary.ProjectUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectUserDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectUserDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectUserDir");

	UEngine_BlueprintPathsLibrary_ProjectUserDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectSavedDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectSavedDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectSavedDir");

	UEngine_BlueprintPathsLibrary_ProjectSavedDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectPluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectPluginsDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectPluginsDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectPluginsDir");

	UEngine_BlueprintPathsLibrary_ProjectPluginsDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectPersistentDownloadDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectPersistentDownloadDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectPersistentDownloadDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectPersistentDownloadDir");

	UEngine_BlueprintPathsLibrary_ProjectPersistentDownloadDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectModsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectModsDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectModsDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectModsDir");

	UEngine_BlueprintPathsLibrary_ProjectModsDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectLogDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectLogDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectLogDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectLogDir");

	UEngine_BlueprintPathsLibrary_ProjectLogDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectIntermediateDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectIntermediateDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectIntermediateDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectIntermediateDir");

	UEngine_BlueprintPathsLibrary_ProjectIntermediateDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectDir");

	UEngine_BlueprintPathsLibrary_ProjectDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectContentDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectContentDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectContentDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectContentDir");

	UEngine_BlueprintPathsLibrary_ProjectContentDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProjectConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProjectConfigDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectConfigDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProjectConfigDir");

	UEngine_BlueprintPathsLibrary_ProjectConfigDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ProfilingDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ProfilingDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProfilingDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ProfilingDir");

	UEngine_BlueprintPathsLibrary_ProfilingDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.NormalizeFilename
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 OutPath                        (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintPathsLibrary::STATIC_NormalizeFilename(const struct FString& InPath, struct FString* OutPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.NormalizeFilename");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.NormalizeFilename");

	UEngine_BlueprintPathsLibrary_NormalizeFilename_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPath != nullptr)
		*OutPath = params.OutPath;
}


// Function Engine.BlueprintPathsLibrary.NormalizeDirectoryName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 OutPath                        (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintPathsLibrary::STATIC_NormalizeDirectoryName(const struct FString& InPath, struct FString* OutPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.NormalizeDirectoryName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.NormalizeDirectoryName");

	UEngine_BlueprintPathsLibrary_NormalizeDirectoryName_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPath != nullptr)
		*OutPath = params.OutPath;
}


// Function Engine.BlueprintPathsLibrary.MakeValidFileName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// struct FString                 InReplacementChar              (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_MakeValidFileName(const struct FString& inString, const struct FString& InReplacementChar)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakeValidFileName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakeValidFileName");

	UEngine_BlueprintPathsLibrary_MakeValidFileName_Params params;
	params.inString = inString;
	params.InReplacementChar = InReplacementChar;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.MakeStandardFilename
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 OutPath                        (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintPathsLibrary::STATIC_MakeStandardFilename(const struct FString& InPath, struct FString* OutPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakeStandardFilename");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakeStandardFilename");

	UEngine_BlueprintPathsLibrary_MakeStandardFilename_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPath != nullptr)
		*OutPath = params.OutPath;
}


// Function Engine.BlueprintPathsLibrary.MakePlatformFilename
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 OutPath                        (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintPathsLibrary::STATIC_MakePlatformFilename(const struct FString& InPath, struct FString* OutPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakePlatformFilename");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakePlatformFilename");

	UEngine_BlueprintPathsLibrary_MakePlatformFilename_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPath != nullptr)
		*OutPath = params.OutPath;
}


// Function Engine.BlueprintPathsLibrary.MakePathRelativeTo
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 InRelativeTo                   (Parm, ZeroConstructor)
// struct FString                 OutPath                        (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_MakePathRelativeTo(const struct FString& InPath, const struct FString& InRelativeTo, struct FString* OutPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakePathRelativeTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.MakePathRelativeTo");

	UEngine_BlueprintPathsLibrary_MakePathRelativeTo_Params params;
	params.InPath = InPath;
	params.InRelativeTo = InRelativeTo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPath != nullptr)
		*OutPath = params.OutPath;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.LaunchDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_LaunchDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.LaunchDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.LaunchDir");

	UEngine_BlueprintPathsLibrary_LaunchDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsSamePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 PathA                          (Parm, ZeroConstructor)
// struct FString                 PathB                          (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_IsSamePath(const struct FString& PathA, const struct FString& PathB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsSamePath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsSamePath");

	UEngine_BlueprintPathsLibrary_IsSamePath_Params params;
	params.PathA = PathA;
	params.PathB = PathB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsRestrictedPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_IsRestrictedPath(const struct FString& InPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsRestrictedPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsRestrictedPath");

	UEngine_BlueprintPathsLibrary_IsRestrictedPath_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsRelative
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_IsRelative(const struct FString& InPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsRelative");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsRelative");

	UEngine_BlueprintPathsLibrary_IsRelative_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsProjectFilePathSet
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_IsProjectFilePathSet()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsProjectFilePathSet");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsProjectFilePathSet");

	UEngine_BlueprintPathsLibrary_IsProjectFilePathSet_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.IsDrive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_IsDrive(const struct FString& InPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsDrive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.IsDrive");

	UEngine_BlueprintPathsLibrary_IsDrive_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.HasProjectPersistentDownloadDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_HasProjectPersistentDownloadDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.HasProjectPersistentDownloadDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.HasProjectPersistentDownloadDir");

	UEngine_BlueprintPathsLibrary_HasProjectPersistentDownloadDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetToolTipLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm)

TArray<struct FString> UEngine_BlueprintPathsLibrary::STATIC_GetToolTipLocalizationPaths()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetToolTipLocalizationPaths");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetToolTipLocalizationPaths");

	UEngine_BlueprintPathsLibrary_GetToolTipLocalizationPaths_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetRestrictedFolderNames
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm)

TArray<struct FString> UEngine_BlueprintPathsLibrary::STATIC_GetRestrictedFolderNames()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetRestrictedFolderNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetRestrictedFolderNames");

	UEngine_BlueprintPathsLibrary_GetRestrictedFolderNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetRelativePathToRoot
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GetRelativePathToRoot()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetRelativePathToRoot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetRelativePathToRoot");

	UEngine_BlueprintPathsLibrary_GetRelativePathToRoot_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetPropertyNameLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm)

TArray<struct FString> UEngine_BlueprintPathsLibrary::STATIC_GetPropertyNameLocalizationPaths()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetPropertyNameLocalizationPaths");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetPropertyNameLocalizationPaths");

	UEngine_BlueprintPathsLibrary_GetPropertyNameLocalizationPaths_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetProjectFilePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GetProjectFilePath()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetProjectFilePath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetProjectFilePath");

	UEngine_BlueprintPathsLibrary_GetProjectFilePath_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GetPath(const struct FString& InPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetPath");

	UEngine_BlueprintPathsLibrary_GetPath_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetInvalidFileSystemChars
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GetInvalidFileSystemChars()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetInvalidFileSystemChars");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetInvalidFileSystemChars");

	UEngine_BlueprintPathsLibrary_GetInvalidFileSystemChars_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetGameLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm)

TArray<struct FString> UEngine_BlueprintPathsLibrary::STATIC_GetGameLocalizationPaths()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetGameLocalizationPaths");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetGameLocalizationPaths");

	UEngine_BlueprintPathsLibrary_GetGameLocalizationPaths_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           bIncludeDot                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GetExtension(const struct FString& InPath, bool bIncludeDot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetExtension");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetExtension");

	UEngine_BlueprintPathsLibrary_GetExtension_Params params;
	params.InPath = InPath;
	params.bIncludeDot = bIncludeDot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetEngineLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm)

TArray<struct FString> UEngine_BlueprintPathsLibrary::STATIC_GetEngineLocalizationPaths()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetEngineLocalizationPaths");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetEngineLocalizationPaths");

	UEngine_BlueprintPathsLibrary_GetEngineLocalizationPaths_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetEditorLocalizationPaths
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         ReturnValue                    (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm)

TArray<struct FString> UEngine_BlueprintPathsLibrary::STATIC_GetEditorLocalizationPaths()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetEditorLocalizationPaths");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetEditorLocalizationPaths");

	UEngine_BlueprintPathsLibrary_GetEditorLocalizationPaths_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetCleanFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GetCleanFilename(const struct FString& InPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetCleanFilename");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetCleanFilename");

	UEngine_BlueprintPathsLibrary_GetCleanFilename_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GetBaseFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           bRemovePath                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GetBaseFilename(const struct FString& InPath, bool bRemovePath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetBaseFilename");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GetBaseFilename");

	UEngine_BlueprintPathsLibrary_GetBaseFilename_Params params;
	params.InPath = InPath;
	params.bRemovePath = bRemovePath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GeneratedConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GeneratedConfigDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GeneratedConfigDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GeneratedConfigDir");

	UEngine_BlueprintPathsLibrary_GeneratedConfigDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameUserDeveloperDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GameUserDeveloperDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameUserDeveloperDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameUserDeveloperDir");

	UEngine_BlueprintPathsLibrary_GameUserDeveloperDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameSourceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GameSourceDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameSourceDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameSourceDir");

	UEngine_BlueprintPathsLibrary_GameSourceDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameDevelopersDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GameDevelopersDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameDevelopersDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameDevelopersDir");

	UEngine_BlueprintPathsLibrary_GameDevelopersDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.GameAgnosticSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_GameAgnosticSavedDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameAgnosticSavedDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.GameAgnosticSavedDir");

	UEngine_BlueprintPathsLibrary_GameAgnosticSavedDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.FileExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_FileExists(const struct FString& InPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.FileExists");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.FileExists");

	UEngine_BlueprintPathsLibrary_FileExists_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.FeaturePackDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_FeaturePackDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.FeaturePackDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.FeaturePackDir");

	UEngine_BlueprintPathsLibrary_FeaturePackDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnterprisePluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EnterprisePluginsDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterprisePluginsDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterprisePluginsDir");

	UEngine_BlueprintPathsLibrary_EnterprisePluginsDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnterpriseFeaturePackDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EnterpriseFeaturePackDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterpriseFeaturePackDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterpriseFeaturePackDir");

	UEngine_BlueprintPathsLibrary_EnterpriseFeaturePackDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnterpriseDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EnterpriseDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterpriseDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnterpriseDir");

	UEngine_BlueprintPathsLibrary_EnterpriseDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineVersionAgnosticUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineVersionAgnosticUserDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineVersionAgnosticUserDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineVersionAgnosticUserDir");

	UEngine_BlueprintPathsLibrary_EngineVersionAgnosticUserDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineUserDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineUserDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineUserDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineUserDir");

	UEngine_BlueprintPathsLibrary_EngineUserDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineSourceDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineSourceDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineSourceDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineSourceDir");

	UEngine_BlueprintPathsLibrary_EngineSourceDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineSavedDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineSavedDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineSavedDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineSavedDir");

	UEngine_BlueprintPathsLibrary_EngineSavedDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EnginePluginsDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EnginePluginsDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnginePluginsDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EnginePluginsDir");

	UEngine_BlueprintPathsLibrary_EnginePluginsDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineIntermediateDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineIntermediateDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineIntermediateDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineIntermediateDir");

	UEngine_BlueprintPathsLibrary_EngineIntermediateDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineDir");

	UEngine_BlueprintPathsLibrary_EngineDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineContentDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineContentDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineContentDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineContentDir");

	UEngine_BlueprintPathsLibrary_EngineContentDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.EngineConfigDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_EngineConfigDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineConfigDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.EngineConfigDir");

	UEngine_BlueprintPathsLibrary_EngineConfigDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.DirectoryExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_DirectoryExists(const struct FString& InPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.DirectoryExists");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.DirectoryExists");

	UEngine_BlueprintPathsLibrary_DirectoryExists_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.DiffDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_DiffDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.DiffDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.DiffDir");

	UEngine_BlueprintPathsLibrary_DiffDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.CreateTempFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Path                           (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// struct FString                 Extension                      (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_CreateTempFilename(const struct FString& Path, const struct FString& Prefix, const struct FString& Extension)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CreateTempFilename");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CreateTempFilename");

	UEngine_BlueprintPathsLibrary_CreateTempFilename_Params params;
	params.Path = Path;
	params.Prefix = Prefix;
	params.Extension = Extension;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ConvertToSandboxPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 InSandboxName                  (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ConvertToSandboxPath(const struct FString& InPath, const struct FString& InSandboxName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertToSandboxPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertToSandboxPath");

	UEngine_BlueprintPathsLibrary_ConvertToSandboxPath_Params params;
	params.InPath = InPath;
	params.InSandboxName = InSandboxName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ConvertRelativePathToFull
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 InBasePath                     (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ConvertRelativePathToFull(const struct FString& InPath, const struct FString& InBasePath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertRelativePathToFull");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertRelativePathToFull");

	UEngine_BlueprintPathsLibrary_ConvertRelativePathToFull_Params params;
	params.InPath = InPath;
	params.InBasePath = InBasePath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ConvertFromSandboxPath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 InSandboxName                  (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ConvertFromSandboxPath(const struct FString& InPath, const struct FString& InSandboxName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertFromSandboxPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ConvertFromSandboxPath");

	UEngine_BlueprintPathsLibrary_ConvertFromSandboxPath_Params params;
	params.InPath = InPath;
	params.InSandboxName = InSandboxName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.Combine
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         InPaths                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_Combine(TArray<struct FString> InPaths)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.Combine");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.Combine");

	UEngine_BlueprintPathsLibrary_Combine_Params params;
	params.InPaths = InPaths;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.CollapseRelativeDirectories
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 OutPath                        (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintPathsLibrary::STATIC_CollapseRelativeDirectories(const struct FString& InPath, struct FString* OutPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CollapseRelativeDirectories");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CollapseRelativeDirectories");

	UEngine_BlueprintPathsLibrary_CollapseRelativeDirectories_Params params;
	params.InPath = InPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPath != nullptr)
		*OutPath = params.OutPath;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.CloudDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_CloudDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CloudDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.CloudDir");

	UEngine_BlueprintPathsLibrary_CloudDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.ChangeExtension
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InPath                         (Parm, ZeroConstructor)
// struct FString                 InNewExtension                 (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_ChangeExtension(const struct FString& InPath, const struct FString& InNewExtension)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ChangeExtension");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.ChangeExtension");

	UEngine_BlueprintPathsLibrary_ChangeExtension_Params params;
	params.InPath = InPath;
	params.InNewExtension = InNewExtension;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.BugItDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_BugItDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.BugItDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.BugItDir");

	UEngine_BlueprintPathsLibrary_BugItDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.AutomationTransientDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_AutomationTransientDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationTransientDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationTransientDir");

	UEngine_BlueprintPathsLibrary_AutomationTransientDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.AutomationLogDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_AutomationLogDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationLogDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationLogDir");

	UEngine_BlueprintPathsLibrary_AutomationLogDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPathsLibrary.AutomationDir
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_BlueprintPathsLibrary::STATIC_AutomationDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPathsLibrary.AutomationDir");

	UEngine_BlueprintPathsLibrary_AutomationDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            inSecondsFromNow               (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Title                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   Body                           (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   Action                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FString                 ActivationEvent                (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_BlueprintPlatformLibrary::STATIC_ScheduleLocalNotificationFromNow(int inSecondsFromNow, const struct FText& Title, const struct FText& Body, const struct FText& Action, const struct FString& ActivationEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow");

	UEngine_BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow_Params params;
	params.inSecondsFromNow = inSecondsFromNow;
	params.Title = Title;
	params.Body = Body;
	params.Action = Action;
	params.ActivationEvent = ActivationEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeFromNow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            inSecondsFromNow               (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ActivationEvent                (Parm, ZeroConstructor)

void UEngine_BlueprintPlatformLibrary::STATIC_ScheduleLocalNotificationBadgeFromNow(int inSecondsFromNow, const struct FString& ActivationEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeFromNow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeFromNow");

	UEngine_BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow_Params params;
	params.inSecondsFromNow = inSecondsFromNow;
	params.ActivationEvent = ActivationEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeAtTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime               FireDateTime                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           LocalTime                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ActivationEvent                (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_BlueprintPlatformLibrary::STATIC_ScheduleLocalNotificationBadgeAtTime(const struct FDateTime& FireDateTime, bool LocalTime, const struct FString& ActivationEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeAtTime");

	UEngine_BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime_Params params;
	params.FireDateTime = FireDateTime;
	params.LocalTime = LocalTime;
	params.ActivationEvent = ActivationEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime               FireDateTime                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           LocalTime                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Title                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   Body                           (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   Action                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FString                 ActivationEvent                (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_BlueprintPlatformLibrary::STATIC_ScheduleLocalNotificationAtTime(const struct FDateTime& FireDateTime, bool LocalTime, const struct FText& Title, const struct FText& Body, const struct FText& Action, const struct FString& ActivationEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime");

	UEngine_BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime_Params params;
	params.FireDateTime = FireDateTime;
	params.LocalTime = LocalTime;
	params.Title = Title;
	params.Body = Body;
	params.Action = Action;
	params.ActivationEvent = ActivationEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.GetLaunchNotification
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// bool                           NotificationLaunchedApp        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FString                 ActivationEvent                (Parm, OutParm, ZeroConstructor)
// int                            FireDate                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_BlueprintPlatformLibrary::STATIC_GetLaunchNotification(bool* NotificationLaunchedApp, struct FString* ActivationEvent, int* FireDate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.GetLaunchNotification");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.GetLaunchNotification");

	UEngine_BlueprintPlatformLibrary_GetLaunchNotification_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NotificationLaunchedApp != nullptr)
		*NotificationLaunchedApp = params.NotificationLaunchedApp;
	if (ActivationEvent != nullptr)
		*ActivationEvent = params.ActivationEvent;
	if (FireDate != nullptr)
		*FireDate = params.FireDate;
}


// Function Engine.BlueprintPlatformLibrary.GetDeviceOrientation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TEnumAsByte<FEngine_Engine_EScreenOrientation> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_EScreenOrientation> UEngine_BlueprintPlatformLibrary::STATIC_GetDeviceOrientation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.GetDeviceOrientation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.GetDeviceOrientation");

	UEngine_BlueprintPlatformLibrary_GetDeviceOrientation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintPlatformLibrary.ClearAllLocalNotifications
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_BlueprintPlatformLibrary::STATIC_ClearAllLocalNotifications()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ClearAllLocalNotifications");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.ClearAllLocalNotifications");

	UEngine_BlueprintPlatformLibrary_ClearAllLocalNotifications_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintPlatformLibrary.CancelLocalNotificationById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            NotificationId                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_BlueprintPlatformLibrary::STATIC_CancelLocalNotificationById(int NotificationId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.CancelLocalNotificationById");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.CancelLocalNotificationById");

	UEngine_BlueprintPlatformLibrary_CancelLocalNotificationById_Params params;
	params.NotificationId = NotificationId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintPlatformLibrary.CancelLocalNotification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 ActivationEvent                (Parm, ZeroConstructor)

void UEngine_BlueprintPlatformLibrary::STATIC_CancelLocalNotification(const struct FString& ActivationEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.CancelLocalNotification");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintPlatformLibrary.CancelLocalNotification");

	UEngine_BlueprintPlatformLibrary_CancelLocalNotification_Params params;
	params.ActivationEvent = ActivationEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.SetSetPropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_BlueprintSetLibrary::STATIC_SetSetPropertyByName(class UObject* Object, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.SetSetPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.SetSetPropertyByName");

	UEngine_BlueprintSetLibrary_SetSetPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.Set_Union
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)

void UEngine_BlueprintSetLibrary::STATIC_Set_Union()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Union");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Union");

	UEngine_BlueprintSetLibrary_Set_Union_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.Set_ToArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    Result                         (Parm, OutParm, ZeroConstructor)

void UEngine_BlueprintSetLibrary::STATIC_Set_ToArray(TArray<int>* Result)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_ToArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_ToArray");

	UEngine_BlueprintSetLibrary_Set_ToArray_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;
}


// Function Engine.BlueprintSetLibrary.Set_RemoveItems
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    Items                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_BlueprintSetLibrary::STATIC_Set_RemoveItems(TArray<int> Items)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_RemoveItems");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_RemoveItems");

	UEngine_BlueprintSetLibrary_Set_RemoveItems_Params params;
	params.Items = Items;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.Set_Remove
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            Item                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintSetLibrary::STATIC_Set_Remove(int Item)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Remove");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Remove");

	UEngine_BlueprintSetLibrary_Set_Remove_Params params;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_Length
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_BlueprintSetLibrary::STATIC_Set_Length()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Length");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Length");

	UEngine_BlueprintSetLibrary_Set_Length_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_Intersection
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)

void UEngine_BlueprintSetLibrary::STATIC_Set_Intersection()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Intersection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Intersection");

	UEngine_BlueprintSetLibrary_Set_Intersection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.Set_Difference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)

void UEngine_BlueprintSetLibrary::STATIC_Set_Difference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Difference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Difference");

	UEngine_BlueprintSetLibrary_Set_Difference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.Set_Contains
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ItemToFind                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_BlueprintSetLibrary::STATIC_Set_Contains(int ItemToFind)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Contains");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Contains");

	UEngine_BlueprintSetLibrary_Set_Contains_Params params;
	params.ItemToFind = ItemToFind;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BlueprintSetLibrary.Set_Clear
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)

void UEngine_BlueprintSetLibrary::STATIC_Set_Clear()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Clear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Clear");

	UEngine_BlueprintSetLibrary_Set_Clear_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.Set_AddItems
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    NewItems                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_BlueprintSetLibrary::STATIC_Set_AddItems(TArray<int> NewItems)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_AddItems");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_AddItems");

	UEngine_BlueprintSetLibrary_Set_AddItems_Params params;
	params.NewItems = NewItems;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BlueprintSetLibrary.Set_Add
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            NewItem                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_BlueprintSetLibrary::STATIC_Set_Add(int NewItem)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Add");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BlueprintSetLibrary.Set_Add");

	UEngine_BlueprintSetLibrary_Set_Add_Params params;
	params.NewItem = NewItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioVolume.SetReverbSettings
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_ReverbSettings  NewReverbSettings              (ConstParm, Parm, OutParm, ReferenceParm)

void AEngine_AudioVolume::SetReverbSettings(const struct FEngine_ReverbSettings& NewReverbSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetReverbSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetReverbSettings");

	AEngine_AudioVolume_SetReverbSettings_Params params;
	params.NewReverbSettings = NewReverbSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioVolume.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewPriority                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_AudioVolume::SetPriority(float NewPriority)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetPriority");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetPriority");

	AEngine_AudioVolume_SetPriority_Params params;
	params.NewPriority = NewPriority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioVolume.SetInteriorSettings
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_InteriorSettings NewInteriorSettings            (ConstParm, Parm, OutParm, ReferenceParm)

void AEngine_AudioVolume::SetInteriorSettings(const struct FEngine_InteriorSettings& NewInteriorSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetInteriorSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetInteriorSettings");

	AEngine_AudioVolume_SetInteriorSettings_Params params;
	params.NewInteriorSettings = NewInteriorSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioVolume.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewEnabled                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_AudioVolume::SetEnabled(bool bNewEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.SetEnabled");

	AEngine_AudioVolume_SetEnabled_Params params;
	params.bNewEnabled = bNewEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.AudioVolume.OnRep_bEnabled
// (Final, Native, Private)

void AEngine_AudioVolume::OnRep_bEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.OnRep_bEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.AudioVolume.OnRep_bEnabled");

	AEngine_AudioVolume_OnRep_bEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BoxComponent.SetBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InBoxExtent                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateOverlaps                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_BoxComponent::SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.SetBoxExtent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.SetBoxExtent");

	UEngine_BoxComponent_SetBoxExtent_Params params;
	params.InBoxExtent = InBoxExtent;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.BoxComponent.GetUnscaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_BoxComponent::GetUnscaledBoxExtent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetUnscaledBoxExtent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetUnscaledBoxExtent");

	UEngine_BoxComponent_GetUnscaledBoxExtent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.BoxComponent.GetScaledBoxExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_BoxComponent::GetScaledBoxExtent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetScaledBoxExtent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetScaledBoxExtent");

	UEngine_BoxComponent_GetScaledBoxExtent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraAnimInst.Stop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bImmediate                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraAnimInst::Stop(bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.Stop");

	UEngine_CameraAnimInst_Stop_Params params;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraAnimInst.SetScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewDuration                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraAnimInst::SetScale(float NewDuration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.SetScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.SetScale");

	UEngine_CameraAnimInst_SetScale_Params params;
	params.NewDuration = NewDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraAnimInst.SetDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewDuration                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraAnimInst::SetDuration(float NewDuration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.SetDuration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.SetDuration");

	UEngine_CameraAnimInst_SetDuration_Params params;
	params.NewDuration = NewDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.IsDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_CameraModifier::IsDisabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.IsDisabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.IsDisabled");

	UEngine_CameraModifier_IsDisabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraModifier.GetViewTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* UEngine_CameraModifier::GetViewTarget()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.GetViewTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.GetViewTarget");

	UEngine_CameraModifier_GetViewTarget_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraModifier.EnableModifier
// (Native, Public, BlueprintCallable)

void UEngine_CameraModifier::EnableModifier()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.EnableModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.EnableModifier");

	UEngine_CameraModifier_EnableModifier_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.DisableModifier
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bImmediate                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraModifier::DisableModifier(bool bImmediate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.DisableModifier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.DisableModifier");

	UEngine_CameraModifier_DisableModifier_Params params;
	params.bImmediate = bImmediate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraModifier.BlueprintModifyPostProcess
// (BlueprintCosmetic, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          PostProcessBlendWeight         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FEngine_PostProcessSettings PostProcessSettings            (Parm, OutParm)

void UEngine_CameraModifier::BlueprintModifyPostProcess(float DeltaTime, float* PostProcessBlendWeight, struct FEngine_PostProcessSettings* PostProcessSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyPostProcess");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyPostProcess");

	UEngine_CameraModifier_BlueprintModifyPostProcess_Params params;
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PostProcessBlendWeight != nullptr)
		*PostProcessBlendWeight = params.PostProcessBlendWeight;
	if (PostProcessSettings != nullptr)
		*PostProcessSettings = params.PostProcessSettings;
}


// Function Engine.CameraModifier.BlueprintModifyCamera
// (BlueprintCosmetic, Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ViewLocation                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ViewRotation                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          FOV                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NewViewLocation                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewViewRotation                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          NewFOV                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraModifier::BlueprintModifyCamera(float DeltaTime, const struct FVector& ViewLocation, const struct FRotator& ViewRotation, float FOV, struct FVector* NewViewLocation, struct FRotator* NewViewRotation, float* NewFOV)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraModifier.BlueprintModifyCamera");

	UEngine_CameraModifier_BlueprintModifyCamera_Params params;
	params.DeltaTime = DeltaTime;
	params.ViewLocation = ViewLocation;
	params.ViewRotation = ViewRotation;
	params.FOV = FOV;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (NewViewLocation != nullptr)
		*NewViewLocation = params.NewViewLocation;
	if (NewViewRotation != nullptr)
		*NewViewRotation = params.NewViewRotation;
	if (NewFOV != nullptr)
		*NewFOV = params.NewFOV;
}


// Function Engine.CameraShake.ReceiveStopShake
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                           bImmediately                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraShake::ReceiveStopShake(bool bImmediately)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceiveStopShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceiveStopShake");

	UEngine_CameraShake_ReceiveStopShake_Params params;
	params.bImmediately = bImmediately;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraShake.ReceivePlayShake
// (Event, Public, BlueprintEvent)
// Parameters:
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CameraShake::ReceivePlayShake(float Scale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceivePlayShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceivePlayShake");

	UEngine_CameraShake_ReceivePlayShake_Params params;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CameraShake.ReceiveIsFinished
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_CameraShake::ReceiveIsFinished()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceiveIsFinished");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.ReceiveIsFinished");

	UEngine_CameraShake_ReceiveIsFinished_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CameraShake.BlueprintUpdateCameraShake
// (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_MinimalViewInfo POV                            (ConstParm, Parm, OutParm, ReferenceParm)
// struct FEngine_MinimalViewInfo ModifiedPOV                    (Parm, OutParm)

void UEngine_CameraShake::BlueprintUpdateCameraShake(float DeltaTime, float ALPHA, const struct FEngine_MinimalViewInfo& POV, struct FEngine_MinimalViewInfo* ModifiedPOV)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.BlueprintUpdateCameraShake");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CameraShake.BlueprintUpdateCameraShake");

	UEngine_CameraShake_BlueprintUpdateCameraShake_Params params;
	params.DeltaTime = DeltaTime;
	params.ALPHA = ALPHA;
	params.POV = POV;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ModifiedPOV != nullptr)
		*ModifiedPOV = params.ModifiedPOV;
}


// Function Engine.Canvas.K2_TextSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Font*            RenderFont                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 RenderText                     (Parm, ZeroConstructor)
// struct FVector2D               Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_Canvas::K2_TextSize(class UEngine_Font* RenderFont, const struct FString& RenderText, const struct FVector2D& Scale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_TextSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_TextSize");

	UEngine_Canvas_K2_TextSize_Params params;
	params.RenderFont = RenderFont;
	params.RenderText = RenderText;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.K2_StrLen
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Font*            RenderFont                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 RenderText                     (Parm, ZeroConstructor)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_Canvas::K2_StrLen(class UEngine_Font* RenderFont, const struct FString& RenderText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_StrLen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_StrLen");

	UEngine_Canvas_K2_StrLen_Params params;
	params.RenderFont = RenderFont;
	params.RenderText = RenderText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.K2_Project
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 WorldLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_Canvas::K2_Project(const struct FVector& WorldLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Project");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Project");

	UEngine_Canvas_K2_Project_Params params;
	params.WorldLocation = WorldLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Canvas.K2_DrawTriangle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         RenderTexture                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_CanvasUVTri> Triangles                      (Parm, ZeroConstructor)

void UEngine_Canvas::K2_DrawTriangle(class UEngine_Texture* RenderTexture, TArray<struct FEngine_CanvasUVTri> Triangles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTriangle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTriangle");

	UEngine_Canvas_K2_DrawTriangle_Params params;
	params.RenderTexture = RenderTexture;
	params.Triangles = Triangles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         RenderTexture                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenSize                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               CoordinatePosition             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               CoordinateSize                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            RenderColor                    (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBlendMode> BlendMode                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               PivotPoint                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_DrawTexture(class UEngine_Texture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, TEnumAsByte<FEngine_Engine_EBlendMode> BlendMode, float Rotation, const struct FVector2D& PivotPoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTexture");

	UEngine_Canvas_K2_DrawTexture_Params params;
	params.RenderTexture = RenderTexture;
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.CoordinatePosition = CoordinatePosition;
	params.CoordinateSize = CoordinateSize;
	params.RenderColor = RenderColor;
	params.BlendMode = BlendMode;
	params.Rotation = Rotation;
	params.PivotPoint = PivotPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawText
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Font*            RenderFont                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 RenderText                     (Parm, ZeroConstructor)
// struct FVector2D               ScreenPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            RenderColor                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Kerning                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ShadowColor                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ShadowOffset                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCentreX                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCentreY                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOutlined                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            OutlineColor                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_DrawText(class UEngine_Font* RenderFont, const struct FString& RenderText, const struct FVector2D& ScreenPosition, const struct FVector2D& Scale, const struct FLinearColor& RenderColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawText");

	UEngine_Canvas_K2_DrawText_Params params;
	params.RenderFont = RenderFont;
	params.RenderText = RenderText;
	params.ScreenPosition = ScreenPosition;
	params.Scale = Scale;
	params.RenderColor = RenderColor;
	params.Kerning = Kerning;
	params.ShadowColor = ShadowColor;
	params.ShadowOffset = ShadowOffset;
	params.bCentreX = bCentreX;
	params.bCentreY = bCentreY;
	params.bOutlined = bOutlined;
	params.OutlineColor = OutlineColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawPolygon
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         RenderTexture                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumberOfSides                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            RenderColor                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_DrawPolygon(class UEngine_Texture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& Radius, int NumberOfSides, const struct FLinearColor& RenderColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawPolygon");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawPolygon");

	UEngine_Canvas_K2_DrawPolygon_Params params;
	params.RenderTexture = RenderTexture;
	params.ScreenPosition = ScreenPosition;
	params.Radius = Radius;
	params.NumberOfSides = NumberOfSides;
	params.RenderColor = RenderColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawMaterialTriangle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* RenderMaterial                 (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_CanvasUVTri> Triangles                      (Parm, ZeroConstructor)

void UEngine_Canvas::K2_DrawMaterialTriangle(class UEngine_MaterialInterface* RenderMaterial, TArray<struct FEngine_CanvasUVTri> Triangles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterialTriangle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterialTriangle");

	UEngine_Canvas_K2_DrawMaterialTriangle_Params params;
	params.RenderMaterial = RenderMaterial;
	params.Triangles = Triangles;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawMaterial
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* RenderMaterial                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenSize                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               CoordinatePosition             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               CoordinateSize                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               PivotPoint                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_DrawMaterial(class UEngine_MaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterial");

	UEngine_Canvas_K2_DrawMaterial_Params params;
	params.RenderMaterial = RenderMaterial;
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.CoordinatePosition = CoordinatePosition;
	params.CoordinateSize = CoordinateSize;
	params.Rotation = Rotation;
	params.PivotPoint = PivotPoint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawLine
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               ScreenPositionA                (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenPositionB                (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            RenderColor                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_DrawLine(const struct FVector2D& ScreenPositionA, const struct FVector2D& ScreenPositionB, float Thickness, const struct FLinearColor& RenderColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawLine");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawLine");

	UEngine_Canvas_K2_DrawLine_Params params;
	params.ScreenPositionA = ScreenPositionA;
	params.ScreenPositionB = ScreenPositionB;
	params.Thickness = Thickness;
	params.RenderColor = RenderColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawBox
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               ScreenPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenSize                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            RenderColor                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_DrawBox(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness, const struct FLinearColor& RenderColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBox");

	UEngine_Canvas_K2_DrawBox_Params params;
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.Thickness = Thickness;
	params.RenderColor = RenderColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_DrawBorder
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         BorderTexture                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         BackgroundTexture              (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         LeftBorderTexture              (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         RightBorderTexture             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         TopBorderTexture               (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         BottomBorderTexture            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ScreenSize                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               CoordinatePosition             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               CoordinateSize                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            RenderColor                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               BorderScale                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               BackgroundScale                (Parm, ZeroConstructor, IsPlainOldData)
// float                          Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               PivotPoint                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               CornerSize                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_DrawBorder(class UEngine_Texture* BorderTexture, class UEngine_Texture* BackgroundTexture, class UEngine_Texture* LeftBorderTexture, class UEngine_Texture* RightBorderTexture, class UEngine_Texture* TopBorderTexture, class UEngine_Texture* BottomBorderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, const struct FVector2D& BorderScale, const struct FVector2D& BackgroundScale, float Rotation, const struct FVector2D& PivotPoint, const struct FVector2D& CornerSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBorder");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBorder");

	UEngine_Canvas_K2_DrawBorder_Params params;
	params.BorderTexture = BorderTexture;
	params.BackgroundTexture = BackgroundTexture;
	params.LeftBorderTexture = LeftBorderTexture;
	params.RightBorderTexture = RightBorderTexture;
	params.TopBorderTexture = TopBorderTexture;
	params.BottomBorderTexture = BottomBorderTexture;
	params.ScreenPosition = ScreenPosition;
	params.ScreenSize = ScreenSize;
	params.CoordinatePosition = CoordinatePosition;
	params.CoordinateSize = CoordinateSize;
	params.RenderColor = RenderColor;
	params.BorderScale = BorderScale;
	params.BackgroundScale = BackgroundScale;
	params.Rotation = Rotation;
	params.PivotPoint = PivotPoint;
	params.CornerSize = CornerSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Canvas.K2_Deproject
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               ScreenPosition                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldOrigin                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldDirection                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_Canvas::K2_Deproject(const struct FVector2D& ScreenPosition, struct FVector* WorldOrigin, struct FVector* WorldDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Deproject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Deproject");

	UEngine_Canvas_K2_Deproject_Params params;
	params.ScreenPosition = ScreenPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (WorldOrigin != nullptr)
		*WorldOrigin = params.WorldOrigin;
	if (WorldDirection != nullptr)
		*WorldDirection = params.WorldDirection;
}


// Function Engine.CanvasRenderTarget2D.UpdateResource
// (Native, Public, BlueprintCallable)

void UEngine_CanvasRenderTarget2D::UpdateResource()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.UpdateResource");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.UpdateResource");

	UEngine_CanvasRenderTarget2D_UpdateResource_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CanvasRenderTarget2D.ReceiveUpdate
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEngine_Canvas*          Canvas                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            Width                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Height                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CanvasRenderTarget2D::ReceiveUpdate(class UEngine_Canvas* Canvas, int Width, int Height)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.ReceiveUpdate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.ReceiveUpdate");

	UEngine_CanvasRenderTarget2D_ReceiveUpdate_Params params;
	params.Canvas = Canvas;
	params.Width = Width;
	params.Height = Height;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CanvasRenderTarget2D.GetSize
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Width                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Height                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CanvasRenderTarget2D::GetSize(int* Width, int* Height)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.GetSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.GetSize");

	UEngine_CanvasRenderTarget2D_GetSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Width != nullptr)
		*Width = params.Width;
	if (Height != nullptr)
		*Height = params.Height;
}


// Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  CanvasRenderTarget2DClass      (Parm, ZeroConstructor, IsPlainOldData)
// int                            Width                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Height                         (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_CanvasRenderTarget2D* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_CanvasRenderTarget2D* UEngine_CanvasRenderTarget2D::STATIC_CreateCanvasRenderTarget2D(class UObject* WorldContextObject, class UClass* CanvasRenderTarget2DClass, int Width, int Height)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D");

	UEngine_CanvasRenderTarget2D_CreateCanvasRenderTarget2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.CanvasRenderTarget2DClass = CanvasRenderTarget2DClass;
	params.Width = Width;
	params.Height = Height;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CapsuleComponent.SetCapsuleSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InRadius                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          InHalfHeight                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateOverlaps                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CapsuleComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleSize");

	UEngine_CapsuleComponent_SetCapsuleSize_Params params;
	params.InRadius = InRadius;
	params.InHalfHeight = InHalfHeight;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CapsuleComponent.SetCapsuleRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateOverlaps                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CapsuleComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleRadius");

	UEngine_CapsuleComponent_SetCapsuleRadius_Params params;
	params.Radius = Radius;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CapsuleComponent.SetCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateOverlaps                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_CapsuleComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleHalfHeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleHalfHeight");

	UEngine_CapsuleComponent_SetCapsuleHalfHeight_Params params;
	params.HalfHeight = HalfHeight;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          OutRadius                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutHalfHeightWithoutHemisphere (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CapsuleComponent::GetUnscaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere");

	UEngine_CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRadius != nullptr)
		*OutRadius = params.OutRadius;
	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = params.OutHalfHeightWithoutHemisphere;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          OutRadius                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutHalfHeight                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CapsuleComponent::GetUnscaledCapsuleSize(float* OutRadius, float* OutHalfHeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize");

	UEngine_CapsuleComponent_GetUnscaledCapsuleSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRadius != nullptr)
		*OutRadius = params.OutRadius;
	if (OutHalfHeight != nullptr)
		*OutHalfHeight = params.OutHalfHeight;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CapsuleComponent::GetUnscaledCapsuleRadius()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius");

	UEngine_CapsuleComponent_GetUnscaledCapsuleRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CapsuleComponent::GetUnscaledCapsuleHalfHeight_WithoutHemisphere()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere");

	UEngine_CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CapsuleComponent::GetUnscaledCapsuleHalfHeight()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight");

	UEngine_CapsuleComponent_GetUnscaledCapsuleHalfHeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CapsuleComponent.GetShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CapsuleComponent::GetShapeScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetShapeScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetShapeScale");

	UEngine_CapsuleComponent_GetShapeScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          OutRadius                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutHalfHeightWithoutHemisphere (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CapsuleComponent::GetScaledCapsuleSize_WithoutHemisphere(float* OutRadius, float* OutHalfHeightWithoutHemisphere)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere");

	UEngine_CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRadius != nullptr)
		*OutRadius = params.OutRadius;
	if (OutHalfHeightWithoutHemisphere != nullptr)
		*OutHalfHeightWithoutHemisphere = params.OutHalfHeightWithoutHemisphere;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleSize
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          OutRadius                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutHalfHeight                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CapsuleComponent::GetScaledCapsuleSize(float* OutRadius, float* OutHalfHeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize");

	UEngine_CapsuleComponent_GetScaledCapsuleSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRadius != nullptr)
		*OutRadius = params.OutRadius;
	if (OutHalfHeight != nullptr)
		*OutHalfHeight = params.OutHalfHeight;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CapsuleComponent::GetScaledCapsuleRadius()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleRadius");

	UEngine_CapsuleComponent_GetScaledCapsuleRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CapsuleComponent::GetScaledCapsuleHalfHeight_WithoutHemisphere()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere");

	UEngine_CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CapsuleComponent::GetScaledCapsuleHalfHeight()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight");

	UEngine_CapsuleComponent_GetScaledCapsuleHalfHeight_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CurveBase.GetValueRange
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          MinValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          MaxValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CurveBase::GetValueRange(float* MinValue, float* MaxValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetValueRange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetValueRange");

	UEngine_CurveBase_GetValueRange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MinValue != nullptr)
		*MinValue = params.MinValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;
}


// Function Engine.CurveBase.GetTimeRange
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          MinTime                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          MaxTime                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_CurveBase::GetTimeRange(float* MinTime, float* MaxTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetTimeRange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetTimeRange");

	UEngine_CurveBase_GetTimeRange_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (MinTime != nullptr)
		*MinTime = params.MinTime;
	if (MaxTime != nullptr)
		*MaxTime = params.MaxTime;
}


// Function Engine.CurveFloat.GetFloatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InTime                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CurveFloat::GetFloatValue(float InTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveFloat.GetFloatValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveFloat.GetFloatValue");

	UEngine_CurveFloat_GetFloatValue_Params params;
	params.InTime = InTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CurveLinearColor.GetLinearColorValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InTime                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_CurveLinearColor::GetLinearColorValue(float InTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetLinearColorValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetLinearColorValue");

	UEngine_CurveLinearColor_GetLinearColorValue_Params params;
	params.InTime = InTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CurveLinearColor.GetClampedLinearColorValue
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InTime                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_CurveLinearColor::GetClampedLinearColorValue(float InTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetClampedLinearColorValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetClampedLinearColorValue");

	UEngine_CurveLinearColor_GetClampedLinearColorValue_Params params;
	params.InTime = InTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Texture2D.Blueprint_GetSizeY
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_Texture2D::Blueprint_GetSizeY()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeY");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeY");

	UEngine_Texture2D_Blueprint_GetSizeY_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Texture2D.Blueprint_GetSizeX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_Texture2D::Blueprint_GetSizeX()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeX");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeX");

	UEngine_Texture2D_Blueprint_GetSizeX_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CurveLinearColorAtlas.GetCurvePosition
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UEngine_CurveLinearColor* InCurve                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Position                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_CurveLinearColorAtlas::GetCurvePosition(class UEngine_CurveLinearColor* InCurve, float* Position)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColorAtlas.GetCurvePosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColorAtlas.GetCurvePosition");

	UEngine_CurveLinearColorAtlas_GetCurvePosition_Params params;
	params.InCurve = InCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Position != nullptr)
		*Position = params.Position;

	return params.ReturnValue;
}


// Function Engine.CurveSourceInterface.GetCurveValue
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FName                   CurveName                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_CurveSourceInterface::GetCurveValue(const struct FName& CurveName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetCurveValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetCurveValue");

	UEngine_CurveSourceInterface_GetCurveValue_Params params;
	params.CurveName = CurveName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CurveSourceInterface.GetCurves
// (Native, Event, Public, HasOutParms, BlueprintEvent, Const)
// Parameters:
// TArray<struct FEngine_NamedCurveValue> OutValues                      (Parm, OutParm, ZeroConstructor)

void UEngine_CurveSourceInterface::GetCurves(TArray<struct FEngine_NamedCurveValue>* OutValues)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetCurves");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetCurves");

	UEngine_CurveSourceInterface_GetCurves_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutValues != nullptr)
		*OutValues = params.OutValues;
}


// Function Engine.CurveSourceInterface.GetBindingName
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_CurveSourceInterface::GetBindingName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetBindingName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveSourceInterface.GetBindingName");

	UEngine_CurveSourceInterface_GetBindingName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.CurveVector.GetVectorValue
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          InTime                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_CurveVector::GetVectorValue(float InTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.CurveVector.GetVectorValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.CurveVector.GetVectorValue");

	UEngine_CurveVector_GetVectorValue_Params params;
	params.InTime = InTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DataTableFunctionLibrary.GetDataTableRowNames
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UEngine_DataTable*       Table                          (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FName>           OutRowNames                    (Parm, OutParm, ZeroConstructor)

void UEngine_DataTableFunctionLibrary::STATIC_GetDataTableRowNames(class UEngine_DataTable* Table, TArray<struct FName>* OutRowNames)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowNames");

	UEngine_DataTableFunctionLibrary_GetDataTableRowNames_Params params;
	params.Table = Table;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRowNames != nullptr)
		*OutRowNames = params.OutRowNames;
}


// Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UEngine_DataTable*       Table                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   RowName                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TableRowBase    OutRow                         (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_DataTableFunctionLibrary::STATIC_GetDataTableRowFromName(class UEngine_DataTable* Table, const struct FName& RowName, struct FEngine_TableRowBase* OutRow)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName");

	UEngine_DataTableFunctionLibrary_GetDataTableRowFromName_Params params;
	params.Table = Table;
	params.RowName = RowName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRow != nullptr)
		*OutRow = params.OutRow;

	return params.ReturnValue;
}


// Function Engine.DataTableFunctionLibrary.GetDataTableColumnAsString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_DataTable*       DataTable                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UEngine_DataTableFunctionLibrary::STATIC_GetDataTableColumnAsString(class UEngine_DataTable* DataTable, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableColumnAsString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableColumnAsString");

	UEngine_DataTableFunctionLibrary_GetDataTableColumnAsString_Params params;
	params.DataTable = DataTable;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UEngine_CurveTable*      CurveTable                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   RowName                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          InXY                           (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EEvaluateCurveTableResult> OutResult                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutXY                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FString                 ContextString                  (Parm, ZeroConstructor)

void UEngine_DataTableFunctionLibrary::STATIC_EvaluateCurveTableRow(class UEngine_CurveTable* CurveTable, const struct FName& RowName, float InXY, const struct FString& ContextString, TEnumAsByte<FEngine_Engine_EEvaluateCurveTableResult>* OutResult, float* OutXY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow");

	UEngine_DataTableFunctionLibrary_EvaluateCurveTableRow_Params params;
	params.CurveTable = CurveTable;
	params.RowName = RowName;
	params.InXY = InXY;
	params.ContextString = ContextString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutResult != nullptr)
		*OutResult = params.OutResult;
	if (OutXY != nullptr)
		*OutXY = params.OutXY;
}


// Function Engine.DataTableFunctionLibrary.DoesDataTableRowExist
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_DataTable*       Table                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   RowName                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_DataTableFunctionLibrary::STATIC_DoesDataTableRowExist(class UEngine_DataTable* Table, const struct FName& RowName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.DoesDataTableRowExist");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.DoesDataTableRowExist");

	UEngine_DataTableFunctionLibrary_DoesDataTableRowExist_Params params;
	params.Table = Table;
	params.RowName = RowName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DebugCameraController.ToggleDisplay
// (Final, Native, Public, BlueprintCallable)

void AEngine_DebugCameraController::ToggleDisplay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ToggleDisplay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ToggleDisplay");

	AEngine_DebugCameraController_ToggleDisplay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DebugCameraController.ShowDebugSelectedInfo
// (Exec, Native, Public)

void AEngine_DebugCameraController::ShowDebugSelectedInfo()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ShowDebugSelectedInfo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ShowDebugSelectedInfo");

	AEngine_DebugCameraController_ShowDebugSelectedInfo_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DebugCameraController.SetPawnMovementSpeedScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewSpeedScale                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DebugCameraController::SetPawnMovementSpeedScale(float NewSpeedScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.SetPawnMovementSpeedScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.SetPawnMovementSpeedScale");

	AEngine_DebugCameraController_SetPawnMovementSpeedScale_Params params;
	params.NewSpeedScale = NewSpeedScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DebugCameraController.ReceiveOnDeactivate
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* RestoredPC                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DebugCameraController::ReceiveOnDeactivate(class AEngine_PlayerController* RestoredPC)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnDeactivate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnDeactivate");

	AEngine_DebugCameraController_ReceiveOnDeactivate_Params params;
	params.RestoredPC = RestoredPC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DebugCameraController.ReceiveOnActorSelected
// (Event, Protected, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
// class AEngine_Actor*           NewSelectedActor               (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SelectHitLocation              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 SelectHitNormal                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FEngine_HitResult       Hit                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void AEngine_DebugCameraController::ReceiveOnActorSelected(class AEngine_Actor* NewSelectedActor, const struct FVector& SelectHitLocation, const struct FVector& SelectHitNormal, const struct FEngine_HitResult& Hit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnActorSelected");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnActorSelected");

	AEngine_DebugCameraController_ReceiveOnActorSelected_Params params;
	params.NewSelectedActor = NewSelectedActor;
	params.SelectHitLocation = SelectHitLocation;
	params.SelectHitNormal = SelectHitNormal;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DebugCameraController.ReceiveOnActivate
// (Event, Public, BlueprintEvent)
// Parameters:
// class AEngine_PlayerController* OriginalPC                     (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DebugCameraController::ReceiveOnActivate(class AEngine_PlayerController* OriginalPC)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnActivate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ReceiveOnActivate");

	AEngine_DebugCameraController_ReceiveOnActivate_Params params;
	params.OriginalPC = OriginalPC;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DebugCameraController.GetSelectedActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEngine_Actor*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_Actor* AEngine_DebugCameraController::GetSelectedActor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.GetSelectedActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.GetSelectedActor");

	AEngine_DebugCameraController_GetSelectedActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.SetSortOrder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DecalComponent::SetSortOrder(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetSortOrder");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetSortOrder");

	UEngine_DecalComponent_SetSortOrder_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalComponent.SetFadeScreenSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewFadeScreenSize              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DecalComponent::SetFadeScreenSize(float NewFadeScreenSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeScreenSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeScreenSize");

	UEngine_DecalComponent_SetFadeScreenSize_Params params;
	params.NewFadeScreenSize = NewFadeScreenSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalComponent.SetFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          StartDelay                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           DestroyOwnerAfterFade          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DecalComponent::SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeOut");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeOut");

	UEngine_DecalComponent_SetFadeOut_Params params;
	params.StartDelay = StartDelay;
	params.Duration = Duration;
	params.DestroyOwnerAfterFade = DestroyOwnerAfterFade;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalComponent.SetFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          StartDelay                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duaration                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DecalComponent::SetFadeIn(float StartDelay, float Duaration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeIn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetFadeIn");

	UEngine_DecalComponent_SetFadeIn_Params params;
	params.StartDelay = StartDelay;
	params.Duaration = Duaration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalComponent.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* NewDecalMaterial               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DecalComponent::SetDecalMaterial(class UEngine_MaterialInterface* NewDecalMaterial)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetDecalMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetDecalMaterial");

	UEngine_DecalComponent_SetDecalMaterial_Params params;
	params.NewDecalMaterial = NewDecalMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DecalComponent.GetFadeStartDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_DecalComponent::GetFadeStartDelay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeStartDelay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeStartDelay");

	UEngine_DecalComponent_GetFadeStartDelay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.GetFadeInStartDelay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_DecalComponent::GetFadeInStartDelay()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeInStartDelay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeInStartDelay");

	UEngine_DecalComponent_GetFadeInStartDelay_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.GetFadeInDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_DecalComponent::GetFadeInDuration()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeInDuration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeInDuration");

	UEngine_DecalComponent_GetFadeInDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.GetFadeDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_DecalComponent::GetFadeDuration()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeDuration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetFadeDuration");

	UEngine_DecalComponent_GetFadeDuration_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.GetDecalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_MaterialInterface* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInterface* UEngine_DecalComponent::GetDecalMaterial()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetDecalMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetDecalMaterial");

	UEngine_DecalComponent_GetDecalMaterial_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DecalComponent.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* UEngine_DecalComponent::CreateDynamicMaterialInstance()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.CreateDynamicMaterialInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.CreateDynamicMaterialInstance");

	UEngine_DecalComponent_CreateDynamicMaterialInstance_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.DefaultPawn.TurnAtRate
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Rate                           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DefaultPawn::TurnAtRate(float Rate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.TurnAtRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.TurnAtRate");

	AEngine_DefaultPawn_TurnAtRate_Params params;
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DefaultPawn.MoveUp_World
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DefaultPawn::MoveUp_World(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveUp_World");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveUp_World");

	AEngine_DefaultPawn_MoveUp_World_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DefaultPawn.MoveRight
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DefaultPawn::MoveRight(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveRight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveRight");

	AEngine_DefaultPawn_MoveRight_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DefaultPawn.MoveForward
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Val                            (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DefaultPawn::MoveForward(float Val)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveForward");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveForward");

	AEngine_DefaultPawn_MoveForward_Params params;
	params.Val = Val;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DefaultPawn.LookUpAtRate
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          Rate                           (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_DefaultPawn::LookUpAtRate(float Rate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.LookUpAtRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.LookUpAtRate");

	AEngine_DefaultPawn_LookUpAtRate_Params params;
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.ToggleEnabled
// (Final, Native, Public, BlueprintCallable)

void AEngine_Light::ToggleEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.ToggleEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.ToggleEnabled");

	AEngine_Light_ToggleEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetLightFunctionScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLightFunctionScale          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionScale");

	AEngine_Light_SetLightFunctionScale_Params params;
	params.NewLightFunctionScale = NewLightFunctionScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* NewLightFunctionMaterial       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetLightFunctionMaterial(class UEngine_MaterialInterface* NewLightFunctionMaterial)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionMaterial");

	AEngine_Light_SetLightFunctionMaterial_Params params;
	params.NewLightFunctionMaterial = NewLightFunctionMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLightFunctionFadeDistance   (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionFadeDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionFadeDistance");

	AEngine_Light_SetLightFunctionFadeDistance_Params params;
	params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewLightColor                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightColor");

	AEngine_Light_SetLightColor_Params params;
	params.NewLightColor = NewLightColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bSetEnabled                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetEnabled(bool bSetEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetEnabled");

	AEngine_Light_SetEnabled_Params params;
	params.bSetEnabled = bSetEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetCastShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetCastShadows(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetCastShadows");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetCastShadows");

	AEngine_Light_SetCastShadows_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewBrightness                  (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetBrightness(float NewBrightness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetBrightness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetBrightness");

	AEngine_Light_SetBrightness_Params params;
	params.NewBrightness = NewBrightness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.SetAffectTranslucentLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Light::SetAffectTranslucentLighting(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.SetAffectTranslucentLighting");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.SetAffectTranslucentLighting");

	AEngine_Light_SetAffectTranslucentLighting_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.OnRep_bEnabled
// (Native, Public)

void AEngine_Light::OnRep_bEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.OnRep_bEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.OnRep_bEnabled");

	AEngine_Light_OnRep_bEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Light.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Light::IsEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.IsEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.IsEnabled");

	AEngine_Light_IsEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Light.GetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor AEngine_Light::GetLightColor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.GetLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.GetLightColor");

	AEngine_Light_GetLightColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Light.GetBrightness
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float AEngine_Light::GetBrightness()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Light.GetBrightness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Light.GetBrightness");

	AEngine_Light_GetBrightness_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LightComponentBase.SetSamplesPerPixel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponentBase::SetSamplesPerPixel(int NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetSamplesPerPixel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetSamplesPerPixel");

	UEngine_LightComponentBase_SetSamplesPerPixel_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponentBase.SetCastVolumetricShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponentBase::SetCastVolumetricShadow(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastVolumetricShadow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastVolumetricShadow");

	UEngine_LightComponentBase_SetCastVolumetricShadow_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponentBase.SetCastShadows
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponentBase::SetCastShadows(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastShadows");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastShadows");

	UEngine_LightComponentBase_SetCastShadows_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponentBase.SetCastRaytracedShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponentBase::SetCastRaytracedShadow(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastRaytracedShadow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastRaytracedShadow");

	UEngine_LightComponentBase_SetCastRaytracedShadow_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponentBase.SetCastDeepShadow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponentBase::SetCastDeepShadow(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastDeepShadow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetCastDeepShadow");

	UEngine_LightComponentBase_SetCastDeepShadow_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponentBase.SetAffectReflection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponentBase::SetAffectReflection(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetAffectReflection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetAffectReflection");

	UEngine_LightComponentBase_SetAffectReflection_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponentBase.SetAffectGlobalIllumination
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponentBase::SetAffectGlobalIllumination(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetAffectGlobalIllumination");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.SetAffectGlobalIllumination");

	UEngine_LightComponentBase_SetAffectGlobalIllumination_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponentBase.GetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_LightComponentBase::GetLightColor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.GetLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponentBase.GetLightColor");

	UEngine_LightComponentBase_GetLightColor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LightComponent.SetVolumetricScatteringIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensity                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetVolumetricScatteringIntensity(float NewIntensity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetVolumetricScatteringIntensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetVolumetricScatteringIntensity");

	UEngine_LightComponent_SetVolumetricScatteringIntensity_Params params;
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetUseIESBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetUseIESBrightness(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetUseIESBrightness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetUseIESBrightness");

	UEngine_LightComponent_SetUseIESBrightness_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetTransmission
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetTransmission(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetTransmission");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetTransmission");

	UEngine_LightComponent_SetTransmission_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetTemperature
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewTemperature                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetTemperature(float NewTemperature)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetTemperature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetTemperature");

	UEngine_LightComponent_SetTemperature_Params params;
	params.NewTemperature = NewTemperature;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetSpecularScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetSpecularScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetSpecularScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetSpecularScale");

	UEngine_LightComponent_SetSpecularScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetShadowSlopeBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetShadowSlopeBias(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetShadowSlopeBias");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetShadowSlopeBias");

	UEngine_LightComponent_SetShadowSlopeBias_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetShadowBias
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetShadowBias(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetShadowBias");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetShadowBias");

	UEngine_LightComponent_SetShadowBias_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetLightFunctionScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLightFunctionScale          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionScale");

	UEngine_LightComponent_SetLightFunctionScale_Params params;
	params.NewLightFunctionScale = NewLightFunctionScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetLightFunctionMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* NewLightFunctionMaterial       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetLightFunctionMaterial(class UEngine_MaterialInterface* NewLightFunctionMaterial)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionMaterial");

	UEngine_LightComponent_SetLightFunctionMaterial_Params params;
	params.NewLightFunctionMaterial = NewLightFunctionMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetLightFunctionFadeDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLightFunctionFadeDistance   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionFadeDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionFadeDistance");

	UEngine_LightComponent_SetLightFunctionFadeDistance_Params params;
	params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetLightFunctionDisabledBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetLightFunctionDisabledBrightness(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionDisabledBrightness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionDisabledBrightness");

	UEngine_LightComponent_SetLightFunctionDisabledBrightness_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewLightColor                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSRGB                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetLightColor(const struct FLinearColor& NewLightColor, bool bSRGB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightColor");

	UEngine_LightComponent_SetLightColor_Params params;
	params.NewLightColor = NewLightColor;
	params.bSRGB = bSRGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensity                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetIntensity(float NewIntensity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIntensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIntensity");

	UEngine_LightComponent_SetIntensity_Params params;
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetIndirectLightingIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensity                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIndirectLightingIntensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIndirectLightingIntensity");

	UEngine_LightComponent_SetIndirectLightingIntensity_Params params;
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetIESTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_TextureLightProfile* NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetIESTexture(class UEngine_TextureLightProfile* NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESTexture");

	UEngine_LightComponent_SetIESTexture_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetIESBrightnessScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetIESBrightnessScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESBrightnessScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESBrightnessScale");

	UEngine_LightComponent_SetIESBrightnessScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetForceCachedShadowsForMovablePrimitives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetForceCachedShadowsForMovablePrimitives(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetForceCachedShadowsForMovablePrimitives");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetForceCachedShadowsForMovablePrimitives");

	UEngine_LightComponent_SetForceCachedShadowsForMovablePrimitives_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetEnableLightShaftBloom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetEnableLightShaftBloom(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetEnableLightShaftBloom");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetEnableLightShaftBloom");

	UEngine_LightComponent_SetEnableLightShaftBloom_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetBloomTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                  NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetBloomTint(const struct FColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomTint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomTint");

	UEngine_LightComponent_SetBloomTint_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetBloomThreshold
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetBloomThreshold(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomThreshold");

	UEngine_LightComponent_SetBloomThreshold_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetBloomScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetBloomScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomScale");

	UEngine_LightComponent_SetBloomScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetBloomMaxBrightness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetBloomMaxBrightness(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomMaxBrightness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomMaxBrightness");

	UEngine_LightComponent_SetBloomMaxBrightness_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetAffectTranslucentLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetAffectTranslucentLighting(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectTranslucentLighting");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectTranslucentLighting");

	UEngine_LightComponent_SetAffectTranslucentLighting_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LightComponent.SetAffectDynamicIndirectLighting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LightComponent::SetAffectDynamicIndirectLighting(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectDynamicIndirectLighting");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectDynamicIndirectLighting");

	UEngine_LightComponent_SetAffectDynamicIndirectLighting_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetShadowDistanceFadeoutFraction(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction");

	UEngine_DirectionalLightComponent_SetShadowDistanceFadeoutFraction_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetShadowAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetShadowAmount(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowAmount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowAmount");

	UEngine_DirectionalLightComponent_SetShadowAmount_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetOcclusionMaskDarkness(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness");

	UEngine_DirectionalLightComponent_SetOcclusionMaskDarkness_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetLightShaftOverrideDirection(const struct FVector& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection");

	UEngine_DirectionalLightComponent_SetLightShaftOverrideDirection_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetEnableLightShaftOcclusion(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion");

	UEngine_DirectionalLightComponent_SetEnableLightShaftOcclusion_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetDynamicShadowDistanceStationaryLight(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight");

	UEngine_DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetDynamicShadowDistanceMovableLight(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight");

	UEngine_DirectionalLightComponent_SetDynamicShadowDistanceMovableLight_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetDynamicShadowCascades
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetDynamicShadowCascades(int NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowCascades");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowCascades");

	UEngine_DirectionalLightComponent_SetDynamicShadowCascades_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetCascadeTransitionFraction(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction");

	UEngine_DirectionalLightComponent_SetCascadeTransitionFraction_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_DirectionalLightComponent::SetCascadeDistributionExponent(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent");

	UEngine_DirectionalLightComponent_SetCascadeDistributionExponent_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SphereComponent.SetSphereRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InSphereRadius                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateOverlaps                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SphereComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.SetSphereRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.SetSphereRadius");

	UEngine_SphereComponent_SetSphereRadius_Params params;
	params.InSphereRadius = InSphereRadius;
	params.bUpdateOverlaps = bUpdateOverlaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SphereComponent.GetUnscaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SphereComponent::GetUnscaledSphereRadius()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetUnscaledSphereRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetUnscaledSphereRadius");

	UEngine_SphereComponent_GetUnscaledSphereRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SphereComponent.GetShapeScale
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SphereComponent::GetShapeScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetShapeScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetShapeScale");

	UEngine_SphereComponent_GetShapeScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SphereComponent.GetScaledSphereRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SphereComponent::GetScaledSphereRadius()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetScaledSphereRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetScaledSphereRadius");

	UEngine_SphereComponent_GetScaledSphereRadius_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Emitter.ToggleActive
// (Final, Native, Public, BlueprintCallable)

void AEngine_Emitter::ToggleActive()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ToggleActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ToggleActive");

	AEngine_Emitter_ToggleActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetVectorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Param                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Emitter::SetVectorParameter(const struct FName& ParameterName, const struct FVector& Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetVectorParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetVectorParameter");

	AEngine_Emitter_SetVectorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetTemplate
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ParticleSystem*  NewTemplate                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Emitter::SetTemplate(class UEngine_ParticleSystem* NewTemplate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetTemplate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetTemplate");

	AEngine_Emitter_SetTemplate_Params params;
	params.NewTemplate = NewTemplate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetMaterialParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* Param                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Emitter::SetMaterialParameter(const struct FName& ParameterName, class UEngine_MaterialInterface* Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetMaterialParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetMaterialParameter");

	AEngine_Emitter_SetMaterialParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetFloatParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          Param                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Emitter::SetFloatParameter(const struct FName& ParameterName, float Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetFloatParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetFloatParameter");

	AEngine_Emitter_SetFloatParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetColorParameter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Param                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Emitter::SetColorParameter(const struct FName& ParameterName, const struct FLinearColor& Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetColorParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetColorParameter");

	AEngine_Emitter_SetColorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.SetActorParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_Actor*           Param                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_Emitter::SetActorParameter(const struct FName& ParameterName, class AEngine_Actor* Param)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetActorParameter");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetActorParameter");

	AEngine_Emitter_SetActorParameter_Params params;
	params.ParameterName = ParameterName;
	params.Param = Param;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.OnRep_bCurrentlyActive
// (Native, Public)

void AEngine_Emitter::OnRep_bCurrentlyActive()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnRep_bCurrentlyActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnRep_bCurrentlyActive");

	AEngine_Emitter_OnRep_bCurrentlyActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.OnParticleSystemFinished
// (Native, Public)
// Parameters:
// class UEngine_ParticleSystemComponent* finishedComponent              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void AEngine_Emitter::OnParticleSystemFinished(class UEngine_ParticleSystemComponent* finishedComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnParticleSystemFinished");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnParticleSystemFinished");

	AEngine_Emitter_OnParticleSystemFinished_Params params;
	params.finishedComponent = finishedComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool AEngine_Emitter::IsActive()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.IsActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.IsActive");

	AEngine_Emitter_IsActive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Emitter.Deactivate
// (Final, Native, Public, BlueprintCallable)

void AEngine_Emitter::Deactivate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Deactivate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Deactivate");

	AEngine_Emitter_Deactivate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Emitter.Activate
// (Final, Native, Public, BlueprintCallable)

void AEngine_Emitter::Activate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Activate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Activate");

	AEngine_Emitter_Activate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogScatteringDistribution
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetVolumetricFogScatteringDistribution(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogScatteringDistribution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogScatteringDistribution");

	UEngine_ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogExtinctionScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetVolumetricFogExtinctionScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogExtinctionScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogExtinctionScale");

	UEngine_ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogEmissive
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetVolumetricFogEmissive(const struct FLinearColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogEmissive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogEmissive");

	UEngine_ExponentialHeightFogComponent_SetVolumetricFogEmissive_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetVolumetricFogDistance(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogDistance");

	UEngine_ExponentialHeightFogComponent_SetVolumetricFogDistance_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogAlbedo
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                  NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetVolumetricFogAlbedo(const struct FColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogAlbedo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFogAlbedo");

	UEngine_ExponentialHeightFogComponent_SetVolumetricFogAlbedo_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetVolumetricFog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetVolumetricFog(bool bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFog");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetVolumetricFog");

	UEngine_ExponentialHeightFogComponent_SetVolumetricFog_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetStartDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetStartDistance(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetStartDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetStartDistance");

	UEngine_ExponentialHeightFogComponent_SetStartDistance_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetNonDirectionalInscatteringColorDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetNonDirectionalInscatteringColorDistance(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetNonDirectionalInscatteringColorDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetNonDirectionalInscatteringColorDistance");

	UEngine_ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringTextureTint
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetInscatteringTextureTint(const struct FLinearColor& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringTextureTint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringTextureTint");

	UEngine_ExponentialHeightFogComponent_SetInscatteringTextureTint_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemapAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetInscatteringColorCubemapAngle(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemapAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemapAngle");

	UEngine_ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_TextureCube*     Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetInscatteringColorCubemap(class UEngine_TextureCube* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemap");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemap");

	UEngine_ExponentialHeightFogComponent_SetInscatteringColorCubemap_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetFullyDirectionalInscatteringColorDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetFullyDirectionalInscatteringColorDistance(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFullyDirectionalInscatteringColorDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFullyDirectionalInscatteringColorDistance");

	UEngine_ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetFogMaxOpacity(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity");

	UEngine_ExponentialHeightFogComponent_SetFogMaxOpacity_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetFogInscatteringColor(const struct FLinearColor& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor");

	UEngine_ExponentialHeightFogComponent_SetFogInscatteringColor_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetFogHeightFalloff(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff");

	UEngine_ExponentialHeightFogComponent_SetFogHeightFalloff_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetFogDensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetFogDensity(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogDensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogDensity");

	UEngine_ExponentialHeightFogComponent_SetFogDensity_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetFogCutoffDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetFogCutoffDistance(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogCutoffDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogCutoffDistance");

	UEngine_ExponentialHeightFogComponent_SetFogCutoffDistance_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetDirectionalInscatteringStartDistance(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance");

	UEngine_ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetDirectionalInscatteringExponent(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent");

	UEngine_ExponentialHeightFogComponent_SetDirectionalInscatteringExponent_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ExponentialHeightFogComponent::SetDirectionalInscatteringColor(const struct FLinearColor& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor");

	UEngine_ExponentialHeightFogComponent_SetDirectionalInscatteringColor_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.Exporter.ScriptRunAssetExportTask
// (Event, Public, BlueprintEvent)
// Parameters:
// class UEngine_AssetExportTask* Task                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_Exporter::ScriptRunAssetExportTask(class UEngine_AssetExportTask* Task)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Exporter.ScriptRunAssetExportTask");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Exporter.ScriptRunAssetExportTask");

	UEngine_Exporter_ScriptRunAssetExportTask_Params params;
	params.Task = Task;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Exporter.RunAssetExportTasks
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<class UEngine_AssetExportTask*> ExportTasks                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_Exporter::STATIC_RunAssetExportTasks(TArray<class UEngine_AssetExportTask*> ExportTasks)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Exporter.RunAssetExportTasks");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Exporter.RunAssetExportTasks");

	UEngine_Exporter_RunAssetExportTasks_Params params;
	params.ExportTasks = ExportTasks;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.Exporter.RunAssetExportTask
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_AssetExportTask* Task                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_Exporter::STATIC_RunAssetExportTask(class UEngine_AssetExportTask* Task)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.Exporter.RunAssetExportTask");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.Exporter.RunAssetExportTask");

	UEngine_Exporter_RunAssetExportTask_Params params;
	params.Task = Task;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ExponentialHeightFog.OnRep_bEnabled
// (Native, Public)

void AEngine_ExponentialHeightFog::OnRep_bEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFog.OnRep_bEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFog.OnRep_bEnabled");

	AEngine_ExponentialHeightFog_OnRep_bEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.ValidateSettings
// (Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::ValidateSettings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ValidateSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ValidateSettings");

	UEngine_GameUserSettings_ValidateSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SupportsHDRDisplayOutput
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::SupportsHDRDisplayOutput()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SupportsHDRDisplayOutput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SupportsHDRDisplayOutput");

	UEngine_GameUserSettings_SupportsHDRDisplayOutput_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.SetVSyncEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetVSyncEnabled(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetVSyncEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetVSyncEnabled");

	UEngine_GameUserSettings_SetVSyncEnabled_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetVisualEffectQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetVisualEffectQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetVisualEffectQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetVisualEffectQuality");

	UEngine_GameUserSettings_SetVisualEffectQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetViewDistanceQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetViewDistanceQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetViewDistanceQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetViewDistanceQuality");

	UEngine_GameUserSettings_SetViewDistanceQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetToDefaults
// (Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::SetToDefaults()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetToDefaults");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetToDefaults");

	UEngine_GameUserSettings_SetToDefaults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetTextureQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetTextureQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetTextureQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetTextureQuality");

	UEngine_GameUserSettings_SetTextureQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetShadowQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetShadowQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetShadowQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetShadowQuality");

	UEngine_GameUserSettings_SetShadowQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetShadingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetShadingQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetShadingQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetShadingQuality");

	UEngine_GameUserSettings_SetShadingQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint               Resolution                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetScreenResolution(const struct FIntPoint& Resolution)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetScreenResolution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetScreenResolution");

	UEngine_GameUserSettings_SetScreenResolution_Params params;
	params.Resolution = Resolution;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetResolutionScaleValueEx
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewScaleValue                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetResolutionScaleValueEx(float NewScaleValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleValueEx");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleValueEx");

	UEngine_GameUserSettings_SetResolutionScaleValueEx_Params params;
	params.NewScaleValue = NewScaleValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetResolutionScaleValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            NewScaleValue                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetResolutionScaleValue(int NewScaleValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleValue");

	UEngine_GameUserSettings_SetResolutionScaleValue_Params params;
	params.NewScaleValue = NewScaleValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetResolutionScaleNormalized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewScaleNormalized             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetResolutionScaleNormalized(float NewScaleNormalized)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleNormalized");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetResolutionScaleNormalized");

	UEngine_GameUserSettings_SetResolutionScaleNormalized_Params params;
	params.NewScaleNormalized = NewScaleNormalized;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetPostProcessingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetPostProcessingQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetPostProcessingQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetPostProcessingQuality");

	UEngine_GameUserSettings_SetPostProcessingQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetOverallScalabilityLevel
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetOverallScalabilityLevel(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetOverallScalabilityLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetOverallScalabilityLevel");

	UEngine_GameUserSettings_SetOverallScalabilityLevel_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetFullscreenMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EWindowMode> InFullscreenMode               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetFullscreenMode(TEnumAsByte<FEngine_Engine_EWindowMode> InFullscreenMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFullscreenMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFullscreenMode");

	UEngine_GameUserSettings_SetFullscreenMode_Params params;
	params.InFullscreenMode = InFullscreenMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetFrameRateLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLimit                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetFrameRateLimit(float NewLimit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFrameRateLimit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFrameRateLimit");

	UEngine_GameUserSettings_SetFrameRateLimit_Params params;
	params.NewLimit = NewLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetFoliageQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetFoliageQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFoliageQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetFoliageQuality");

	UEngine_GameUserSettings_SetFoliageQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetDynamicResolutionEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetDynamicResolutionEnabled(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetDynamicResolutionEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetDynamicResolutionEnabled");

	UEngine_GameUserSettings_SetDynamicResolutionEnabled_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetBenchmarkFallbackValues
// (Final, Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::SetBenchmarkFallbackValues()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetBenchmarkFallbackValues");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetBenchmarkFallbackValues");

	UEngine_GameUserSettings_SetBenchmarkFallbackValues_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetAudioQualityLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            QualityLevel                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetAudioQualityLevel(int QualityLevel)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetAudioQualityLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetAudioQualityLevel");

	UEngine_GameUserSettings_SetAudioQualityLevel_Params params;
	params.QualityLevel = QualityLevel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::SetAntiAliasingQuality(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetAntiAliasingQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SetAntiAliasingQuality");

	UEngine_GameUserSettings_SetAntiAliasingQuality_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.SaveSettings
// (Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::SaveSettings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SaveSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SaveSettings");

	UEngine_GameUserSettings_SaveSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.RunHardwareBenchmark
// (Native, Public, BlueprintCallable)
// Parameters:
// int                            WorkScale                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          CPUMultiplier                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          GPUMultiplier                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::RunHardwareBenchmark(int WorkScale, float CPUMultiplier, float GPUMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.RunHardwareBenchmark");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.RunHardwareBenchmark");

	UEngine_GameUserSettings_RunHardwareBenchmark_Params params;
	params.WorkScale = WorkScale;
	params.CPUMultiplier = CPUMultiplier;
	params.GPUMultiplier = GPUMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.RevertVideoMode
// (Final, Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::RevertVideoMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.RevertVideoMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.RevertVideoMode");

	UEngine_GameUserSettings_RevertVideoMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.ResetToCurrentSettings
// (Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::ResetToCurrentSettings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ResetToCurrentSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ResetToCurrentSettings");

	UEngine_GameUserSettings_ResetToCurrentSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.LoadSettings
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bForceReload                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::LoadSettings(bool bForceReload)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.LoadSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.LoadSettings");

	UEngine_GameUserSettings_LoadSettings_Params params;
	params.bForceReload = bForceReload;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.IsVSyncEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsVSyncEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsVSyncEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsVSyncEnabled");

	UEngine_GameUserSettings_IsVSyncEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.IsVSyncDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsVSyncDirty()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsVSyncDirty");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsVSyncDirty");

	UEngine_GameUserSettings_IsVSyncDirty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.IsScreenResolutionDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsScreenResolutionDirty()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsScreenResolutionDirty");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsScreenResolutionDirty");

	UEngine_GameUserSettings_IsScreenResolutionDirty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.IsHDREnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsHDREnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsHDREnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsHDREnabled");

	UEngine_GameUserSettings_IsHDREnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.IsFullscreenModeDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsFullscreenModeDirty()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsFullscreenModeDirty");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsFullscreenModeDirty");

	UEngine_GameUserSettings_IsFullscreenModeDirty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.IsDynamicResolutionEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsDynamicResolutionEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDynamicResolutionEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDynamicResolutionEnabled");

	UEngine_GameUserSettings_IsDynamicResolutionEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.IsDynamicResolutionDirty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsDynamicResolutionDirty()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDynamicResolutionDirty");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDynamicResolutionDirty");

	UEngine_GameUserSettings_IsDynamicResolutionDirty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.IsDirty
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_GameUserSettings::IsDirty()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDirty");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.IsDirty");

	UEngine_GameUserSettings_IsDirty_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetVisualEffectQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetVisualEffectQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetVisualEffectQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetVisualEffectQuality");

	UEngine_GameUserSettings_GetVisualEffectQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetViewDistanceQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetViewDistanceQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetViewDistanceQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetViewDistanceQuality");

	UEngine_GameUserSettings_GetViewDistanceQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetTextureQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetTextureQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetTextureQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetTextureQuality");

	UEngine_GameUserSettings_GetTextureQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetSyncInterval
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::STATIC_GetSyncInterval()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetSyncInterval");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetSyncInterval");

	UEngine_GameUserSettings_GetSyncInterval_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetShadowQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetShadowQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetShadowQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetShadowQuality");

	UEngine_GameUserSettings_GetShadowQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetShadingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetShadingQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetShadingQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetShadingQuality");

	UEngine_GameUserSettings_GetShadingQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntPoint UEngine_GameUserSettings::GetScreenResolution()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetScreenResolution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetScreenResolution");

	UEngine_GameUserSettings_GetScreenResolution_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetResolutionScaleNormalized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameUserSettings::GetResolutionScaleNormalized()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleNormalized");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleNormalized");

	UEngine_GameUserSettings_GetResolutionScaleNormalized_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetResolutionScaleInformationEx
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CurrentScaleNormalized         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          CurrentScaleValue              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          MinScaleValue                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          MaxScaleValue                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::GetResolutionScaleInformationEx(float* CurrentScaleNormalized, float* CurrentScaleValue, float* MinScaleValue, float* MaxScaleValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleInformationEx");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleInformationEx");

	UEngine_GameUserSettings_GetResolutionScaleInformationEx_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CurrentScaleNormalized != nullptr)
		*CurrentScaleNormalized = params.CurrentScaleNormalized;
	if (CurrentScaleValue != nullptr)
		*CurrentScaleValue = params.CurrentScaleValue;
	if (MinScaleValue != nullptr)
		*MinScaleValue = params.MinScaleValue;
	if (MaxScaleValue != nullptr)
		*MaxScaleValue = params.MaxScaleValue;
}


// Function Engine.GameUserSettings.GetResolutionScaleInformation
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          CurrentScaleNormalized         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            CurrentScaleValue              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            MinScaleValue                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            MaxScaleValue                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::GetResolutionScaleInformation(float* CurrentScaleNormalized, int* CurrentScaleValue, int* MinScaleValue, int* MaxScaleValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleInformation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetResolutionScaleInformation");

	UEngine_GameUserSettings_GetResolutionScaleInformation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (CurrentScaleNormalized != nullptr)
		*CurrentScaleNormalized = params.CurrentScaleNormalized;
	if (CurrentScaleValue != nullptr)
		*CurrentScaleValue = params.CurrentScaleValue;
	if (MinScaleValue != nullptr)
		*MinScaleValue = params.MinScaleValue;
	if (MaxScaleValue != nullptr)
		*MaxScaleValue = params.MaxScaleValue;
}


// Function Engine.GameUserSettings.GetRecommendedResolutionScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameUserSettings::GetRecommendedResolutionScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetRecommendedResolutionScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetRecommendedResolutionScale");

	UEngine_GameUserSettings_GetRecommendedResolutionScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetPreferredFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_EWindowMode> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_EWindowMode> UEngine_GameUserSettings::GetPreferredFullscreenMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetPreferredFullscreenMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetPreferredFullscreenMode");

	UEngine_GameUserSettings_GetPreferredFullscreenMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetPostProcessingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetPostProcessingQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetPostProcessingQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetPostProcessingQuality");

	UEngine_GameUserSettings_GetPostProcessingQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetOverallScalabilityLevel
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetOverallScalabilityLevel()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetOverallScalabilityLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetOverallScalabilityLevel");

	UEngine_GameUserSettings_GetOverallScalabilityLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetLastConfirmedScreenResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntPoint UEngine_GameUserSettings::GetLastConfirmedScreenResolution()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetLastConfirmedScreenResolution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetLastConfirmedScreenResolution");

	UEngine_GameUserSettings_GetLastConfirmedScreenResolution_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_EWindowMode> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_EWindowMode> UEngine_GameUserSettings::GetLastConfirmedFullscreenMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode");

	UEngine_GameUserSettings_GetLastConfirmedFullscreenMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_GameUserSettings* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_GameUserSettings* UEngine_GameUserSettings::STATIC_GetGameUserSettings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetGameUserSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetGameUserSettings");

	UEngine_GameUserSettings_GetGameUserSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetFullscreenMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_EWindowMode> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_EWindowMode> UEngine_GameUserSettings::GetFullscreenMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFullscreenMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFullscreenMode");

	UEngine_GameUserSettings_GetFullscreenMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetFrameRateLimit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameUserSettings::GetFrameRateLimit()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFrameRateLimit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFrameRateLimit");

	UEngine_GameUserSettings_GetFrameRateLimit_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetFoliageQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetFoliageQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFoliageQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetFoliageQuality");

	UEngine_GameUserSettings_GetFoliageQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetDesktopResolution
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FIntPoint               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntPoint UEngine_GameUserSettings::GetDesktopResolution()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDesktopResolution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDesktopResolution");

	UEngine_GameUserSettings_GetDesktopResolution_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetDefaultWindowPosition
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntPoint UEngine_GameUserSettings::STATIC_GetDefaultWindowPosition()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultWindowPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultWindowPosition");

	UEngine_GameUserSettings_GetDefaultWindowPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetDefaultWindowMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EWindowMode> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_EWindowMode> UEngine_GameUserSettings::STATIC_GetDefaultWindowMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultWindowMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultWindowMode");

	UEngine_GameUserSettings_GetDefaultWindowMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetDefaultResolutionScale
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_GameUserSettings::GetDefaultResolutionScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultResolutionScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultResolutionScale");

	UEngine_GameUserSettings_GetDefaultResolutionScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetDefaultResolution
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FIntPoint               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntPoint UEngine_GameUserSettings::STATIC_GetDefaultResolution()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultResolution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetDefaultResolution");

	UEngine_GameUserSettings_GetDefaultResolution_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetCurrentHDRDisplayNits
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetCurrentHDRDisplayNits()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetCurrentHDRDisplayNits");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetCurrentHDRDisplayNits");

	UEngine_GameUserSettings_GetCurrentHDRDisplayNits_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetAudioQualityLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetAudioQualityLevel()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetAudioQualityLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetAudioQualityLevel");

	UEngine_GameUserSettings_GetAudioQualityLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.GetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_GameUserSettings::GetAntiAliasingQuality()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetAntiAliasingQuality");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.GetAntiAliasingQuality");

	UEngine_GameUserSettings_GetAntiAliasingQuality_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.GameUserSettings.EnableHDRDisplayOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            DisplayNits                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::EnableHDRDisplayOutput(bool bEnable, int DisplayNits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.EnableHDRDisplayOutput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.EnableHDRDisplayOutput");

	UEngine_GameUserSettings_EnableHDRDisplayOutput_Params params;
	params.bEnable = bEnable;
	params.DisplayNits = DisplayNits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.ConfirmVideoMode
// (Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::ConfirmVideoMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ConfirmVideoMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ConfirmVideoMode");

	UEngine_GameUserSettings_ConfirmVideoMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.ApplySettings
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bCheckForCommandLineOverrides  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::ApplySettings(bool bCheckForCommandLineOverrides)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplySettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplySettings");

	UEngine_GameUserSettings_ApplySettings_Params params;
	params.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.ApplyResolutionSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bCheckForCommandLineOverrides  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_GameUserSettings::ApplyResolutionSettings(bool bCheckForCommandLineOverrides)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyResolutionSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyResolutionSettings");

	UEngine_GameUserSettings_ApplyResolutionSettings_Params params;
	params.bCheckForCommandLineOverrides = bCheckForCommandLineOverrides;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.ApplyNonResolutionSettings
// (Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::ApplyNonResolutionSettings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyNonResolutionSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyNonResolutionSettings");

	UEngine_GameUserSettings_ApplyNonResolutionSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.GameUserSettings.ApplyHardwareBenchmarkResults
// (Native, Public, BlueprintCallable)

void UEngine_GameUserSettings::ApplyHardwareBenchmarkResults()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyHardwareBenchmarkResults");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.ApplyHardwareBenchmarkResults");

	UEngine_GameUserSettings_ApplyHardwareBenchmarkResults_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpotLight.SetOuterConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewOuterConeAngle              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_SpotLight::SetOuterConeAngle(float NewOuterConeAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetOuterConeAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetOuterConeAngle");

	AEngine_SpotLight_SetOuterConeAngle_Params params;
	params.NewOuterConeAngle = NewOuterConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpotLight.SetInnerConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewInnerConeAngle              (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_SpotLight::SetInnerConeAngle(float NewInnerConeAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetInnerConeAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetInnerConeAngle");

	AEngine_SpotLight_SetInnerConeAngle_Params params;
	params.NewInnerConeAngle = NewInnerConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFeedbackComponent.Stop
// (Native, Public, BlueprintCallable)

void UEngine_ForceFeedbackComponent::Stop()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.Stop");

	UEngine_ForceFeedbackComponent_Stop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFeedbackComponent.SetIntensityMultiplier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensityMultiplier         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ForceFeedbackComponent::SetIntensityMultiplier(float NewIntensityMultiplier)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.SetIntensityMultiplier");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.SetIntensityMultiplier");

	UEngine_ForceFeedbackComponent_SetIntensityMultiplier_Params params;
	params.NewIntensityMultiplier = NewIntensityMultiplier;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFeedbackComponent.SetForceFeedbackEffect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_ForceFeedbackEffect* NewForceFeedbackEffect         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ForceFeedbackComponent::SetForceFeedbackEffect(class UEngine_ForceFeedbackEffect* NewForceFeedbackEffect)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.SetForceFeedbackEffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.SetForceFeedbackEffect");

	UEngine_ForceFeedbackComponent_SetForceFeedbackEffect_Params params;
	params.NewForceFeedbackEffect = NewForceFeedbackEffect;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFeedbackComponent.Play
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          StartTime                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ForceFeedbackComponent::Play(float StartTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.Play");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.Play");

	UEngine_ForceFeedbackComponent_Play_Params params;
	params.StartTime = StartTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ForceFeedbackComponent.BP_GetAttenuationSettingsToApply
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEngine_ForceFeedbackAttenuationSettings OutAttenuationSettings         (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ForceFeedbackComponent::BP_GetAttenuationSettingsToApply(struct FEngine_ForceFeedbackAttenuationSettings* OutAttenuationSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.BP_GetAttenuationSettingsToApply");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.BP_GetAttenuationSettingsToApply");

	UEngine_ForceFeedbackComponent_BP_GetAttenuationSettingsToApply_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutAttenuationSettings != nullptr)
		*OutAttenuationSettings = params.OutAttenuationSettings;

	return params.ReturnValue;
}


// Function Engine.ForceFeedbackComponent.AdjustAttenuation
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_ForceFeedbackAttenuationSettings InAttenuationSettings          (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_ForceFeedbackComponent::AdjustAttenuation(const struct FEngine_ForceFeedbackAttenuationSettings& InAttenuationSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.AdjustAttenuation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ForceFeedbackComponent.AdjustAttenuation");

	UEngine_ForceFeedbackComponent_AdjustAttenuation_Params params;
	params.InAttenuationSettings = InAttenuationSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ImportanceSamplingLibrary.RandomSobolFloat
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Dimension                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Seed                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_ImportanceSamplingLibrary::STATIC_RandomSobolFloat(int Index, int Dimension, float Seed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolFloat");

	UEngine_ImportanceSamplingLibrary_RandomSobolFloat_Params params;
	params.Index = Index;
	params.Dimension = Dimension;
	params.Seed = Seed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.RandomSobolCell3D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumCells                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Cell                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Seed                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_ImportanceSamplingLibrary::STATIC_RandomSobolCell3D(int Index, int NumCells, const struct FVector& Cell, const struct FVector& Seed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolCell3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolCell3D");

	UEngine_ImportanceSamplingLibrary_RandomSobolCell3D_Params params;
	params.Index = Index;
	params.NumCells = NumCells;
	params.Cell = Cell;
	params.Seed = Seed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.RandomSobolCell2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumCells                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Cell                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Seed                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_ImportanceSamplingLibrary::STATIC_RandomSobolCell2D(int Index, int NumCells, const struct FVector2D& Cell, const struct FVector2D& Seed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolCell2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.RandomSobolCell2D");

	UEngine_ImportanceSamplingLibrary_RandomSobolCell2D_Params params;
	params.Index = Index;
	params.NumCells = NumCells;
	params.Cell = Cell;
	params.Seed = Seed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.NextSobolFloat
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Dimension                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          PreviousValue                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_ImportanceSamplingLibrary::STATIC_NextSobolFloat(int Index, int Dimension, float PreviousValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolFloat");

	UEngine_ImportanceSamplingLibrary_NextSobolFloat_Params params;
	params.Index = Index;
	params.Dimension = Dimension;
	params.PreviousValue = PreviousValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.NextSobolCell3D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumCells                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PreviousValue                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_ImportanceSamplingLibrary::STATIC_NextSobolCell3D(int Index, int NumCells, const struct FVector& PreviousValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolCell3D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolCell3D");

	UEngine_ImportanceSamplingLibrary_NextSobolCell3D_Params params;
	params.Index = Index;
	params.NumCells = NumCells;
	params.PreviousValue = PreviousValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.NextSobolCell2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumCells                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               PreviousValue                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_ImportanceSamplingLibrary::STATIC_NextSobolCell2D(int Index, int NumCells, const struct FVector2D& PreviousValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolCell2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.NextSobolCell2D");

	UEngine_ImportanceSamplingLibrary_NextSobolCell2D_Params params;
	params.Index = Index;
	params.NumCells = NumCells;
	params.PreviousValue = PreviousValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.MakeImportanceTexture
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEngine_Texture2D*       Texture                        (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EImportanceWeight> WeightingFunc                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_ImportanceTexture ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEngine_ImportanceTexture UEngine_ImportanceSamplingLibrary::STATIC_MakeImportanceTexture(class UEngine_Texture2D* Texture, TEnumAsByte<FEngine_Engine_EImportanceWeight> WeightingFunc)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.MakeImportanceTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.MakeImportanceTexture");

	UEngine_ImportanceSamplingLibrary_MakeImportanceTexture_Params params;
	params.Texture = Texture;
	params.WeightingFunc = WeightingFunc;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ImportanceSamplingLibrary.ImportanceSample
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_ImportanceTexture Texture                        (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector2D               Rand                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            Samples                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Intensity                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               SamplePosition                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            SampleColor                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          SampleIntensity                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          SampleSize                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_ImportanceSamplingLibrary::STATIC_ImportanceSample(const struct FEngine_ImportanceTexture& Texture, const struct FVector2D& Rand, int Samples, float Intensity, struct FVector2D* SamplePosition, struct FLinearColor* SampleColor, float* SampleIntensity, float* SampleSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.ImportanceSample");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.ImportanceSample");

	UEngine_ImportanceSamplingLibrary_ImportanceSample_Params params;
	params.Texture = Texture;
	params.Rand = Rand;
	params.Samples = Samples;
	params.Intensity = Intensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SamplePosition != nullptr)
		*SamplePosition = params.SamplePosition;
	if (SampleColor != nullptr)
		*SampleColor = params.SampleColor;
	if (SampleIntensity != nullptr)
		*SampleIntensity = params.SampleIntensity;
	if (SampleSize != nullptr)
		*SampleSize = params.SampleSize;
}


// Function Engine.ImportanceSamplingLibrary.BreakImportanceTexture
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_ImportanceTexture ImportanceTexture              (ConstParm, Parm, OutParm, ReferenceParm)
// class UEngine_Texture2D*       Texture                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EImportanceWeight> WeightingFunc                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_ImportanceSamplingLibrary::STATIC_BreakImportanceTexture(const struct FEngine_ImportanceTexture& ImportanceTexture, class UEngine_Texture2D** Texture, TEnumAsByte<FEngine_Engine_EImportanceWeight>* WeightingFunc)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.BreakImportanceTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ImportanceSamplingLibrary.BreakImportanceTexture");

	UEngine_ImportanceSamplingLibrary_BreakImportanceTexture_Params params;
	params.ImportanceTexture = ImportanceTexture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Texture != nullptr)
		*Texture = params.Texture;
	if (WeightingFunc != nullptr)
		*WeightingFunc = params.WeightingFunc;
}


// Function Engine.InputComponent.WasControllerKeyJustReleased
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InputComponent::WasControllerKeyJustReleased(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustReleased");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustReleased");

	UEngine_InputComponent_WasControllerKeyJustReleased_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InputComponent.WasControllerKeyJustPressed
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InputComponent::WasControllerKeyJustPressed(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustPressed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustPressed");

	UEngine_InputComponent_WasControllerKeyJustPressed_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InputComponent.IsControllerKeyDown
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_InputComponent::IsControllerKeyDown(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.IsControllerKeyDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.IsControllerKeyDown");

	UEngine_InputComponent_IsControllerKeyDown_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InputComponent.GetTouchState
// (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            FingerIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          LocationX                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          LocationY                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           bIsCurrentlyPressed            (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_InputComponent::GetTouchState(int FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetTouchState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetTouchState");

	UEngine_InputComponent_GetTouchState_Params params;
	params.FingerIndex = FingerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LocationX != nullptr)
		*LocationX = params.LocationX;
	if (LocationY != nullptr)
		*LocationY = params.LocationY;
	if (bIsCurrentlyPressed != nullptr)
		*bIsCurrentlyPressed = params.bIsCurrentlyPressed;
}


// Function Engine.InputComponent.GetControllerVectorKeyState
// (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_InputComponent::GetControllerVectorKeyState(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerVectorKeyState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerVectorKeyState");

	UEngine_InputComponent_GetControllerVectorKeyState_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InputComponent.GetControllerMouseDelta
// (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          DeltaX                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          DeltaY                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_InputComponent::GetControllerMouseDelta(float* DeltaX, float* DeltaY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerMouseDelta");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerMouseDelta");

	UEngine_InputComponent_GetControllerMouseDelta_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (DeltaX != nullptr)
		*DeltaX = params.DeltaX;
	if (DeltaY != nullptr)
		*DeltaY = params.DeltaY;
}


// Function Engine.InputComponent.GetControllerKeyTimeDown
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_InputComponent::GetControllerKeyTimeDown(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerKeyTimeDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerKeyTimeDown");

	UEngine_InputComponent_GetControllerKeyTimeDown_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InputComponent.GetControllerAnalogStickState
// (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_EControllerAnalogStick> WhichStick                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          StickX                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          StickY                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_InputComponent::GetControllerAnalogStickState(TEnumAsByte<FEngine_Engine_EControllerAnalogStick> WhichStick, float* StickX, float* StickY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogStickState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogStickState");

	UEngine_InputComponent_GetControllerAnalogStickState_Params params;
	params.WhichStick = WhichStick;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (StickX != nullptr)
		*StickX = params.StickX;
	if (StickY != nullptr)
		*StickY = params.StickY;
}


// Function Engine.InputComponent.GetControllerAnalogKeyState
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputCore_Key          Key                            (Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_InputComponent::GetControllerAnalogKeyState(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogKeyState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogKeyState");

	UEngine_InputComponent_GetControllerAnalogKeyState_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InputSettings.SaveKeyMappings
// (Final, Native, Public, BlueprintCallable)

void UEngine_InputSettings::SaveKeyMappings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.SaveKeyMappings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.SaveKeyMappings");

	UEngine_InputSettings_SaveKeyMappings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InputSettings.RemoveAxisMapping
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_InputAxisKeyMapping KeyMapping                     (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           bForceRebuildKeymaps           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InputSettings::RemoveAxisMapping(const struct FEngine_InputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.RemoveAxisMapping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.RemoveAxisMapping");

	UEngine_InputSettings_RemoveAxisMapping_Params params;
	params.KeyMapping = KeyMapping;
	params.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InputSettings.RemoveActionMapping
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_InputActionKeyMapping KeyMapping                     (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           bForceRebuildKeymaps           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InputSettings::RemoveActionMapping(const struct FEngine_InputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.RemoveActionMapping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.RemoveActionMapping");

	UEngine_InputSettings_RemoveActionMapping_Params params;
	params.KeyMapping = KeyMapping;
	params.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InputSettings.GetInputSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEngine_InputSettings*   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_InputSettings* UEngine_InputSettings::STATIC_GetInputSettings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetInputSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetInputSettings");

	UEngine_InputSettings_GetInputSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.InputSettings.GetAxisNames
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FName>           AxisNames                      (Parm, OutParm, ZeroConstructor)

void UEngine_InputSettings::GetAxisNames(TArray<struct FName>* AxisNames)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetAxisNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetAxisNames");

	UEngine_InputSettings_GetAxisNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (AxisNames != nullptr)
		*AxisNames = params.AxisNames;
}


// Function Engine.InputSettings.GetAxisMappingByName
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InAxisName                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_InputAxisKeyMapping> OutMappings                    (Parm, OutParm, ZeroConstructor)

void UEngine_InputSettings::GetAxisMappingByName(const struct FName& InAxisName, TArray<struct FEngine_InputAxisKeyMapping>* OutMappings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetAxisMappingByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetAxisMappingByName");

	UEngine_InputSettings_GetAxisMappingByName_Params params;
	params.InAxisName = InAxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutMappings != nullptr)
		*OutMappings = params.OutMappings;
}


// Function Engine.InputSettings.GetActionNames
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FName>           ActionNames                    (Parm, OutParm, ZeroConstructor)

void UEngine_InputSettings::GetActionNames(TArray<struct FName>* ActionNames)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetActionNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetActionNames");

	UEngine_InputSettings_GetActionNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (ActionNames != nullptr)
		*ActionNames = params.ActionNames;
}


// Function Engine.InputSettings.GetActionMappingByName
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InActionName                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_InputActionKeyMapping> OutMappings                    (Parm, OutParm, ZeroConstructor)

void UEngine_InputSettings::GetActionMappingByName(const struct FName& InActionName, TArray<struct FEngine_InputActionKeyMapping>* OutMappings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetActionMappingByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.GetActionMappingByName");

	UEngine_InputSettings_GetActionMappingByName_Params params;
	params.InActionName = InActionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutMappings != nullptr)
		*OutMappings = params.OutMappings;
}


// Function Engine.InputSettings.ForceRebuildKeymaps
// (Final, Native, Public, BlueprintCallable)

void UEngine_InputSettings::ForceRebuildKeymaps()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.ForceRebuildKeymaps");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.ForceRebuildKeymaps");

	UEngine_InputSettings_ForceRebuildKeymaps_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InputSettings.AddAxisMapping
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_InputAxisKeyMapping KeyMapping                     (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           bForceRebuildKeymaps           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InputSettings::AddAxisMapping(const struct FEngine_InputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.AddAxisMapping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.AddAxisMapping");

	UEngine_InputSettings_AddAxisMapping_Params params;
	params.KeyMapping = KeyMapping;
	params.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InputSettings.AddActionMapping
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_InputActionKeyMapping KeyMapping                     (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           bForceRebuildKeymaps           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InputSettings::AddActionMapping(const struct FEngine_InputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.AddActionMapping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InputSettings.AddActionMapping");

	UEngine_InputSettings_AddActionMapping_Params params;
	params.KeyMapping = KeyMapping;
	params.bForceRebuildKeymaps = bForceRebuildKeymaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HealthSnapshotBlueprintLibrary.StopPerformanceSnapshots
// (Final, Exec, Native, Static, Public, BlueprintCallable)

void UEngine_HealthSnapshotBlueprintLibrary::STATIC_StopPerformanceSnapshots()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.StopPerformanceSnapshots");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.StopPerformanceSnapshots");

	UEngine_HealthSnapshotBlueprintLibrary_StopPerformanceSnapshots_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HealthSnapshotBlueprintLibrary.StartPerformanceSnapshots
// (Final, Exec, Native, Static, Public, BlueprintCallable)

void UEngine_HealthSnapshotBlueprintLibrary::STATIC_StartPerformanceSnapshots()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.StartPerformanceSnapshots");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.StartPerformanceSnapshots");

	UEngine_HealthSnapshotBlueprintLibrary_StartPerformanceSnapshots_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.HealthSnapshotBlueprintLibrary.LogPerformanceSnapshot
// (Final, Exec, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 SnapshotTitle                  (ConstParm, Parm, ZeroConstructor)
// bool                           bResetStats                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_HealthSnapshotBlueprintLibrary::STATIC_LogPerformanceSnapshot(const struct FString& SnapshotTitle, bool bResetStats)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.LogPerformanceSnapshot");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.HealthSnapshotBlueprintLibrary.LogPerformanceSnapshot");

	UEngine_HealthSnapshotBlueprintLibrary_LogPerformanceSnapshot_Params params;
	params.SnapshotTitle = SnapshotTitle;
	params.bResetStats = bResetStats;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpToMovementComponent.StopSimulating
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_HitResult       HitResult                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_InterpToMovementComponent::StopSimulating(const struct FEngine_HitResult& HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.StopSimulating");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.StopSimulating");

	UEngine_InterpToMovementComponent_StopSimulating_Params params;
	params.HitResult = HitResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpToMovementComponent.RestartMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InitialDirection               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InterpToMovementComponent::RestartMovement(float InitialDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.RestartMovement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.RestartMovement");

	UEngine_InterpToMovementComponent_RestartMovement_Params params;
	params.InitialDirection = InitialDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
// struct FEngine_HitResult       ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InterpToMovementComponent::OnInterpToWaitEndDelegate__DelegateSignature(const struct FEngine_HitResult& ImpactResult, float Time)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature");

	UEngine_InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature_Params params;
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
// struct FEngine_HitResult       ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InterpToMovementComponent::OnInterpToWaitBeginDelegate__DelegateSignature(const struct FEngine_HitResult& ImpactResult, float Time)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature");

	UEngine_InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature_Params params;
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
// struct FEngine_HitResult       ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InterpToMovementComponent::OnInterpToStopDelegate__DelegateSignature(const struct FEngine_HitResult& ImpactResult, float Time)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature");

	UEngine_InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature_Params params;
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
// struct FEngine_HitResult       ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InterpToMovementComponent::OnInterpToReverseDelegate__DelegateSignature(const struct FEngine_HitResult& ImpactResult, float Time)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature");

	UEngine_InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature_Params params;
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
// struct FEngine_HitResult       ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_InterpToMovementComponent::OnInterpToResetDelegate__DelegateSignature(const struct FEngine_HitResult& ImpactResult, float Time)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature");

	UEngine_InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature_Params params;
	params.ImpactResult = ImpactResult;
	params.Time = Time;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.InterpToMovementComponent.FinaliseControlPoints
// (Final, Native, Public, BlueprintCallable)

void UEngine_InterpToMovementComponent::FinaliseControlPoints()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.FinaliseControlPoints");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.InterpToMovementComponent.FinaliseControlPoints");

	UEngine_InterpToMovementComponent_FinaliseControlPoints_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.SetArrayPropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// TArray<int>                    Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetArrayLibrary::STATIC_SetArrayPropertyByName(class UObject* Object, const struct FName& PropertyName, TArray<int> Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.SetArrayPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.SetArrayPropertyByName");

	UEngine_KismetArrayLibrary_SetArrayPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.FilterArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<class AEngine_Actor*>   TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  FilterClass                    (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   FilteredArray                  (Parm, OutParm, ZeroConstructor)

void UEngine_KismetArrayLibrary::STATIC_FilterArray(TArray<class AEngine_Actor*> TargetArray, class UClass* FilterClass, TArray<class AEngine_Actor*>* FilteredArray)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.FilterArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.FilterArray");

	UEngine_KismetArrayLibrary_FilterArray_Params params;
	params.TargetArray = TargetArray;
	params.FilterClass = FilterClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (FilteredArray != nullptr)
		*FilteredArray = params.FilteredArray;
}


// Function Engine.KismetArrayLibrary.Array_Swap
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            FirstIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            SecondIndex                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetArrayLibrary::STATIC_Array_Swap(TArray<int> TargetArray, int FirstIndex, int SecondIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Swap");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Swap");

	UEngine_KismetArrayLibrary_Array_Swap_Params params;
	params.TargetArray = TargetArray;
	params.FirstIndex = FirstIndex;
	params.SecondIndex = SecondIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_Shuffle
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetArrayLibrary::STATIC_Array_Shuffle(TArray<int> TargetArray)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Shuffle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Shuffle");

	UEngine_KismetArrayLibrary_Array_Shuffle_Params params;
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_Set
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Item                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           bSizeToFit                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetArrayLibrary::STATIC_Array_Set(TArray<int> TargetArray, int Index, int Item, bool bSizeToFit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Set");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Set");

	UEngine_KismetArrayLibrary_Array_Set_Params params;
	params.TargetArray = TargetArray;
	params.Index = Index;
	params.Item = Item;
	params.bSizeToFit = bSizeToFit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_Resize
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Size                           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetArrayLibrary::STATIC_Array_Resize(TArray<int> TargetArray, int Size)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Resize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Resize");

	UEngine_KismetArrayLibrary_Array_Resize_Params params;
	params.TargetArray = TargetArray;
	params.Size = Size;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_RemoveItem
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Item                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetArrayLibrary::STATIC_Array_RemoveItem(TArray<int> TargetArray, int Item)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_RemoveItem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_RemoveItem");

	UEngine_KismetArrayLibrary_Array_RemoveItem_Params params;
	params.TargetArray = TargetArray;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Remove
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexToRemove                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetArrayLibrary::STATIC_Array_Remove(TArray<int> TargetArray, int IndexToRemove)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Remove");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Remove");

	UEngine_KismetArrayLibrary_Array_Remove_Params params;
	params.TargetArray = TargetArray;
	params.IndexToRemove = IndexToRemove;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_Length
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetArrayLibrary::STATIC_Array_Length(TArray<int> TargetArray)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Length");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Length");

	UEngine_KismetArrayLibrary_Array_Length_Params params;
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_LastIndex
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetArrayLibrary::STATIC_Array_LastIndex(TArray<int> TargetArray)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_LastIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_LastIndex");

	UEngine_KismetArrayLibrary_Array_LastIndex_Params params;
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_IsValidIndex
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexToTest                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetArrayLibrary::STATIC_Array_IsValidIndex(TArray<int> TargetArray, int IndexToTest)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_IsValidIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_IsValidIndex");

	UEngine_KismetArrayLibrary_Array_IsValidIndex_Params params;
	params.TargetArray = TargetArray;
	params.IndexToTest = IndexToTest;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Insert
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            NewItem                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetArrayLibrary::STATIC_Array_Insert(TArray<int> TargetArray, int NewItem, int Index)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Insert");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Insert");

	UEngine_KismetArrayLibrary_Array_Insert_Params params;
	params.TargetArray = TargetArray;
	params.NewItem = NewItem;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_Identical
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    ArrayA                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<int>                    ArrayB                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetArrayLibrary::STATIC_Array_Identical(TArray<int> ArrayA, TArray<int> ArrayB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Identical");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Identical");

	UEngine_KismetArrayLibrary_Array_Identical_Params params;
	params.ArrayA = ArrayA;
	params.ArrayB = ArrayB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Get
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Item                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetArrayLibrary::STATIC_Array_Get(TArray<int> TargetArray, int Index, int* Item)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Get");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Get");

	UEngine_KismetArrayLibrary_Array_Get_Params params;
	params.TargetArray = TargetArray;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Item != nullptr)
		*Item = params.Item;
}


// Function Engine.KismetArrayLibrary.Array_Find
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            ItemToFind                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetArrayLibrary::STATIC_Array_Find(TArray<int> TargetArray, int ItemToFind)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Find");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Find");

	UEngine_KismetArrayLibrary_Array_Find_Params params;
	params.TargetArray = TargetArray;
	params.ItemToFind = ItemToFind;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Contains
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            ItemToFind                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetArrayLibrary::STATIC_Array_Contains(TArray<int> TargetArray, int ItemToFind)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Contains");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Contains");

	UEngine_KismetArrayLibrary_Array_Contains_Params params;
	params.TargetArray = TargetArray;
	params.ItemToFind = ItemToFind;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Clear
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetArrayLibrary::STATIC_Array_Clear(TArray<int> TargetArray)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Clear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Clear");

	UEngine_KismetArrayLibrary_Array_Clear_Params params;
	params.TargetArray = TargetArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_Append
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<int>                    SourceArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetArrayLibrary::STATIC_Array_Append(TArray<int> TargetArray, TArray<int> SourceArray)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Append");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Append");

	UEngine_KismetArrayLibrary_Array_Append_Params params;
	params.TargetArray = TargetArray;
	params.SourceArray = SourceArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetArrayLibrary.Array_AddUnique
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            NewItem                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetArrayLibrary::STATIC_Array_AddUnique(TArray<int> TargetArray, int NewItem)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_AddUnique");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_AddUnique");

	UEngine_KismetArrayLibrary_Array_AddUnique_Params params;
	params.TargetArray = TargetArray;
	params.NewItem = NewItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetArrayLibrary.Array_Add
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<int>                    TargetArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            NewItem                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetArrayLibrary::STATIC_Array_Add(TArray<int> TargetArray, int NewItem)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Add");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Add");

	UEngine_KismetArrayLibrary_Array_Add_Params params;
	params.TargetArray = TargetArray;
	params.NewItem = NewItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_PointerEvent_IsTouchEvent(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent");

	UEngine_KismetInputLibrary_PointerEvent_IsTouchEvent_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FInputCore_Key          MouseButton                    (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_PointerEvent_IsMouseButtonDown(const struct FSlateCore_PointerEvent& Input, const struct FInputCore_Key& MouseButton)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown");

	UEngine_KismetInputLibrary_PointerEvent_IsMouseButtonDown_Params params;
	params.Input = Input;
	params.MouseButton = MouseButton;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetInputLibrary::STATIC_PointerEvent_GetWheelDelta(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta");

	UEngine_KismetInputLibrary_PointerEvent_GetWheelDelta_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetInputLibrary::STATIC_PointerEvent_GetUserIndex(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex");

	UEngine_KismetInputLibrary_PointerEvent_GetUserIndex_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetInputLibrary::STATIC_PointerEvent_GetTouchpadIndex(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex");

	UEngine_KismetInputLibrary_PointerEvent_GetTouchpadIndex_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetInputLibrary::STATIC_PointerEvent_GetScreenSpacePosition(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition");

	UEngine_KismetInputLibrary_PointerEvent_GetScreenSpacePosition_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetInputLibrary::STATIC_PointerEvent_GetPointerIndex(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex");

	UEngine_KismetInputLibrary_PointerEvent_GetPointerIndex_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetInputLibrary::STATIC_PointerEvent_GetLastScreenSpacePosition(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition");

	UEngine_KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetGestureType
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// FEngine_Engine_ESlateGesture   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FEngine_Engine_ESlateGesture UEngine_KismetInputLibrary::STATIC_PointerEvent_GetGestureType(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureType");

	UEngine_KismetInputLibrary_PointerEvent_GetGestureType_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetInputLibrary::STATIC_PointerEvent_GetGestureDelta(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta");

	UEngine_KismetInputLibrary_PointerEvent_GetGestureDelta_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FInputCore_Key          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FInputCore_Key UEngine_KismetInputLibrary::STATIC_PointerEvent_GetEffectingButton(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton");

	UEngine_KismetInputLibrary_PointerEvent_GetEffectingButton_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_PointerEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetInputLibrary::STATIC_PointerEvent_GetCursorDelta(const struct FSlateCore_PointerEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta");

	UEngine_KismetInputLibrary_PointerEvent_GetCursorDelta_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsVectorAxis
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_Key_IsVectorAxis(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsVectorAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsVectorAxis");

	UEngine_KismetInputLibrary_Key_IsVectorAxis_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsValid
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_Key_IsValid(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsValid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsValid");

	UEngine_KismetInputLibrary_Key_IsValid_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsMouseButton
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_Key_IsMouseButton(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsMouseButton");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsMouseButton");

	UEngine_KismetInputLibrary_Key_IsMouseButton_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsModifierKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_Key_IsModifierKey(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsModifierKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsModifierKey");

	UEngine_KismetInputLibrary_Key_IsModifierKey_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsKeyboardKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_Key_IsKeyboardKey(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsKeyboardKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsKeyboardKey");

	UEngine_KismetInputLibrary_Key_IsKeyboardKey_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsGamepadKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_Key_IsGamepadKey(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsGamepadKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsGamepadKey");

	UEngine_KismetInputLibrary_Key_IsGamepadKey_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_IsFloatAxis
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_Key_IsFloatAxis(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsFloatAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_IsFloatAxis");

	UEngine_KismetInputLibrary_Key_IsFloatAxis_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_KeyEvent     InKeyEvent                     (ConstParm, Parm, OutParm, ReferenceParm)
// FSlateCore_SlateCore_EUINavigation ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FSlateCore_SlateCore_EUINavigation UEngine_KismetInputLibrary::STATIC_Key_GetNavigationDirectionFromKey(const struct FSlateCore_KeyEvent& InKeyEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromKey");

	UEngine_KismetInputLibrary_Key_GetNavigationDirectionFromKey_Params params;
	params.InKeyEvent = InKeyEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromAnalog
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_AnalogInputEvent InAnalogEvent                  (ConstParm, Parm, OutParm, ReferenceParm)
// FSlateCore_SlateCore_EUINavigation ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FSlateCore_SlateCore_EUINavigation UEngine_KismetInputLibrary::STATIC_Key_GetNavigationDirectionFromAnalog(const struct FSlateCore_AnalogInputEvent& InAnalogEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromAnalog");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationDirectionFromAnalog");

	UEngine_KismetInputLibrary_Key_GetNavigationDirectionFromAnalog_Params params;
	params.InAnalogEvent = InAnalogEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationActionFromKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_KeyEvent     InKeyEvent                     (ConstParm, Parm, OutParm, ReferenceParm)
// FSlateCore_SlateCore_EUINavigationAction ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FSlateCore_SlateCore_EUINavigationAction UEngine_KismetInputLibrary::STATIC_Key_GetNavigationActionFromKey(const struct FSlateCore_KeyEvent& InKeyEvent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationActionFromKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationActionFromKey");

	UEngine_KismetInputLibrary_Key_GetNavigationActionFromKey_Params params;
	params.InKeyEvent = InKeyEvent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetNavigationAction
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          InKey                          (ConstParm, Parm, OutParm, ReferenceParm)
// FSlateCore_SlateCore_EUINavigationAction ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FSlateCore_SlateCore_EUINavigationAction UEngine_KismetInputLibrary::STATIC_Key_GetNavigationAction(const struct FInputCore_Key& InKey)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationAction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetNavigationAction");

	UEngine_KismetInputLibrary_Key_GetNavigationAction_Params params;
	params.InKey = InKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.Key_GetDisplayName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetInputLibrary::STATIC_Key_GetDisplayName(const struct FInputCore_Key& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetDisplayName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.Key_GetDisplayName");

	UEngine_KismetInputLibrary_Key_GetDisplayName_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsShiftDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsShiftDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsShiftDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsShiftDown");

	UEngine_KismetInputLibrary_InputEvent_IsShiftDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsRightShiftDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown");

	UEngine_KismetInputLibrary_InputEvent_IsRightShiftDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsRightControlDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown");

	UEngine_KismetInputLibrary_InputEvent_IsRightControlDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsRightCommandDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown");

	UEngine_KismetInputLibrary_InputEvent_IsRightCommandDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsRightAltDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown");

	UEngine_KismetInputLibrary_InputEvent_IsRightAltDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsRepeat
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsRepeat(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRepeat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRepeat");

	UEngine_KismetInputLibrary_InputEvent_IsRepeat_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsLeftShiftDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown");

	UEngine_KismetInputLibrary_InputEvent_IsLeftShiftDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsLeftControlDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown");

	UEngine_KismetInputLibrary_InputEvent_IsLeftControlDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsLeftCommandDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown");

	UEngine_KismetInputLibrary_InputEvent_IsLeftCommandDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsLeftAltDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown");

	UEngine_KismetInputLibrary_InputEvent_IsLeftAltDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsControlDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsControlDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsControlDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsControlDown");

	UEngine_KismetInputLibrary_InputEvent_IsControlDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsCommandDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsCommandDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsCommandDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsCommandDown");

	UEngine_KismetInputLibrary_InputEvent_IsCommandDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputEvent_IsAltDown
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_InputEvent   Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_InputEvent_IsAltDown(const struct FSlateCore_InputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsAltDown");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsAltDown");

	UEngine_KismetInputLibrary_InputEvent_IsAltDown_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.InputChord_GetDisplayName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlate_InputChord       Key                            (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetInputLibrary::STATIC_InputChord_GetDisplayName(const struct FSlate_InputChord& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputChord_GetDisplayName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputChord_GetDisplayName");

	UEngine_KismetInputLibrary_InputChord_GetDisplayName_Params params;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.GetUserIndex
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_KeyEvent     Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetInputLibrary::STATIC_GetUserIndex(const struct FSlateCore_KeyEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetUserIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetUserIndex");

	UEngine_KismetInputLibrary_GetUserIndex_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.GetKey
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_KeyEvent     Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// struct FInputCore_Key          ReturnValue                    (Parm, OutParm, ReturnParm)

struct FInputCore_Key UEngine_KismetInputLibrary::STATIC_GetKey(const struct FSlateCore_KeyEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetKey");

	UEngine_KismetInputLibrary_GetKey_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.GetAnalogValue
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlateCore_AnalogInputEvent Input                          (ConstParm, Parm, OutParm, ReferenceParm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetInputLibrary::STATIC_GetAnalogValue(const struct FSlateCore_AnalogInputEvent& Input)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetAnalogValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetAnalogValue");

	UEngine_KismetInputLibrary_GetAnalogValue_Params params;
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.EqualEqual_KeyKey
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FInputCore_Key          A                              (Parm)
// struct FInputCore_Key          B                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_EqualEqual_KeyKey(const struct FInputCore_Key& A, const struct FInputCore_Key& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_KeyKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_KeyKey");

	UEngine_KismetInputLibrary_EqualEqual_KeyKey_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSlate_InputChord       A                              (Parm)
// struct FSlate_InputChord       B                              (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInputLibrary::STATIC_EqualEqual_InputChordInputChord(const struct FSlate_InputChord& A, const struct FSlate_InputChord& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord");

	UEngine_KismetInputLibrary_EqualEqual_InputChordInputChord_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInputLibrary.CalibrateTilt
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetInputLibrary::STATIC_CalibrateTilt()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.CalibrateTilt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.CalibrateTilt");

	UEngine_KismetInputLibrary_CalibrateTilt_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLocale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 Culture                        (Parm, ZeroConstructor)
// bool                           SaveToConfig                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInternationalizationLibrary::STATIC_SetCurrentLocale(const struct FString& Culture, bool SaveToConfig)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLocale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLocale");

	UEngine_KismetInternationalizationLibrary_SetCurrentLocale_Params params;
	params.Culture = Culture;
	params.SaveToConfig = SaveToConfig;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguageAndLocale
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 Culture                        (Parm, ZeroConstructor)
// bool                           SaveToConfig                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInternationalizationLibrary::STATIC_SetCurrentLanguageAndLocale(const struct FString& Culture, bool SaveToConfig)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLanguageAndLocale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLanguageAndLocale");

	UEngine_KismetInternationalizationLibrary_SetCurrentLanguageAndLocale_Params params;
	params.Culture = Culture;
	params.SaveToConfig = SaveToConfig;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 Culture                        (Parm, ZeroConstructor)
// bool                           SaveToConfig                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInternationalizationLibrary::STATIC_SetCurrentLanguage(const struct FString& Culture, bool SaveToConfig)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLanguage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentLanguage");

	UEngine_KismetInternationalizationLibrary_SetCurrentLanguage_Params params;
	params.Culture = Culture;
	params.SaveToConfig = SaveToConfig;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 Culture                        (Parm, ZeroConstructor)
// bool                           SaveToConfig                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInternationalizationLibrary::STATIC_SetCurrentCulture(const struct FString& Culture, bool SaveToConfig)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentCulture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentCulture");

	UEngine_KismetInternationalizationLibrary_SetCurrentCulture_Params params;
	params.Culture = Culture;
	params.SaveToConfig = SaveToConfig;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.SetCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   AssetGroup                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Culture                        (Parm, ZeroConstructor)
// bool                           SaveToConfig                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetInternationalizationLibrary::STATIC_SetCurrentAssetGroupCulture(const struct FName& AssetGroup, const struct FString& Culture, bool SaveToConfig)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentAssetGroupCulture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.SetCurrentAssetGroupCulture");

	UEngine_KismetInternationalizationLibrary_SetCurrentAssetGroupCulture_Params params;
	params.AssetGroup = AssetGroup;
	params.Culture = Culture;
	params.SaveToConfig = SaveToConfig;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetSuitableCulture
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         AvailableCultures              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FString                 CultureToMatch                 (Parm, ZeroConstructor)
// struct FString                 FallbackCulture                (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetInternationalizationLibrary::STATIC_GetSuitableCulture(TArray<struct FString> AvailableCultures, const struct FString& CultureToMatch, const struct FString& FallbackCulture)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetSuitableCulture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetSuitableCulture");

	UEngine_KismetInternationalizationLibrary_GetSuitableCulture_Params params;
	params.AvailableCultures = AvailableCultures;
	params.CultureToMatch = CultureToMatch;
	params.FallbackCulture = FallbackCulture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetNativeCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FCoreUObject_ELocalizedTextSourceCategory TextCategory                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetInternationalizationLibrary::STATIC_GetNativeCulture(FCoreUObject_ELocalizedTextSourceCategory TextCategory)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetNativeCulture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetNativeCulture");

	UEngine_KismetInternationalizationLibrary_GetNativeCulture_Params params;
	params.TextCategory = TextCategory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetLocalizedCultures
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           IncludeGame                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           IncludeEngine                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           IncludeEditor                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           IncludeAdditional              (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UEngine_KismetInternationalizationLibrary::STATIC_GetLocalizedCultures(bool IncludeGame, bool IncludeEngine, bool IncludeEditor, bool IncludeAdditional)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetLocalizedCultures");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetLocalizedCultures");

	UEngine_KismetInternationalizationLibrary_GetLocalizedCultures_Params params;
	params.IncludeGame = IncludeGame;
	params.IncludeEngine = IncludeEngine;
	params.IncludeEditor = IncludeEditor;
	params.IncludeAdditional = IncludeAdditional;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentLocale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetInternationalizationLibrary::STATIC_GetCurrentLocale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentLocale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentLocale");

	UEngine_KismetInternationalizationLibrary_GetCurrentLocale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetInternationalizationLibrary::STATIC_GetCurrentLanguage()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentLanguage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentLanguage");

	UEngine_KismetInternationalizationLibrary_GetCurrentLanguage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetInternationalizationLibrary::STATIC_GetCurrentCulture()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentCulture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentCulture");

	UEngine_KismetInternationalizationLibrary_GetCurrentCulture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   AssetGroup                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetInternationalizationLibrary::STATIC_GetCurrentAssetGroupCulture(const struct FName& AssetGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentAssetGroupCulture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCurrentAssetGroupCulture");

	UEngine_KismetInternationalizationLibrary_GetCurrentAssetGroupCulture_Params params;
	params.AssetGroup = AssetGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.GetCultureDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Culture                        (Parm, ZeroConstructor)
// bool                           Localized                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetInternationalizationLibrary::STATIC_GetCultureDisplayName(const struct FString& Culture, bool Localized)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCultureDisplayName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.GetCultureDisplayName");

	UEngine_KismetInternationalizationLibrary_GetCultureDisplayName_Params params;
	params.Culture = Culture;
	params.Localized = Localized;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetInternationalizationLibrary.ClearCurrentAssetGroupCulture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FName                   AssetGroup                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           SaveToConfig                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetInternationalizationLibrary::STATIC_ClearCurrentAssetGroupCulture(const struct FName& AssetGroup, bool SaveToConfig)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.ClearCurrentAssetGroupCulture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetInternationalizationLibrary.ClearCurrentAssetGroupCulture");

	UEngine_KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture_Params params;
	params.AssetGroup = AssetGroup;
	params.SaveToConfig = SaveToConfig;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetMaterialLibrary.SetVectorParameterValue
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialParameterCollection* Collection                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ParameterValue                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMaterialLibrary::STATIC_SetVectorParameterValue(class UObject* WorldContextObject, class UEngine_MaterialParameterCollection* Collection, const struct FName& ParameterName, const struct FLinearColor& ParameterValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetVectorParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetVectorParameterValue");

	UEngine_KismetMaterialLibrary_SetVectorParameterValue_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;
	params.ParameterValue = ParameterValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetMaterialLibrary.SetScalarParameterValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialParameterCollection* Collection                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          ParameterValue                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMaterialLibrary::STATIC_SetScalarParameterValue(class UObject* WorldContextObject, class UEngine_MaterialParameterCollection* Collection, const struct FName& ParameterName, float ParameterValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetScalarParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetScalarParameterValue");

	UEngine_KismetMaterialLibrary_SetScalarParameterValue_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;
	params.ParameterValue = ParameterValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetMaterialLibrary.GetVectorParameterValue
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialParameterCollection* Collection                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMaterialLibrary::STATIC_GetVectorParameterValue(class UObject* WorldContextObject, class UEngine_MaterialParameterCollection* Collection, const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetVectorParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetVectorParameterValue");

	UEngine_KismetMaterialLibrary_GetVectorParameterValue_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMaterialLibrary.GetScalarParameterValue
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialParameterCollection* Collection                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMaterialLibrary::STATIC_GetScalarParameterValue(class UObject* WorldContextObject, class UEngine_MaterialParameterCollection* Collection, const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetScalarParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetScalarParameterValue");

	UEngine_KismetMaterialLibrary_GetScalarParameterValue_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Collection = Collection;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* Parent                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   OptionalName                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInstanceDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInstanceDynamic* UEngine_KismetMaterialLibrary::STATIC_CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UEngine_MaterialInterface* Parent, const struct FName& OptionalName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance");

	UEngine_KismetMaterialLibrary_CreateDynamicMaterialInstance_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Parent = Parent;
	params.OptionalName = OptionalName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Xor_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Xor_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_IntInt");

	UEngine_KismetMathLibrary_Xor_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Xor_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Xor_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_Int64Int64");

	UEngine_KismetMathLibrary_Xor_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.WeightedMovingAverage_FVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 CurrentSample                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PreviousSample                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          Weight                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_WeightedMovingAverage_FVector(const struct FVector& CurrentSample, const struct FVector& PreviousSample, float Weight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_FVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_FVector");

	UEngine_KismetMathLibrary_WeightedMovingAverage_FVector_Params params;
	params.CurrentSample = CurrentSample;
	params.PreviousSample = PreviousSample;
	params.Weight = Weight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.WeightedMovingAverage_FRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                CurrentSample                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                PreviousSample                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          Weight                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_WeightedMovingAverage_FRotator(const struct FRotator& CurrentSample, const struct FRotator& PreviousSample, float Weight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_FRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_FRotator");

	UEngine_KismetMathLibrary_WeightedMovingAverage_FRotator_Params params;
	params.CurrentSample = CurrentSample;
	params.PreviousSample = PreviousSample;
	params.Weight = Weight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.WeightedMovingAverage_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          CurrentSample                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          PreviousSample                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          Weight                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_WeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float Weight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_Float");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WeightedMovingAverage_Float");

	UEngine_KismetMathLibrary_WeightedMovingAverage_Float_Params params;
	params.CurrentSample = CurrentSample;
	params.PreviousSample = PreviousSample;
	params.Weight = Weight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSizeXYSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_VSizeXYSquared(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeXYSquared");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeXYSquared");

	UEngine_KismetMathLibrary_VSizeXYSquared_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSizeXY
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_VSizeXY(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeXY");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeXY");

	UEngine_KismetMathLibrary_VSizeXY_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSizeSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_VSizeSquared(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeSquared");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeSquared");

	UEngine_KismetMathLibrary_VSizeSquared_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSize2DSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_VSize2DSquared(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2DSquared");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2DSquared");

	UEngine_KismetMathLibrary_VSize2DSquared_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSize2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_VSize2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2D");

	UEngine_KismetMathLibrary_VSize2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_VSize(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize");

	UEngine_KismetMathLibrary_VSize_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_VLerp(const struct FVector& A, const struct FVector& B, float ALPHA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VLerp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VLerp");

	UEngine_KismetMathLibrary_VLerp_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_VInterpTo_Constant(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant");

	UEngine_KismetMathLibrary_VInterpTo_Constant_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_VInterpTo(const struct FVector& Current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo");

	UEngine_KismetMathLibrary_VInterpTo_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VectorSpringInterp
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Target                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_VectorSpringState SpringState                    (Parm, OutParm, ReferenceParm)
// float                          Stiffness                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          CriticalDampingFactor          (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Mass                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_VectorSpringInterp(const struct FVector& Current, const struct FVector& Target, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, struct FEngine_VectorSpringState* SpringState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VectorSpringInterp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VectorSpringInterp");

	UEngine_KismetMathLibrary_VectorSpringInterp_Params params;
	params.Current = Current;
	params.Target = Target;
	params.Stiffness = Stiffness;
	params.CriticalDampingFactor = CriticalDampingFactor;
	params.DeltaTime = DeltaTime;
	params.Mass = Mass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SpringState != nullptr)
		*SpringState = params.SpringState;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Zero()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Zero");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Zero");

	UEngine_KismetMathLibrary_Vector_Zero_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Up
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Up()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Up");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Up");

	UEngine_KismetMathLibrary_Vector_Up_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_UnwindEuler
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector_UnwindEuler(struct FVector* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_UnwindEuler");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_UnwindEuler");

	UEngine_KismetMathLibrary_Vector_UnwindEuler_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector_UnitCartesianToSpherical
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Vector_UnitCartesianToSpherical(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_UnitCartesianToSpherical");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_UnitCartesianToSpherical");

	UEngine_KismetMathLibrary_Vector_UnitCartesianToSpherical_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ToRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ToRadians(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ToRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ToRadians");

	UEngine_KismetMathLibrary_Vector_ToRadians_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ToDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ToDegrees(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ToDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ToDegrees");

	UEngine_KismetMathLibrary_Vector_ToDegrees_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_SnappedToGrid
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVect                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          InGridSize                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_SnappedToGrid(const struct FVector& InVect, float InGridSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_SnappedToGrid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_SnappedToGrid");

	UEngine_KismetMathLibrary_Vector_SnappedToGrid_Params params;
	params.InVect = InVect;
	params.InGridSize = InGridSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Set
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector_Set(float X, float Y, float Z, struct FVector* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Set");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Set");

	UEngine_KismetMathLibrary_Vector_Set_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector_Right
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Right()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Right");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Right");

	UEngine_KismetMathLibrary_Vector_Right_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Reciprocal
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Reciprocal(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Reciprocal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Reciprocal");

	UEngine_KismetMathLibrary_Vector_Reciprocal_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ProjectOnToNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InNormal                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ProjectOnToNormal(const struct FVector& V, const struct FVector& InNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ProjectOnToNormal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ProjectOnToNormal");

	UEngine_KismetMathLibrary_Vector_ProjectOnToNormal_Params params;
	params.V = V;
	params.InNormal = InNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_One
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_One()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_One");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_One");

	UEngine_KismetMathLibrary_Vector_One_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_NormalUnsafe
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_NormalUnsafe(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_NormalUnsafe");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_NormalUnsafe");

	UEngine_KismetMathLibrary_Vector_NormalUnsafe_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Normalize
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector_Normalize(float Tolerance, struct FVector* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Normalize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Normalize");

	UEngine_KismetMathLibrary_Vector_Normalize_Params params;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector_Normal2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Normal2D(const struct FVector& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Normal2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Normal2D");

	UEngine_KismetMathLibrary_Vector_Normal2D_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_MirrorByPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FPlane                  InPlane                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_MirrorByPlane(const struct FVector& A, const struct FPlane& InPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_MirrorByPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_MirrorByPlane");

	UEngine_KismetMathLibrary_Vector_MirrorByPlane_Params params;
	params.A = A;
	params.InPlane = InPlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Left
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Left()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Left");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Left");

	UEngine_KismetMathLibrary_Vector_Left_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsZero
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector_IsZero(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsZero");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsZero");

	UEngine_KismetMathLibrary_Vector_IsZero_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsUnit
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          SquaredLenthTolerance          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector_IsUnit(const struct FVector& A, float SquaredLenthTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsUnit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsUnit");

	UEngine_KismetMathLibrary_Vector_IsUnit_Params params;
	params.A = A;
	params.SquaredLenthTolerance = SquaredLenthTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsUniform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector_IsUniform(const struct FVector& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsUniform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsUniform");

	UEngine_KismetMathLibrary_Vector_IsUniform_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsNormal
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector_IsNormal(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNormal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNormal");

	UEngine_KismetMathLibrary_Vector_IsNormal_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsNearlyZero
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector_IsNearlyZero(const struct FVector& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNearlyZero");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNearlyZero");

	UEngine_KismetMathLibrary_Vector_IsNearlyZero_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_IsNAN
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector_IsNAN(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNAN");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_IsNAN");

	UEngine_KismetMathLibrary_Vector_IsNAN_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_HeadingAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_HeadingAngle(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_HeadingAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_HeadingAngle");

	UEngine_KismetMathLibrary_Vector_HeadingAngle_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetSignVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_GetSignVector(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetSignVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetSignVector");

	UEngine_KismetMathLibrary_Vector_GetSignVector_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetProjection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_GetProjection(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetProjection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetProjection");

	UEngine_KismetMathLibrary_Vector_GetProjection_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetAbsMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_GetAbsMin(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbsMin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbsMin");

	UEngine_KismetMathLibrary_Vector_GetAbsMin_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetAbsMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_GetAbsMax(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbsMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbsMax");

	UEngine_KismetMathLibrary_Vector_GetAbsMax_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_GetAbs
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_GetAbs(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbs");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_GetAbs");

	UEngine_KismetMathLibrary_Vector_GetAbs_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Forward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Forward()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Forward");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Forward");

	UEngine_KismetMathLibrary_Vector_Forward_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Down
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Down()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Down");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Down");

	UEngine_KismetMathLibrary_Vector_Down_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_DistanceSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 v1                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 v2                             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_DistanceSquared(const struct FVector& v1, const struct FVector& v2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_DistanceSquared");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_DistanceSquared");

	UEngine_KismetMathLibrary_Vector_DistanceSquared_Params params;
	params.v1 = v1;
	params.v2 = v2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Distance2DSquared
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 v1                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 v2                             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_Distance2DSquared(const struct FVector& v1, const struct FVector& v2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance2DSquared");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance2DSquared");

	UEngine_KismetMathLibrary_Vector_Distance2DSquared_Params params;
	params.v1 = v1;
	params.v2 = v2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Distance2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 v1                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 v2                             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_Distance2D(const struct FVector& v1, const struct FVector& v2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance2D");

	UEngine_KismetMathLibrary_Vector_Distance2D_Params params;
	params.v1 = v1;
	params.v2 = v2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Distance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 v1                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 v2                             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_Distance(const struct FVector& v1, const struct FVector& v2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Distance");

	UEngine_KismetMathLibrary_Vector_Distance_Params params;
	params.v1 = v1;
	params.v2 = v2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_CosineAngle2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector_CosineAngle2D(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_CosineAngle2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_CosineAngle2D");

	UEngine_KismetMathLibrary_Vector_CosineAngle2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ComponentMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ComponentMin(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ComponentMin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ComponentMin");

	UEngine_KismetMathLibrary_Vector_ComponentMin_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ComponentMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ComponentMax(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ComponentMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ComponentMax");

	UEngine_KismetMathLibrary_Vector_ComponentMax_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ClampSizeMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ClampSizeMax2D(const struct FVector& A, float Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSizeMax2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSizeMax2D");

	UEngine_KismetMathLibrary_Vector_ClampSizeMax2D_Params params;
	params.A = A;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ClampSizeMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ClampSizeMax(const struct FVector& A, float Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSizeMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSizeMax");

	UEngine_KismetMathLibrary_Vector_ClampSizeMax_Params params;
	params.A = A;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_ClampSize2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Min                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_ClampSize2D(const struct FVector& A, float Min, float Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSize2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_ClampSize2D");

	UEngine_KismetMathLibrary_Vector_ClampSize2D_Params params;
	params.A = A;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_BoundedToCube
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVect                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRadius                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_BoundedToCube(const struct FVector& InVect, float InRadius)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_BoundedToCube");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_BoundedToCube");

	UEngine_KismetMathLibrary_Vector_BoundedToCube_Params params;
	params.InVect = InVect;
	params.InRadius = InRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_BoundedToBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVect                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InBoxMin                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InBoxMax                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_BoundedToBox(const struct FVector& InVect, const struct FVector& InBoxMin, const struct FVector& InBoxMax)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_BoundedToBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_BoundedToBox");

	UEngine_KismetMathLibrary_Vector_BoundedToBox_Params params;
	params.InVect = InVect;
	params.InBoxMin = InBoxMin;
	params.InBoxMax = InBoxMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Backward
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Vector_Backward()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Backward");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Backward");

	UEngine_KismetMathLibrary_Vector_Backward_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector_Assign
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 InVector                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector_Assign(const struct FVector& InVector, struct FVector* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Assign");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_Assign");

	UEngine_KismetMathLibrary_Vector_Assign_Params params;
	params.InVector = InVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector_AddBounded
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 InAddVect                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRadius                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector_AddBounded(const struct FVector& InAddVect, float InRadius, struct FVector* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_AddBounded");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector_AddBounded");

	UEngine_KismetMathLibrary_Vector_AddBounded_Params params;
	params.InAddVect = InAddVect;
	params.InRadius = InRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector4_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Vector4_Zero()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Zero");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Zero");

	UEngine_KismetMathLibrary_Vector4_Zero_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_SizeSquared3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector4_SizeSquared3(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_SizeSquared3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_SizeSquared3");

	UEngine_KismetMathLibrary_Vector4_SizeSquared3_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_SizeSquared
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector4_SizeSquared(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_SizeSquared");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_SizeSquared");

	UEngine_KismetMathLibrary_Vector4_SizeSquared_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Size3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector4_Size3(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Size3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Size3");

	UEngine_KismetMathLibrary_Vector4_Size3_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Size
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector4_Size(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Size");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Size");

	UEngine_KismetMathLibrary_Vector4_Size_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Set
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          W                              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector4_Set(float X, float Y, float Z, float W, struct FVector4* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Set");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Set");

	UEngine_KismetMathLibrary_Vector4_Set_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;
	params.W = W;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector4_NormalUnsafe3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Vector4_NormalUnsafe3(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_NormalUnsafe3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_NormalUnsafe3");

	UEngine_KismetMathLibrary_Vector4_NormalUnsafe3_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Normalize3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector4_Normalize3(float Tolerance, struct FVector4* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Normalize3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Normalize3");

	UEngine_KismetMathLibrary_Vector4_Normalize3_Params params;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector4_Normal3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Vector4_Normal3(const struct FVector4& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Normal3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Normal3");

	UEngine_KismetMathLibrary_Vector4_Normal3_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Negated
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Vector4_Negated(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Negated");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Negated");

	UEngine_KismetMathLibrary_Vector4_Negated_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_MirrorByVector3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                Direction                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                SurfaceNormal                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Vector4_MirrorByVector3(const struct FVector4& Direction, const struct FVector4& SurfaceNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_MirrorByVector3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_MirrorByVector3");

	UEngine_KismetMathLibrary_Vector4_MirrorByVector3_Params params;
	params.Direction = Direction;
	params.SurfaceNormal = SurfaceNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsZero
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector4_IsZero(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsZero");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsZero");

	UEngine_KismetMathLibrary_Vector4_IsZero_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsUnit3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          SquaredLenthTolerance          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector4_IsUnit3(const struct FVector4& A, float SquaredLenthTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsUnit3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsUnit3");

	UEngine_KismetMathLibrary_Vector4_IsUnit3_Params params;
	params.A = A;
	params.SquaredLenthTolerance = SquaredLenthTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsNormal3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector4_IsNormal3(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNormal3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNormal3");

	UEngine_KismetMathLibrary_Vector4_IsNormal3_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsNearlyZero3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector4_IsNearlyZero3(const struct FVector4& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNearlyZero3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNearlyZero3");

	UEngine_KismetMathLibrary_Vector4_IsNearlyZero3_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_IsNAN
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Vector4_IsNAN(const struct FVector4& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNAN");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_IsNAN");

	UEngine_KismetMathLibrary_Vector4_IsNAN_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_DotProduct3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector4_DotProduct3(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_DotProduct3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_DotProduct3");

	UEngine_KismetMathLibrary_Vector4_DotProduct3_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_DotProduct
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Vector4_DotProduct(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_DotProduct");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_DotProduct");

	UEngine_KismetMathLibrary_Vector4_DotProduct_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_CrossProduct3
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Vector4_CrossProduct3(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_CrossProduct3");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_CrossProduct3");

	UEngine_KismetMathLibrary_Vector4_CrossProduct3_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector4_Assign
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector4                A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                InVector                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Vector4_Assign(const struct FVector4& InVector, struct FVector4* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Assign");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector4_Assign");

	UEngine_KismetMathLibrary_Vector4_Assign_Params params;
	params.InVector = InVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Vector2DInterpTo_Constant(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant");

	UEngine_KismetMathLibrary_Vector2DInterpTo_Constant_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2DInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Vector2DInterpTo(const struct FVector2D& Current, const struct FVector2D& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2DInterpTo");

	UEngine_KismetMathLibrary_Vector2DInterpTo_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2D_Zero
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Vector2D_Zero()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_Zero");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_Zero");

	UEngine_KismetMathLibrary_Vector2D_Zero_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2D_Unit45Deg
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Vector2D_Unit45Deg()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_Unit45Deg");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_Unit45Deg");

	UEngine_KismetMathLibrary_Vector2D_Unit45Deg_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Vector2D_One
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Vector2D_One()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_One");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Vector2D_One");

	UEngine_KismetMathLibrary_Vector2D_One_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.VEase
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendExp                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            Steps                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_VEase(const struct FVector& A, const struct FVector& B, float ALPHA, TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VEase");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VEase");

	UEngine_KismetMathLibrary_VEase_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.UtcNow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_UtcNow()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.UtcNow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.UtcNow");

	UEngine_KismetMathLibrary_UtcNow_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TransformRotation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              T                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_TransformRotation(const struct FTransform& T, const struct FRotator& Rotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformRotation");

	UEngine_KismetMathLibrary_TransformRotation_Params params;
	params.T = T;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TransformLocation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              T                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_TransformLocation(const struct FTransform& T, const struct FVector& Location)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformLocation");

	UEngine_KismetMathLibrary_TransformLocation_Params params;
	params.T = T;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TransformDirection
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              T                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_TransformDirection(const struct FTransform& T, const struct FVector& Direction)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformDirection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformDirection");

	UEngine_KismetMathLibrary_TransformDirection_Params params;
	params.T = T;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Transform_Determinant
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              Transform                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Transform_Determinant(const struct FTransform& Transform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Transform_Determinant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Transform_Determinant");

	UEngine_KismetMathLibrary_Transform_Determinant_Params params;
	params.Transform = Transform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ToSign2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_ToSign2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToSign2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToSign2D");

	UEngine_KismetMathLibrary_ToSign2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ToRounded2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_ToRounded2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToRounded2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToRounded2D");

	UEngine_KismetMathLibrary_ToRounded2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ToDirectionAndLength2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               OutDir                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutLength                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_ToDirectionAndLength2D(const struct FVector2D& A, struct FVector2D* OutDir, float* OutLength)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToDirectionAndLength2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ToDirectionAndLength2D");

	UEngine_KismetMathLibrary_ToDirectionAndLength2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutDir != nullptr)
		*OutDir = params.OutDir;
	if (OutLength != nullptr)
		*OutLength = params.OutLength;
}


// Function Engine.KismetMathLibrary.Today
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_Today()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Today");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Today");

	UEngine_KismetMathLibrary_Today_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TLerp
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ELerpInterpolationMode> InterpMode                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_TLerp(const struct FTransform& A, const struct FTransform& B, float ALPHA, TEnumAsByte<FEngine_Engine_ELerpInterpolationMode> InterpMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TLerp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TLerp");

	UEngine_KismetMathLibrary_TLerp_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;
	params.InterpMode = InterpMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TInterpTo
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              Current                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              Target                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_TInterpTo(const struct FTransform& Current, const struct FTransform& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TInterpTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TInterpTo");

	UEngine_KismetMathLibrary_TInterpTo_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanZeroValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_TimespanZeroValue()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanZeroValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanZeroValue");

	UEngine_KismetMathLibrary_TimespanZeroValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanRatio
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_TimespanRatio(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanRatio");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanRatio");

	UEngine_KismetMathLibrary_TimespanRatio_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanMinValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_TimespanMinValue()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMinValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMinValue");

	UEngine_KismetMathLibrary_TimespanMinValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanMaxValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_TimespanMaxValue()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMaxValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMaxValue");

	UEngine_KismetMathLibrary_TimespanMaxValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TimespanFromString
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 TimespanString                 (Parm, ZeroConstructor)
// struct FTimespan               Result                         (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_TimespanFromString(const struct FString& TimespanString, struct FTimespan* Result)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanFromString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanFromString");

	UEngine_KismetMathLibrary_TimespanFromString_Params params;
	params.TimespanString = TimespanString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.TEase
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendExp                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            Steps                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_TEase(const struct FTransform& A, const struct FTransform& B, float ALPHA, TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TEase");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TEase");

	UEngine_KismetMathLibrary_TEase_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Tan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Tan(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Tan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Tan");

	UEngine_KismetMathLibrary_Tan_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Subtract_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorVector");

	UEngine_KismetMathLibrary_Subtract_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Subtract_VectorInt(const struct FVector& A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorInt");

	UEngine_KismetMathLibrary_Subtract_VectorInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Subtract_VectorFloat(const struct FVector& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorFloat");

	UEngine_KismetMathLibrary_Subtract_VectorFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Subtract_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector4Vector4");

	UEngine_KismetMathLibrary_Subtract_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Subtract_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D");

	UEngine_KismetMathLibrary_Subtract_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Subtract_Vector2DFloat(const struct FVector2D& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DFloat");

	UEngine_KismetMathLibrary_Subtract_Vector2DFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_Subtract_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_TimespanTimespan");

	UEngine_KismetMathLibrary_Subtract_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_QuatQuat
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Subtract_QuatQuat(const struct FQuat& A, const struct FQuat& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_QuatQuat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_QuatQuat");

	UEngine_KismetMathLibrary_Subtract_QuatQuat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Subtract_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_LinearColorLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_LinearColorLinearColor");

	UEngine_KismetMathLibrary_Subtract_LinearColorLinearColor_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Subtract_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_IntInt");

	UEngine_KismetMathLibrary_Subtract_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Subtract_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Int64Int64");

	UEngine_KismetMathLibrary_Subtract_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Subtract_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_FloatFloat");

	UEngine_KismetMathLibrary_Subtract_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_Subtract_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan");

	UEngine_KismetMathLibrary_Subtract_DateTimeTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_Subtract_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime");

	UEngine_KismetMathLibrary_Subtract_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Subtract_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_Subtract_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_ByteByte");

	UEngine_KismetMathLibrary_Subtract_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Square
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Square(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Square");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Square");

	UEngine_KismetMathLibrary_Square_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Sqrt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Sqrt(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sqrt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sqrt");

	UEngine_KismetMathLibrary_Sqrt_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Spherical2DToUnitCartesian
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Spherical2DToUnitCartesian(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Spherical2DToUnitCartesian");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Spherical2DToUnitCartesian");

	UEngine_KismetMathLibrary_Spherical2DToUnitCartesian_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Sin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Sin(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sin");

	UEngine_KismetMathLibrary_Sin_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SignOfInteger64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_SignOfInteger64(int64_t A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger64");

	UEngine_KismetMathLibrary_SignOfInteger64_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SignOfInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_SignOfInteger(int A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger");

	UEngine_KismetMathLibrary_SignOfInteger_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SignOfFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_SignOfFloat(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfFloat");

	UEngine_KismetMathLibrary_SignOfFloat_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SetRandomStreamSeed
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream           Stream                         (Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            NewSeed                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_SetRandomStreamSeed(int NewSeed, struct FRandomStream* Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetRandomStreamSeed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetRandomStreamSeed");

	UEngine_KismetMathLibrary_SetRandomStreamSeed_Params params;
	params.NewSeed = NewSeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Stream != nullptr)
		*Stream = params.Stream;
}


// Function Engine.KismetMathLibrary.Set2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Set2D(float X, float Y, struct FVector2D* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Set2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Set2D");

	UEngine_KismetMathLibrary_Set2D_Params params;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.SelectVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPickA                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_SelectVector(const struct FVector& A, const struct FVector& B, bool bPickA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectVector");

	UEngine_KismetMathLibrary_SelectVector_Params params;
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           bPickA                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_SelectTransform(const struct FTransform& A, const struct FTransform& B, bool bPickA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectTransform");

	UEngine_KismetMathLibrary_SelectTransform_Params params;
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 A                              (Parm, ZeroConstructor)
// struct FString                 B                              (Parm, ZeroConstructor)
// bool                           bPickA                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetMathLibrary::STATIC_SelectString(const struct FString& A, const struct FString& B, bool bPickA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectString");

	UEngine_KismetMathLibrary_SelectString_Params params;
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPickA                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_SelectRotator(const struct FRotator& A, const struct FRotator& B, bool bPickA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectRotator");

	UEngine_KismetMathLibrary_SelectRotator_Params params;
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSelectA                       (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UEngine_KismetMathLibrary::STATIC_SelectObject(class UObject* A, class UObject* B, bool bSelectA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectObject");

	UEngine_KismetMathLibrary_SelectObject_Params params;
	params.A = A;
	params.B = B;
	params.bSelectA = bSelectA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPickA                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_SelectInt(int A, int B, bool bPickA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectInt");

	UEngine_KismetMathLibrary_SelectInt_Params params;
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPickA                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_SelectFloat(float A, float B, bool bPickA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectFloat");

	UEngine_KismetMathLibrary_SelectFloat_Params params;
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPickA                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_SelectColor(const struct FLinearColor& A, const struct FLinearColor& B, bool bPickA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectColor");

	UEngine_KismetMathLibrary_SelectColor_Params params;
	params.A = A;
	params.B = B;
	params.bPickA = bPickA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SelectClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSelectA                       (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UEngine_KismetMathLibrary::STATIC_SelectClass(class UClass* A, class UClass* B, bool bSelectA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectClass");

	UEngine_KismetMathLibrary_SelectClass_Params params;
	params.A = A;
	params.B = B;
	params.bSelectA = bSelectA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.SeedRandomStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream           Stream                         (Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetMathLibrary::STATIC_SeedRandomStream(struct FRandomStream* Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SeedRandomStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SeedRandomStream");

	UEngine_KismetMathLibrary_SeedRandomStream_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Stream != nullptr)
		*Stream = params.Stream;
}


// Function Engine.KismetMathLibrary.SafeDivide
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_SafeDivide(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SafeDivide");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SafeDivide");

	UEngine_KismetMathLibrary_SafeDivide_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Round64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Round64(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round64");

	UEngine_KismetMathLibrary_Round64_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Round
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Round(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round");

	UEngine_KismetMathLibrary_Round_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Axis                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Angle                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_RotatorFromAxisAndAngle(const struct FVector& Axis, float Angle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle");

	UEngine_KismetMathLibrary_RotatorFromAxisAndAngle_Params params;
	params.Axis = Axis;
	params.Angle = Angle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RotateAngleAxis
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVect                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngleDeg                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Axis                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RotateAngleAxis(const struct FVector& InVect, float AngleDeg, const struct FVector& Axis)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotateAngleAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotateAngleAxis");

	UEngine_KismetMathLibrary_RotateAngleAxis_Params params;
	params.InVect = InVect;
	params.AngleDeg = AngleDeg;
	params.Axis = Axis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShortestPath                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_RLerp(const struct FRotator& A, const struct FRotator& B, float ALPHA, bool bShortestPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RLerp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RLerp");

	UEngine_KismetMathLibrary_RLerp_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;
	params.bShortestPath = bShortestPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RInterpTo_Constant
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_RInterpTo_Constant(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo_Constant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo_Constant");

	UEngine_KismetMathLibrary_RInterpTo_Constant_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_RInterpTo(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo");

	UEngine_KismetMathLibrary_RInterpTo_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RGBToHSV_Vector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            RGB                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            HSV                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_RGBToHSV_Vector(const struct FLinearColor& RGB, struct FLinearColor* HSV)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV_Vector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV_Vector");

	UEngine_KismetMathLibrary_RGBToHSV_Vector_Params params;
	params.RGB = RGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (HSV != nullptr)
		*HSV = params.HSV;
}


// Function Engine.KismetMathLibrary.RGBToHSV
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          H                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          S                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          V                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          A                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_RGBToHSV(const struct FLinearColor& InColor, float* H, float* S, float* V, float* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV");

	UEngine_KismetMathLibrary_RGBToHSV_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (H != nullptr)
		*H = params.H;
	if (S != nullptr)
		*S = params.S;
	if (V != nullptr)
		*V = params.V;
	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.RGBLinearToHSV
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            RGB                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_RGBLinearToHSV(const struct FLinearColor& RGB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBLinearToHSV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBLinearToHSV");

	UEngine_KismetMathLibrary_RGBLinearToHSV_Params params;
	params.RGB = RGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ResetVectorSpringState
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_VectorSpringState SpringState                    (Parm, OutParm, ReferenceParm)

void UEngine_KismetMathLibrary::STATIC_ResetVectorSpringState(struct FEngine_VectorSpringState* SpringState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetVectorSpringState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetVectorSpringState");

	UEngine_KismetMathLibrary_ResetVectorSpringState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SpringState != nullptr)
		*SpringState = params.SpringState;
}


// Function Engine.KismetMathLibrary.ResetRandomStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetMathLibrary::STATIC_ResetRandomStream(const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetRandomStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetRandomStream");

	UEngine_KismetMathLibrary_ResetRandomStream_Params params;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetMathLibrary.ResetFloatSpringState
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_FloatSpringState SpringState                    (Parm, OutParm, ReferenceParm)

void UEngine_KismetMathLibrary::STATIC_ResetFloatSpringState(struct FEngine_FloatSpringState* SpringState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetFloatSpringState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetFloatSpringState");

	UEngine_KismetMathLibrary_ResetFloatSpringState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SpringState != nullptr)
		*SpringState = params.SpringState;
}


// Function Engine.KismetMathLibrary.REase
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShortestPath                  (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendExp                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            Steps                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_REase(const struct FRotator& A, const struct FRotator& B, float ALPHA, bool bShortestPath, TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.REase");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.REase");

	UEngine_KismetMathLibrary_REase_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;
	params.bShortestPath = bShortestPath;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadiansFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          MaxYawInRadians                (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxPitchInRadians              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInEllipticalConeInRadiansFromStream(const struct FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadiansFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadiansFromStream");

	UEngine_KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream_Params params;
	params.ConeDir = ConeDir;
	params.MaxYawInRadians = MaxYawInRadians;
	params.MaxPitchInRadians = MaxPitchInRadians;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxYawInRadians                (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxPitchInRadians              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInEllipticalConeInRadians(const struct FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadians");

	UEngine_KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians_Params params;
	params.ConeDir = ConeDir;
	params.MaxYawInRadians = MaxYawInRadians;
	params.MaxPitchInRadians = MaxPitchInRadians;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegreesFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          MaxYawInDegrees                (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxPitchInDegrees              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInEllipticalConeInDegreesFromStream(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegreesFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegreesFromStream");

	UEngine_KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream_Params params;
	params.ConeDir = ConeDir;
	params.MaxYawInDegrees = MaxYawInDegrees;
	params.MaxPitchInDegrees = MaxPitchInDegrees;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxYawInDegrees                (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxPitchInDegrees              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInEllipticalConeInDegrees(const struct FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegrees");

	UEngine_KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees_Params params;
	params.ConeDir = ConeDir;
	params.MaxYawInDegrees = MaxYawInDegrees;
	params.MaxPitchInDegrees = MaxPitchInDegrees;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadiansFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ConeHalfAngleInRadians         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInConeInRadiansFromStream(const struct FVector& ConeDir, float ConeHalfAngleInRadians, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadiansFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadiansFromStream");

	UEngine_KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream_Params params;
	params.ConeDir = ConeDir;
	params.ConeHalfAngleInRadians = ConeHalfAngleInRadians;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadians
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ConeHalfAngleInRadians         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInConeInRadians(const struct FVector& ConeDir, float ConeHalfAngleInRadians)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadians");

	UEngine_KismetMathLibrary_RandomUnitVectorInConeInRadians_Params params;
	params.ConeDir = ConeDir;
	params.ConeHalfAngleInRadians = ConeHalfAngleInRadians;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegreesFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ConeHalfAngleInDegrees         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInConeInDegreesFromStream(const struct FVector& ConeDir, float ConeHalfAngleInDegrees, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegreesFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegreesFromStream");

	UEngine_KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream_Params params;
	params.ConeDir = ConeDir;
	params.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ConeDir                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ConeHalfAngleInDegrees         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorInConeInDegrees(const struct FVector& ConeDir, float ConeHalfAngleInDegrees)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegrees");

	UEngine_KismetMathLibrary_RandomUnitVectorInConeInDegrees_Params params;
	params.ConeDir = ConeDir;
	params.ConeHalfAngleInDegrees = ConeHalfAngleInDegrees;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVectorFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVectorFromStream(const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorFromStream");

	UEngine_KismetMathLibrary_RandomUnitVectorFromStream_Params params;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomUnitVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomUnitVector()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVector");

	UEngine_KismetMathLibrary_RandomUnitVector_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomRotatorFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           bRoll                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_RandomRotatorFromStream(bool bRoll, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotatorFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotatorFromStream");

	UEngine_KismetMathLibrary_RandomRotatorFromStream_Params params;
	params.bRoll = bRoll;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           bRoll                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_RandomRotator(bool bRoll)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotator");

	UEngine_KismetMathLibrary_RandomRotator_Params params;
	params.bRoll = bRoll;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomPointInBoundingBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Origin                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_RandomPointInBoundingBox(const struct FVector& Origin, const struct FVector& BoxExtent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBox");

	UEngine_KismetMathLibrary_RandomPointInBoundingBox_Params params;
	params.Origin = Origin;
	params.BoxExtent = BoxExtent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Min                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_RandomIntegerInRangeFromStream(int Min, int Max, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream");

	UEngine_KismetMathLibrary_RandomIntegerInRangeFromStream_Params params;
	params.Min = Min;
	params.Max = Max;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomIntegerInRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Min                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            Max                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_RandomIntegerInRange(int Min, int Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRange");

	UEngine_KismetMathLibrary_RandomIntegerInRange_Params params;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomIntegerFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_RandomIntegerFromStream(int Max, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerFromStream");

	UEngine_KismetMathLibrary_RandomIntegerFromStream_Params params;
	params.Max = Max;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomInteger64InRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        Min                            (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        Max                            (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_RandomInteger64InRange(int64_t Min, int64_t Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger64InRange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger64InRange");

	UEngine_KismetMathLibrary_RandomInteger64InRange_Params params;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomInteger64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        Max                            (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_RandomInteger64(int64_t Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger64");

	UEngine_KismetMathLibrary_RandomInteger64_Params params;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Max                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_RandomInteger(int Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger");

	UEngine_KismetMathLibrary_RandomInteger_Params params;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Min                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_RandomFloatInRangeFromStream(float Min, float Max, const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream");

	UEngine_KismetMathLibrary_RandomFloatInRangeFromStream_Params params;
	params.Min = Min;
	params.Max = Max;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloatInRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Min                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_RandomFloatInRange(float Min, float Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRange");

	UEngine_KismetMathLibrary_RandomFloatInRange_Params params;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloatFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_RandomFloatFromStream(const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatFromStream");

	UEngine_KismetMathLibrary_RandomFloatFromStream_Params params;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_RandomFloat()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloat");

	UEngine_KismetMathLibrary_RandomFloat_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Weight                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           RandomStream                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_RandomBoolWithWeightFromStream(float Weight, const struct FRandomStream& RandomStream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream");

	UEngine_KismetMathLibrary_RandomBoolWithWeightFromStream_Params params;
	params.Weight = Weight;
	params.RandomStream = RandomStream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBoolWithWeight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Weight                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_RandomBoolWithWeight(float Weight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolWithWeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolWithWeight");

	UEngine_KismetMathLibrary_RandomBoolWithWeight_Params params;
	params.Weight = Weight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBoolFromStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream           Stream                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_RandomBoolFromStream(const struct FRandomStream& Stream)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolFromStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolFromStream");

	UEngine_KismetMathLibrary_RandomBoolFromStream_Params params;
	params.Stream = Stream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RandomBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_RandomBool()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBool");

	UEngine_KismetMathLibrary_RandomBool_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.RadiansToDegrees
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_RadiansToDegrees(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RadiansToDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RadiansToDegrees");

	UEngine_KismetMathLibrary_RadiansToDegrees_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_VectorUp
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_VectorUp(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorUp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorUp");

	UEngine_KismetMathLibrary_Quat_VectorUp_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_VectorRight
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_VectorRight(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorRight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorRight");

	UEngine_KismetMathLibrary_Quat_VectorRight_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_VectorForward
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_VectorForward(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorForward");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_VectorForward");

	UEngine_KismetMathLibrary_Quat_VectorForward_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_UnrotateVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 V                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_UnrotateVector(const struct FQuat& Q, const struct FVector& V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_UnrotateVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_UnrotateVector");

	UEngine_KismetMathLibrary_Quat_UnrotateVector_Params params;
	params.Q = Q;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_SizeSquared
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Quat_SizeSquared(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SizeSquared");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SizeSquared");

	UEngine_KismetMathLibrary_Quat_SizeSquared_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Size
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Quat_Size(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Size");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Size");

	UEngine_KismetMathLibrary_Quat_Size_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_SetFromEuler
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                   Q                              (Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Euler                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Quat_SetFromEuler(const struct FVector& Euler, struct FQuat* Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SetFromEuler");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SetFromEuler");

	UEngine_KismetMathLibrary_Quat_SetFromEuler_Params params;
	params.Euler = Euler;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Q != nullptr)
		*Q = params.Q;
}


// Function Engine.KismetMathLibrary.Quat_SetComponents
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                   Q                              (Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          W                              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Quat_SetComponents(float X, float Y, float Z, float W, struct FQuat* Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SetComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_SetComponents");

	UEngine_KismetMathLibrary_Quat_SetComponents_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;
	params.W = W;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Q != nullptr)
		*Q = params.Q;
}


// Function Engine.KismetMathLibrary.Quat_Rotator
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_Quat_Rotator(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Rotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Rotator");

	UEngine_KismetMathLibrary_Quat_Rotator_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_RotateVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 V                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_RotateVector(const struct FQuat& Q, const struct FVector& V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_RotateVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_RotateVector");

	UEngine_KismetMathLibrary_Quat_RotateVector_Params params;
	params.Q = Q;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Normalized
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Quat_Normalized(const struct FQuat& Q, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Normalized");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Normalized");

	UEngine_KismetMathLibrary_Quat_Normalized_Params params;
	params.Q = Q;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Normalize
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                   Q                              (Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Quat_Normalize(float Tolerance, struct FQuat* Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Normalize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Normalize");

	UEngine_KismetMathLibrary_Quat_Normalize_Params params;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Q != nullptr)
		*Q = params.Q;
}


// Function Engine.KismetMathLibrary.Quat_MakeFromEuler
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Euler                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Quat_MakeFromEuler(const struct FVector& Euler)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_MakeFromEuler");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_MakeFromEuler");

	UEngine_KismetMathLibrary_Quat_MakeFromEuler_Params params;
	params.Euler = Euler;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Log
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Quat_Log(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Log");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Log");

	UEngine_KismetMathLibrary_Quat_Log_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsNormalized
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Quat_IsNormalized(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsNormalized");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsNormalized");

	UEngine_KismetMathLibrary_Quat_IsNormalized_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsNonFinite
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Quat_IsNonFinite(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsNonFinite");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsNonFinite");

	UEngine_KismetMathLibrary_Quat_IsNonFinite_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsIdentity
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Quat_IsIdentity(const struct FQuat& Q, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsIdentity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsIdentity");

	UEngine_KismetMathLibrary_Quat_IsIdentity_Params params;
	params.Q = Q;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_IsFinite
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Quat_IsFinite(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsFinite");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_IsFinite");

	UEngine_KismetMathLibrary_Quat_IsFinite_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Inversed
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Quat_Inversed(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Inversed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Inversed");

	UEngine_KismetMathLibrary_Quat_Inversed_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Identity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Quat_Identity()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Identity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Identity");

	UEngine_KismetMathLibrary_Quat_Identity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetRotationAxis
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_GetRotationAxis(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetRotationAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetRotationAxis");

	UEngine_KismetMathLibrary_Quat_GetRotationAxis_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAxisZ
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_GetAxisZ(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisZ");

	UEngine_KismetMathLibrary_Quat_GetAxisZ_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAxisY
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_GetAxisY(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisY");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisY");

	UEngine_KismetMathLibrary_Quat_GetAxisY_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAxisX
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_GetAxisX(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisX");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAxisX");

	UEngine_KismetMathLibrary_Quat_GetAxisX_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_GetAngle
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Quat_GetAngle(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_GetAngle");

	UEngine_KismetMathLibrary_Quat_GetAngle_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Exp
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Quat_Exp(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Exp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Exp");

	UEngine_KismetMathLibrary_Quat_Exp_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_Euler
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   Q                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Quat_Euler(const struct FQuat& Q)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Euler");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_Euler");

	UEngine_KismetMathLibrary_Quat_Euler_Params params;
	params.Q = Q;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Quat_EnforceShortestArcWith
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FQuat                   A                              (Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Quat_EnforceShortestArcWith(const struct FQuat& B, struct FQuat* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_EnforceShortestArcWith");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_EnforceShortestArcWith");

	UEngine_KismetMathLibrary_Quat_EnforceShortestArcWith_Params params;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Quat_AngularDistance
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Quat_AngularDistance(const struct FQuat& A, const struct FQuat& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_AngularDistance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Quat_AngularDistance");

	UEngine_KismetMathLibrary_Quat_AngularDistance_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ProjectVectorOnToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Target                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_ProjectVectorOnToVector(const struct FVector& V, const struct FVector& Target)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToVector");

	UEngine_KismetMathLibrary_ProjectVectorOnToVector_Params params;
	params.V = V;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ProjectVectorOnToPlane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PlaneNormal                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_ProjectVectorOnToPlane(const struct FVector& V, const struct FVector& PlaneNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToPlane");

	UEngine_KismetMathLibrary_ProjectVectorOnToPlane_Params params;
	params.V = V;
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ProjectPointOnToPlane
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PlaneBase                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PlaneNormal                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_ProjectPointOnToPlane(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectPointOnToPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectPointOnToPlane");

	UEngine_KismetMathLibrary_ProjectPointOnToPlane_Params params;
	params.Point = Point;
	params.PlaneBase = PlaneBase;
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.PointsAreCoplanar
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>         Points                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_PointsAreCoplanar(TArray<struct FVector> Points, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PointsAreCoplanar");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PointsAreCoplanar");

	UEngine_KismetMathLibrary_PointsAreCoplanar_Params params;
	params.Points = Points;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.PerlinNoise1D
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_PerlinNoise1D(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PerlinNoise1D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PerlinNoise1D");

	UEngine_KismetMathLibrary_PerlinNoise1D_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Percent_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Percent_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_IntInt");

	UEngine_KismetMathLibrary_Percent_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Percent_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Percent_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_FloatFloat");

	UEngine_KismetMathLibrary_Percent_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Percent_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_Percent_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_ByteByte");

	UEngine_KismetMathLibrary_Percent_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Or_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Or_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_IntInt");

	UEngine_KismetMathLibrary_Or_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Or_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Or_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_Int64Int64");

	UEngine_KismetMathLibrary_Or_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Now
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_Now()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Now");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Now");

	UEngine_KismetMathLibrary_Now_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqualExactly_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqualExactly_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_VectorVector");

	UEngine_KismetMathLibrary_NotEqualExactly_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqualExactly_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqualExactly_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_Vector4Vector4");

	UEngine_KismetMathLibrary_NotEqualExactly_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqualExactly_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqualExactly_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqualExactly_Vector2DVector2D");

	UEngine_KismetMathLibrary_NotEqualExactly_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_VectorVector");

	UEngine_KismetMathLibrary_NotEqual_VectorVector_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_Vector4Vector4(const struct FVector4& A, const struct FVector4& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Vector4Vector4");

	UEngine_KismetMathLibrary_NotEqual_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D");

	UEngine_KismetMathLibrary_NotEqual_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan");

	UEngine_KismetMathLibrary_NotEqual_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_RotatorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_RotatorRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_RotatorRotator");

	UEngine_KismetMathLibrary_NotEqual_RotatorRotator_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_QuatQuat
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_QuatQuat(const struct FQuat& A, const struct FQuat& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_QuatQuat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_QuatQuat");

	UEngine_KismetMathLibrary_NotEqual_QuatQuat_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_ObjectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ObjectObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ObjectObject");

	UEngine_KismetMathLibrary_NotEqual_ObjectObject_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_NameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_NameName(const struct FName& A, const struct FName& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_NameName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_NameName");

	UEngine_KismetMathLibrary_NotEqual_NameName_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_MatrixMatrix
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_MatrixMatrix");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_MatrixMatrix");

	UEngine_KismetMathLibrary_NotEqual_MatrixMatrix_Params params;
	params.A = A;
	params.B = B;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_LinearColorLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_LinearColorLinearColor");

	UEngine_KismetMathLibrary_NotEqual_LinearColorLinearColor_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_IntInt");

	UEngine_KismetMathLibrary_NotEqual_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_Int64Int64");

	UEngine_KismetMathLibrary_NotEqual_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_FloatFloat");

	UEngine_KismetMathLibrary_NotEqual_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime");

	UEngine_KismetMathLibrary_NotEqual_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_ClassClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_ClassClass(class UClass* A, class UClass* B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ClassClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ClassClass");

	UEngine_KismetMathLibrary_NotEqual_ClassClass_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ByteByte");

	UEngine_KismetMathLibrary_NotEqual_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NotEqual_BoolBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NotEqual_BoolBool(bool A, bool B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_BoolBool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_BoolBool");

	UEngine_KismetMathLibrary_NotEqual_BoolBool_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Not_PreBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Not_PreBool(bool A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_PreBool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_PreBool");

	UEngine_KismetMathLibrary_Not_PreBool_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Not_Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Not_Int64(int64_t A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_Int64");

	UEngine_KismetMathLibrary_Not_Int64_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Not_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Not_Int(int A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_Int");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_Int");

	UEngine_KismetMathLibrary_Not_Int_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NormalSafe2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_NormalSafe2D(const struct FVector2D& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalSafe2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalSafe2D");

	UEngine_KismetMathLibrary_NormalSafe2D_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NormalizeToRange
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          RangeMin                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          RangeMax                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_NormalizeToRange(float Value, float RangeMin, float RangeMax)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeToRange");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeToRange");

	UEngine_KismetMathLibrary_NormalizeToRange_Params params;
	params.Value = Value;
	params.RangeMin = RangeMin;
	params.RangeMax = RangeMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NormalizedDeltaRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_NormalizedDeltaRotator(const struct FRotator& A, const struct FRotator& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizedDeltaRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizedDeltaRotator");

	UEngine_KismetMathLibrary_NormalizedDeltaRotator_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NormalizeAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Angle                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_NormalizeAxis(float Angle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeAxis");

	UEngine_KismetMathLibrary_NormalizeAxis_Params params;
	params.Angle = Angle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Normalize2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               A                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Normalize2D(float Tolerance, struct FVector2D* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normalize2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normalize2D");

	UEngine_KismetMathLibrary_Normalize2D_Params params;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.Normal2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Normal2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal2D");

	UEngine_KismetMathLibrary_Normal2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Normal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Normal(const struct FVector& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal");

	UEngine_KismetMathLibrary_Normal_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NegateVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_NegateVector(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateVector");

	UEngine_KismetMathLibrary_NegateVector_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NegateRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_NegateRotator(const struct FRotator& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateRotator");

	UEngine_KismetMathLibrary_NegateRotator_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Negated2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Negated2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Negated2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Negated2D");

	UEngine_KismetMathLibrary_Negated2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          LocationTolerance              (Parm, ZeroConstructor, IsPlainOldData)
// float                          RotationTolerance              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale3DTolerance               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NearlyEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform");

	UEngine_KismetMathLibrary_NearlyEqual_TransformTransform_Params params;
	params.A = A;
	params.B = B;
	params.LocationTolerance = LocationTolerance;
	params.RotationTolerance = RotationTolerance;
	params.Scale3DTolerance = Scale3DTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat");

	UEngine_KismetMathLibrary_NearlyEqual_FloatFloat_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Base                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Exp                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_MultiplyMultiply_FloatFloat(float Base, float Exp)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat");

	UEngine_KismetMathLibrary_MultiplyMultiply_FloatFloat_Params params;
	params.Base = Base;
	params.Exp = Exp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MultiplyByPi
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_MultiplyByPi(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyByPi");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyByPi");

	UEngine_KismetMathLibrary_MultiplyByPi_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Multiply_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorVector");

	UEngine_KismetMathLibrary_Multiply_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Multiply_VectorInt(const struct FVector& A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorInt");

	UEngine_KismetMathLibrary_Multiply_VectorInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Multiply_VectorFloat(const struct FVector& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorFloat");

	UEngine_KismetMathLibrary_Multiply_VectorFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Multiply_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector4Vector4");

	UEngine_KismetMathLibrary_Multiply_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Multiply_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D");

	UEngine_KismetMathLibrary_Multiply_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Multiply_Vector2DFloat(const struct FVector2D& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DFloat");

	UEngine_KismetMathLibrary_Multiply_Vector2DFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_TimespanFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// float                          Scalar                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_Multiply_TimespanFloat(const struct FTimespan& A, float Scalar)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_TimespanFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_TimespanFloat");

	UEngine_KismetMathLibrary_Multiply_TimespanFloat_Params params;
	params.A = A;
	params.Scalar = Scalar;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_RotatorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_Multiply_RotatorInt(const struct FRotator& A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorInt");

	UEngine_KismetMathLibrary_Multiply_RotatorInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_RotatorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_Multiply_RotatorFloat(const struct FRotator& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorFloat");

	UEngine_KismetMathLibrary_Multiply_RotatorFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_QuatQuat
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Multiply_QuatQuat(const struct FQuat& A, const struct FQuat& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_QuatQuat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_QuatQuat");

	UEngine_KismetMathLibrary_Multiply_QuatQuat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_MatrixMatrix
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Multiply_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_MatrixMatrix");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_MatrixMatrix");

	UEngine_KismetMathLibrary_Multiply_MatrixMatrix_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_MatrixFloat
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Multiply_MatrixFloat(const struct FMatrix& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_MatrixFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_MatrixFloat");

	UEngine_KismetMathLibrary_Multiply_MatrixFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Multiply_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor");

	UEngine_KismetMathLibrary_Multiply_LinearColorLinearColor_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_LinearColorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Multiply_LinearColorFloat(const struct FLinearColor& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorFloat");

	UEngine_KismetMathLibrary_Multiply_LinearColorFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Multiply_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntInt");

	UEngine_KismetMathLibrary_Multiply_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_IntFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Multiply_IntFloat(int A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntFloat");

	UEngine_KismetMathLibrary_Multiply_IntFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Multiply_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Int64Int64");

	UEngine_KismetMathLibrary_Multiply_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Multiply_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_FloatFloat");

	UEngine_KismetMathLibrary_Multiply_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Multiply_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_Multiply_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_ByteByte");

	UEngine_KismetMathLibrary_Multiply_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MirrorVectorByNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVect                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InNormal                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_MirrorVectorByNormal(const struct FVector& InVect, const struct FVector& InNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MirrorVectorByNormal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MirrorVectorByNormal");

	UEngine_KismetMathLibrary_MirrorVectorByNormal_Params params;
	params.InVect = InVect;
	params.InNormal = InNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MinOfIntArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    IntArray                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexOfMinValue                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            MinValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_MinOfIntArray(TArray<int> IntArray, int* IndexOfMinValue, int* MinValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfIntArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfIntArray");

	UEngine_KismetMathLibrary_MinOfIntArray_Params params;
	params.IntArray = IntArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = params.IndexOfMinValue;
	if (MinValue != nullptr)
		*MinValue = params.MinValue;
}


// Function Engine.KismetMathLibrary.MinOfFloatArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                  FloatArray                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexOfMinValue                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          MinValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_MinOfFloatArray(TArray<float> FloatArray, int* IndexOfMinValue, float* MinValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfFloatArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfFloatArray");

	UEngine_KismetMathLibrary_MinOfFloatArray_Params params;
	params.FloatArray = FloatArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = params.IndexOfMinValue;
	if (MinValue != nullptr)
		*MinValue = params.MinValue;
}


// Function Engine.KismetMathLibrary.MinOfByteArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<unsigned char>          ByteArray                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexOfMinValue                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// unsigned char                  MinValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_MinOfByteArray(TArray<unsigned char> ByteArray, int* IndexOfMinValue, unsigned char* MinValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfByteArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfByteArray");

	UEngine_KismetMathLibrary_MinOfByteArray_Params params;
	params.ByteArray = ByteArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IndexOfMinValue != nullptr)
		*IndexOfMinValue = params.IndexOfMinValue;
	if (MinValue != nullptr)
		*MinValue = params.MinValue;
}


// Function Engine.KismetMathLibrary.MinInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_MinInt64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinInt64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinInt64");

	UEngine_KismetMathLibrary_MinInt64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MinimumAreaRectangle
// (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FVector>         InVerts                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 SampleSurfaceNormal            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 OutRectCenter                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                OutRectRotation                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutSideLengthX                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutSideLengthY                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           bDebugDraw                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_MinimumAreaRectangle(class UObject* WorldContextObject, TArray<struct FVector> InVerts, const struct FVector& SampleSurfaceNormal, bool bDebugDraw, struct FVector* OutRectCenter, struct FRotator* OutRectRotation, float* OutSideLengthX, float* OutSideLengthY)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinimumAreaRectangle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinimumAreaRectangle");

	UEngine_KismetMathLibrary_MinimumAreaRectangle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InVerts = InVerts;
	params.SampleSurfaceNormal = SampleSurfaceNormal;
	params.bDebugDraw = bDebugDraw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutRectCenter != nullptr)
		*OutRectCenter = params.OutRectCenter;
	if (OutRectRotation != nullptr)
		*OutRectRotation = params.OutRectRotation;
	if (OutSideLengthX != nullptr)
		*OutSideLengthX = params.OutSideLengthX;
	if (OutSideLengthY != nullptr)
		*OutSideLengthY = params.OutSideLengthY;
}


// Function Engine.KismetMathLibrary.Min
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Min(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Min");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Min");

	UEngine_KismetMathLibrary_Min_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MaxOfIntArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<int>                    IntArray                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexOfMaxValue                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            MaxValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_MaxOfIntArray(TArray<int> IntArray, int* IndexOfMaxValue, int* MaxValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfIntArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfIntArray");

	UEngine_KismetMathLibrary_MaxOfIntArray_Params params;
	params.IntArray = IntArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = params.IndexOfMaxValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;
}


// Function Engine.KismetMathLibrary.MaxOfFloatArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<float>                  FloatArray                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexOfMaxValue                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          MaxValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_MaxOfFloatArray(TArray<float> FloatArray, int* IndexOfMaxValue, float* MaxValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfFloatArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfFloatArray");

	UEngine_KismetMathLibrary_MaxOfFloatArray_Params params;
	params.FloatArray = FloatArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = params.IndexOfMaxValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;
}


// Function Engine.KismetMathLibrary.MaxOfByteArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<unsigned char>          ByteArray                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            IndexOfMaxValue                (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// unsigned char                  MaxValue                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_MaxOfByteArray(TArray<unsigned char> ByteArray, int* IndexOfMaxValue, unsigned char* MaxValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfByteArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfByteArray");

	UEngine_KismetMathLibrary_MaxOfByteArray_Params params;
	params.ByteArray = ByteArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IndexOfMaxValue != nullptr)
		*IndexOfMaxValue = params.IndexOfMaxValue;
	if (MaxValue != nullptr)
		*MaxValue = params.MaxValue;
}


// Function Engine.KismetMathLibrary.MaxInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_MaxInt64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxInt64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxInt64");

	UEngine_KismetMathLibrary_MaxInt64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Max
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Max(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Max");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Max");

	UEngine_KismetMathLibrary_Max_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_TransformVector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Matrix_TransformVector4(const struct FMatrix& M, const struct FVector4& V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformVector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformVector4");

	UEngine_KismetMathLibrary_Matrix_TransformVector4_Params params;
	params.M = M;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_TransformVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Matrix_TransformVector(const struct FMatrix& M, const struct FVector& V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformVector");

	UEngine_KismetMathLibrary_Matrix_TransformVector_Params params;
	params.M = M;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_TransformPosition
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Matrix_TransformPosition(const struct FMatrix& M, const struct FVector& V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_TransformPosition");

	UEngine_KismetMathLibrary_Matrix_TransformPosition_Params params;
	params.M = M;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ToQuat
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Matrix_ToQuat(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ToQuat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ToQuat");

	UEngine_KismetMathLibrary_Matrix_ToQuat_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_SetOrigin
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                 M                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 NewOrigin                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Matrix_SetOrigin(const struct FVector& NewOrigin, struct FMatrix* M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetOrigin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetOrigin");

	UEngine_KismetMathLibrary_Matrix_SetOrigin_Params params;
	params.NewOrigin = NewOrigin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (M != nullptr)
		*M = params.M;
}


// Function Engine.KismetMathLibrary.Matrix_SetColumn
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                 M                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EMatrixColumns> Column                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Matrix_SetColumn(TEnumAsByte<FEngine_Engine_EMatrixColumns> Column, const struct FVector& Value, struct FMatrix* M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetColumn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetColumn");

	UEngine_KismetMathLibrary_Matrix_SetColumn_Params params;
	params.Column = Column;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (M != nullptr)
		*M = params.M;
}


// Function Engine.KismetMathLibrary.Matrix_SetAxis
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                 M                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FCoreUObject_EAxis> Axis                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 AxisVector                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Matrix_SetAxis(TEnumAsByte<FCoreUObject_EAxis> Axis, const struct FVector& AxisVector, struct FMatrix* M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_SetAxis");

	UEngine_KismetMathLibrary_Matrix_SetAxis_Params params;
	params.Axis = Axis;
	params.AxisVector = AxisVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (M != nullptr)
		*M = params.M;
}


// Function Engine.KismetMathLibrary.Matrix_ScaleTranslation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Scale3D                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_ScaleTranslation(const struct FMatrix& M, const struct FVector& Scale3D)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ScaleTranslation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ScaleTranslation");

	UEngine_KismetMathLibrary_Matrix_ScaleTranslation_Params params;
	params.M = M;
	params.Scale3D = Scale3D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_RemoveTranslation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_RemoveTranslation(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_RemoveTranslation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_RemoveTranslation");

	UEngine_KismetMathLibrary_Matrix_RemoveTranslation_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_RemoveScaling
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMatrix                 M                              (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Matrix_RemoveScaling(float Tolerance, struct FMatrix* M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_RemoveScaling");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_RemoveScaling");

	UEngine_KismetMathLibrary_Matrix_RemoveScaling_Params params;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (M != nullptr)
		*M = params.M;
}


// Function Engine.KismetMathLibrary.Matrix_Mirror
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FCoreUObject_EAxis> MirrorAxis                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FCoreUObject_EAxis> FlipAxis                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_Mirror(const struct FMatrix& M, TEnumAsByte<FCoreUObject_EAxis> MirrorAxis, TEnumAsByte<FCoreUObject_EAxis> FlipAxis)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_Mirror");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_Mirror");

	UEngine_KismetMathLibrary_Matrix_Mirror_Params params;
	params.M = M;
	params.MirrorAxis = MirrorAxis;
	params.FlipAxis = FlipAxis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_InverseTransformVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Matrix_InverseTransformVector(const struct FMatrix& M, const struct FVector& V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_InverseTransformVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_InverseTransformVector");

	UEngine_KismetMathLibrary_Matrix_InverseTransformVector_Params params;
	params.M = M;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_InverseTransformPosition
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Matrix_InverseTransformPosition(const struct FMatrix& M, const struct FVector& V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_InverseTransformPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_InverseTransformPosition");

	UEngine_KismetMathLibrary_Matrix_InverseTransformPosition_Params params;
	params.M = M;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_Identity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_Identity()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_Identity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_Identity");

	UEngine_KismetMathLibrary_Matrix_Identity_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetUnitAxis
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FCoreUObject_EAxis> Axis                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Matrix_GetUnitAxis(const struct FMatrix& M, TEnumAsByte<FCoreUObject_EAxis> Axis)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetUnitAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetUnitAxis");

	UEngine_KismetMathLibrary_Matrix_GetUnitAxis_Params params;
	params.M = M;
	params.Axis = Axis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetUnitAxes
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 X                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Y                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Z                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Matrix_GetUnitAxes(const struct FMatrix& M, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetUnitAxes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetUnitAxes");

	UEngine_KismetMathLibrary_Matrix_GetUnitAxes_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;
}


// Function Engine.KismetMathLibrary.Matrix_GetTransposed
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_GetTransposed(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetTransposed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetTransposed");

	UEngine_KismetMathLibrary_Matrix_GetTransposed_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetTransposeAdjoint
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_GetTransposeAdjoint(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetTransposeAdjoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetTransposeAdjoint");

	UEngine_KismetMathLibrary_Matrix_GetTransposeAdjoint_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetScaleVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Matrix_GetScaleVector(const struct FMatrix& M, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaleVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaleVector");

	UEngine_KismetMathLibrary_Matrix_GetScaleVector_Params params;
	params.M = M;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetScaledAxis
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FCoreUObject_EAxis> Axis                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Matrix_GetScaledAxis(const struct FMatrix& M, TEnumAsByte<FCoreUObject_EAxis> Axis)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaledAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaledAxis");

	UEngine_KismetMathLibrary_Matrix_GetScaledAxis_Params params;
	params.M = M;
	params.Axis = Axis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetScaledAxes
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 X                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Y                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Z                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_Matrix_GetScaledAxes(const struct FMatrix& M, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaledAxes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetScaledAxes");

	UEngine_KismetMathLibrary_Matrix_GetScaledAxes_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;
}


// Function Engine.KismetMathLibrary.Matrix_GetRotDeterminant
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Matrix_GetRotDeterminant(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetRotDeterminant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetRotDeterminant");

	UEngine_KismetMathLibrary_Matrix_GetRotDeterminant_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetRotator
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_Matrix_GetRotator(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetRotator");

	UEngine_KismetMathLibrary_Matrix_GetRotator_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetOrigin
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 InMatrix                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Matrix_GetOrigin(const struct FMatrix& InMatrix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetOrigin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetOrigin");

	UEngine_KismetMathLibrary_Matrix_GetOrigin_Params params;
	params.InMatrix = InMatrix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetMaximumAxisScale
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Matrix_GetMaximumAxisScale(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetMaximumAxisScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetMaximumAxisScale");

	UEngine_KismetMathLibrary_Matrix_GetMaximumAxisScale_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetMatrixWithoutScale
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_GetMatrixWithoutScale(const struct FMatrix& M, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetMatrixWithoutScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetMatrixWithoutScale");

	UEngine_KismetMathLibrary_Matrix_GetMatrixWithoutScale_Params params;
	params.M = M;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetInverse
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_GetInverse(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetInverse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetInverse");

	UEngine_KismetMathLibrary_Matrix_GetInverse_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumTopPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FPlane                  OutPlane                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Matrix_GetFrustumTopPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumTopPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumTopPlane");

	UEngine_KismetMathLibrary_Matrix_GetFrustumTopPlane_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlane != nullptr)
		*OutPlane = params.OutPlane;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumRightPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FPlane                  OutPlane                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Matrix_GetFrustumRightPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumRightPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumRightPlane");

	UEngine_KismetMathLibrary_Matrix_GetFrustumRightPlane_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlane != nullptr)
		*OutPlane = params.OutPlane;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumNearPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FPlane                  OutPlane                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Matrix_GetFrustumNearPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumNearPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumNearPlane");

	UEngine_KismetMathLibrary_Matrix_GetFrustumNearPlane_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlane != nullptr)
		*OutPlane = params.OutPlane;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumLeftPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FPlane                  OutPlane                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Matrix_GetFrustumLeftPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumLeftPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumLeftPlane");

	UEngine_KismetMathLibrary_Matrix_GetFrustumLeftPlane_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlane != nullptr)
		*OutPlane = params.OutPlane;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumFarPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FPlane                  OutPlane                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Matrix_GetFrustumFarPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumFarPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumFarPlane");

	UEngine_KismetMathLibrary_Matrix_GetFrustumFarPlane_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlane != nullptr)
		*OutPlane = params.OutPlane;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetFrustumBottomPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FPlane                  OutPlane                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Matrix_GetFrustumBottomPlane(const struct FMatrix& M, struct FPlane* OutPlane)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumBottomPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetFrustumBottomPlane");

	UEngine_KismetMathLibrary_Matrix_GetFrustumBottomPlane_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPlane != nullptr)
		*OutPlane = params.OutPlane;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetDeterminant
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Matrix_GetDeterminant(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetDeterminant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetDeterminant");

	UEngine_KismetMathLibrary_Matrix_GetDeterminant_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_GetColumn
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EMatrixColumns> Column                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Matrix_GetColumn(const struct FMatrix& M, TEnumAsByte<FEngine_Engine_EMatrixColumns> Column)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetColumn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_GetColumn");

	UEngine_KismetMathLibrary_Matrix_GetColumn_Params params;
	params.M = M;
	params.Column = Column;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ContainsNaN
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Matrix_ContainsNaN(const struct FMatrix& M)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ContainsNaN");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ContainsNaN");

	UEngine_KismetMathLibrary_Matrix_ContainsNaN_Params params;
	params.M = M;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ConcatenateTranslation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Translation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_ConcatenateTranslation(const struct FMatrix& M, const struct FVector& Translation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ConcatenateTranslation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ConcatenateTranslation");

	UEngine_KismetMathLibrary_Matrix_ConcatenateTranslation_Params params;
	params.M = M;
	params.Translation = Translation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Matrix_ApplyScale
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 M                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Matrix_ApplyScale(const struct FMatrix& M, float Scale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ApplyScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Matrix_ApplyScale");

	UEngine_KismetMathLibrary_Matrix_ApplyScale_Params params;
	params.M = M;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MapRangeUnclamped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRangeA                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRangeB                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutRangeA                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutRangeB                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_MapRangeUnclamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeUnclamped");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeUnclamped");

	UEngine_KismetMathLibrary_MapRangeUnclamped_Params params;
	params.Value = Value;
	params.InRangeA = InRangeA;
	params.InRangeB = InRangeB;
	params.OutRangeA = OutRangeA;
	params.OutRangeB = OutRangeB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MapRangeClamped
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRangeA                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          InRangeB                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutRangeA                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          OutRangeB                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_MapRangeClamped(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeClamped");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRangeClamped");

	UEngine_KismetMathLibrary_MapRangeClamped_Params params;
	params.Value = Value;
	params.InRangeA = InRangeA;
	params.InRangeB = InRangeB;
	params.OutRangeA = OutRangeA;
	params.OutRangeB = OutRangeB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector4
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          W                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_MakeVector4(float X, float Y, float Z, float W)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector4");

	UEngine_KismetMathLibrary_MakeVector4_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;
	params.W = W;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_MakeVector2D(float X, float Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector2D");

	UEngine_KismetMathLibrary_MakeVector2D_Params params;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_MakeVector(float X, float Y, float Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector");

	UEngine_KismetMathLibrary_MakeVector_Params params;
	params.X = X;
	params.Y = Y;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_MakeTransform(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTransform");

	UEngine_KismetMathLibrary_MakeTransform_Params params;
	params.Location = Location;
	params.Rotation = Rotation;
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeTimespan2
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Days                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            Hours                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Minutes                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            Seconds                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            FractionNano                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_MakeTimespan2(int Days, int Hours, int Minutes, int Seconds, int FractionNano)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTimespan2");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTimespan2");

	UEngine_KismetMathLibrary_MakeTimespan2_Params params;
	params.Days = Days;
	params.Hours = Hours;
	params.Minutes = Minutes;
	params.Seconds = Seconds;
	params.FractionNano = FractionNano;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Days                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            Hours                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Minutes                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            Seconds                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            Milliseconds                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_MakeTimespan(int Days, int Hours, int Minutes, int Seconds, int Milliseconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTimespan");

	UEngine_KismetMathLibrary_MakeTimespan_Params params;
	params.Days = Days;
	params.Hours = Hours;
	params.Minutes = Minutes;
	params.Seconds = Seconds;
	params.Milliseconds = Milliseconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromZY
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Z                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Y                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromZY(const struct FVector& Z, const struct FVector& Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZY");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZY");

	UEngine_KismetMathLibrary_MakeRotFromZY_Params params;
	params.Z = Z;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromZX
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Z                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 X                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromZX(const struct FVector& Z, const struct FVector& X)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZX");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZX");

	UEngine_KismetMathLibrary_MakeRotFromZX_Params params;
	params.Z = Z;
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromZ
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Z                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromZ(const struct FVector& Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZ");

	UEngine_KismetMathLibrary_MakeRotFromZ_Params params;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromYZ
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Y                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Z                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromYZ(const struct FVector& Y, const struct FVector& Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYZ");

	UEngine_KismetMathLibrary_MakeRotFromYZ_Params params;
	params.Y = Y;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromYX
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Y                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 X                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromYX(const struct FVector& Y, const struct FVector& X)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYX");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYX");

	UEngine_KismetMathLibrary_MakeRotFromYX_Params params;
	params.Y = Y;
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromY
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Y                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromY(const struct FVector& Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromY");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromY");

	UEngine_KismetMathLibrary_MakeRotFromY_Params params;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromXZ
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 X                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Z                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromXZ(const struct FVector& X, const struct FVector& Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXZ");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXZ");

	UEngine_KismetMathLibrary_MakeRotFromXZ_Params params;
	params.X = X;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromXY
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 X                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Y                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromXY(const struct FVector& X, const struct FVector& Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXY");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXY");

	UEngine_KismetMathLibrary_MakeRotFromXY_Params params;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotFromX
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 X                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotFromX(const struct FVector& X)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromX");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromX");

	UEngine_KismetMathLibrary_MakeRotFromX_Params params;
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Roll                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Yaw                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotator(float Roll, float Pitch, float Yaw)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotator");

	UEngine_KismetMathLibrary_MakeRotator_Params params;
	params.Roll = Roll;
	params.Pitch = Pitch;
	params.Yaw = Yaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRotationFromAxes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Forward                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Right                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Up                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_MakeRotationFromAxes(const struct FVector& Forward, const struct FVector& Right, const struct FVector& Up)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotationFromAxes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotationFromAxes");

	UEngine_KismetMathLibrary_MakeRotationFromAxes_Params params;
	params.Forward = Forward;
	params.Right = Right;
	params.Up = Up;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRelativeTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              RelativeTo                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_MakeRelativeTransform(const struct FTransform& A, const struct FTransform& RelativeTo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRelativeTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRelativeTransform");

	UEngine_KismetMathLibrary_MakeRelativeTransform_Params params;
	params.A = A;
	params.RelativeTo = RelativeTo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeRandomStream
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            InitialSeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRandomStream           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FRandomStream UEngine_KismetMathLibrary::STATIC_MakeRandomStream(int InitialSeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRandomStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRandomStream");

	UEngine_KismetMathLibrary_MakeRandomStream_Params params;
	params.InitialSeed = InitialSeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeQualifiedFrameTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrameNumber            Frame                          (Parm)
// struct FFrameRate              FrameRate                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          SubFrame                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FQualifiedFrameTime     ReturnValue                    (Parm, OutParm, ReturnParm)

struct FQualifiedFrameTime UEngine_KismetMathLibrary::STATIC_MakeQualifiedFrameTime(const struct FFrameNumber& Frame, const struct FFrameRate& FrameRate, float SubFrame)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeQualifiedFrameTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeQualifiedFrameTime");

	UEngine_KismetMathLibrary_MakeQualifiedFrameTime_Params params;
	params.Frame = Frame;
	params.FrameRate = FrameRate;
	params.SubFrame = SubFrame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakePulsatingValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          InCurrentTime                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPulsesPerSecond              (Parm, ZeroConstructor, IsPlainOldData)
// float                          InPhase                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakePulsatingValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakePulsatingValue");

	UEngine_KismetMathLibrary_MakePulsatingValue_Params params;
	params.InCurrentTime = InCurrentTime;
	params.InPulsesPerSecond = InPulsesPerSecond;
	params.InPhase = InPhase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Normal                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FPlane                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FPlane UEngine_KismetMathLibrary::STATIC_MakePlaneFromPointAndNormal(const struct FVector& Point, const struct FVector& Normal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal");

	UEngine_KismetMathLibrary_MakePlaneFromPointAndNormal_Params params;
	params.Point = Point;
	params.Normal = Normal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeFrameRate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Numerator                      (Parm, ZeroConstructor, IsPlainOldData)
// int                            Denominator                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FFrameRate              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FFrameRate UEngine_KismetMathLibrary::STATIC_MakeFrameRate(int Numerator, int Denominator)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeFrameRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeFrameRate");

	UEngine_KismetMathLibrary_MakeFrameRate_Params params;
	params.Numerator = Numerator;
	params.Denominator = Denominator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Year                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            Month                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Day                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            Hour                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            Minute                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            Second                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            Millisecond                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_MakeDateTime(int Year, int Month, int Day, int Hour, int Minute, int Second, int Millisecond)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeDateTime");

	UEngine_KismetMathLibrary_MakeDateTime_Params params;
	params.Year = Year;
	params.Month = Month;
	params.Day = Day;
	params.Hour = Hour;
	params.Minute = Minute;
	params.Second = Second;
	params.Millisecond = Millisecond;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          R                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          G                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_MakeColor(float R, float G, float B, float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeColor");

	UEngine_KismetMathLibrary_MakeColor_Params params;
	params.R = R;
	params.G = G;
	params.B = B;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeBox2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               Min                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FBox2D                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FBox2D UEngine_KismetMathLibrary::STATIC_MakeBox2D(const struct FVector2D& Min, const struct FVector2D& Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeBox2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeBox2D");

	UEngine_KismetMathLibrary_MakeBox2D_Params params;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.MakeBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Min                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FBox                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FBox UEngine_KismetMathLibrary::STATIC_MakeBox(const struct FVector& Min, const struct FVector& Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeBox");

	UEngine_KismetMathLibrary_MakeBox_Params params;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Loge
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Loge(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Loge");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Loge");

	UEngine_KismetMathLibrary_Loge_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Log
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Base                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Log(float A, float Base)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Log");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Log");

	UEngine_KismetMathLibrary_Log_Params params;
	params.A = A;
	params.Base = Base;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 LineStart                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 LineEnd                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 PlaneOrigin                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PlaneNormal                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          T                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Intersection                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LinePlaneIntersection_OriginNormal(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, float* T, struct FVector* Intersection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal");

	UEngine_KismetMathLibrary_LinePlaneIntersection_OriginNormal_Params params;
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.PlaneOrigin = PlaneOrigin;
	params.PlaneNormal = PlaneNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (T != nullptr)
		*T = params.T;
	if (Intersection != nullptr)
		*Intersection = params.Intersection;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinePlaneIntersection
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 LineStart                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 LineEnd                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FPlane                  APlane                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          T                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Intersection                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LinePlaneIntersection(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FPlane& APlane, float* T, struct FVector* Intersection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection");

	UEngine_KismetMathLibrary_LinePlaneIntersection_Params params;
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.APlane = APlane;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (T != nullptr)
		*T = params.T;
	if (Intersection != nullptr)
		*Intersection = params.Intersection;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColorLerpUsingHSV(const struct FLinearColor& A, const struct FLinearColor& B, float ALPHA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV");

	UEngine_KismetMathLibrary_LinearColorLerpUsingHSV_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColorLerp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColorLerp(const struct FLinearColor& A, const struct FLinearColor& B, float ALPHA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerp");

	UEngine_KismetMathLibrary_LinearColorLerp_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Yellow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Yellow()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Yellow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Yellow");

	UEngine_KismetMathLibrary_LinearColor_Yellow_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_White
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_White()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_White");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_White");

	UEngine_KismetMathLibrary_LinearColor_White_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Transparent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Transparent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Transparent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Transparent");

	UEngine_KismetMathLibrary_LinearColor_Transparent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_ToRGBE
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InLinearColor                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FColor UEngine_KismetMathLibrary::STATIC_LinearColor_ToRGBE(const struct FLinearColor& InLinearColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_ToRGBE");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_ToRGBE");

	UEngine_KismetMathLibrary_LinearColor_ToRGBE_Params params;
	params.InLinearColor = InLinearColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_ToNewOpacity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          InOpacity                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_ToNewOpacity(const struct FLinearColor& InColor, float InOpacity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_ToNewOpacity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_ToNewOpacity");

	UEngine_KismetMathLibrary_LinearColor_ToNewOpacity_Params params;
	params.InColor = InColor;
	params.InOpacity = InOpacity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_SetTemperature
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InOutColor                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          InTemperature                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_LinearColor_SetTemperature(float InTemperature, struct FLinearColor* InOutColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetTemperature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetTemperature");

	UEngine_KismetMathLibrary_LinearColor_SetTemperature_Params params;
	params.InTemperature = InTemperature;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InOutColor != nullptr)
		*InOutColor = params.InOutColor;
}


// Function Engine.KismetMathLibrary.LinearColor_SetRGBA
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InOutColor                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          R                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          G                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_LinearColor_SetRGBA(float R, float G, float B, float A, struct FLinearColor* InOutColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetRGBA");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetRGBA");

	UEngine_KismetMathLibrary_LinearColor_SetRGBA_Params params;
	params.R = R;
	params.G = G;
	params.B = B;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InOutColor != nullptr)
		*InOutColor = params.InOutColor;
}


// Function Engine.KismetMathLibrary.LinearColor_SetRandomHue
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InOutColor                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_LinearColor_SetRandomHue(struct FLinearColor* InOutColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetRandomHue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetRandomHue");

	UEngine_KismetMathLibrary_LinearColor_SetRandomHue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InOutColor != nullptr)
		*InOutColor = params.InOutColor;
}


// Function Engine.KismetMathLibrary.LinearColor_SetFromSRGB
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InOutColor                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FColor                  InSRGB                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_LinearColor_SetFromSRGB(const struct FColor& InSRGB, struct FLinearColor* InOutColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromSRGB");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromSRGB");

	UEngine_KismetMathLibrary_LinearColor_SetFromSRGB_Params params;
	params.InSRGB = InSRGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InOutColor != nullptr)
		*InOutColor = params.InOutColor;
}


// Function Engine.KismetMathLibrary.LinearColor_SetFromPow22
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InOutColor                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FColor                  InColor                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_LinearColor_SetFromPow22(const struct FColor& InColor, struct FLinearColor* InOutColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromPow22");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromPow22");

	UEngine_KismetMathLibrary_LinearColor_SetFromPow22_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InOutColor != nullptr)
		*InOutColor = params.InOutColor;
}


// Function Engine.KismetMathLibrary.LinearColor_SetFromHSV
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InOutColor                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          H                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          S                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          V                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_LinearColor_SetFromHSV(float H, float S, float V, float A, struct FLinearColor* InOutColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromHSV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_SetFromHSV");

	UEngine_KismetMathLibrary_LinearColor_SetFromHSV_Params params;
	params.H = H;
	params.S = S;
	params.V = V;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InOutColor != nullptr)
		*InOutColor = params.InOutColor;
}


// Function Engine.KismetMathLibrary.LinearColor_Set
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InOutColor                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_LinearColor_Set(const struct FLinearColor& InColor, struct FLinearColor* InOutColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Set");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Set");

	UEngine_KismetMathLibrary_LinearColor_Set_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InOutColor != nullptr)
		*InOutColor = params.InOutColor;
}


// Function Engine.KismetMathLibrary.LinearColor_Red
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Red()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Red");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Red");

	UEngine_KismetMathLibrary_LinearColor_Red_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_QuantizeRound
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FColor UEngine_KismetMathLibrary::STATIC_LinearColor_QuantizeRound(const struct FLinearColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_QuantizeRound");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_QuantizeRound");

	UEngine_KismetMathLibrary_LinearColor_QuantizeRound_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Quantize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FColor UEngine_KismetMathLibrary::STATIC_LinearColor_Quantize(const struct FLinearColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Quantize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Quantize");

	UEngine_KismetMathLibrary_LinearColor_Quantize_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_IsNearEqual
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LinearColor_IsNearEqual(const struct FLinearColor& A, const struct FLinearColor& B, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_IsNearEqual");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_IsNearEqual");

	UEngine_KismetMathLibrary_LinearColor_IsNearEqual_Params params;
	params.A = A;
	params.B = B;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Green
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Green()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Green");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Green");

	UEngine_KismetMathLibrary_LinearColor_Green_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Gray
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Gray()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Gray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Gray");

	UEngine_KismetMathLibrary_LinearColor_Gray_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_GetMin
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_LinearColor_GetMin(const struct FLinearColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetMin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetMin");

	UEngine_KismetMathLibrary_LinearColor_GetMin_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_GetMax
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_LinearColor_GetMax(const struct FLinearColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetMax");

	UEngine_KismetMathLibrary_LinearColor_GetMax_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_GetLuminance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_LinearColor_GetLuminance(const struct FLinearColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetLuminance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_GetLuminance");

	UEngine_KismetMathLibrary_LinearColor_GetLuminance_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Distance
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            C1                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            C2                             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_LinearColor_Distance(const struct FLinearColor& C1, const struct FLinearColor& C2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Distance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Distance");

	UEngine_KismetMathLibrary_LinearColor_Distance_Params params;
	params.C1 = C1;
	params.C2 = C2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Desaturated
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          InDesaturation                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Desaturated(const struct FLinearColor& InColor, float InDesaturation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Desaturated");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Desaturated");

	UEngine_KismetMathLibrary_LinearColor_Desaturated_Params params;
	params.InColor = InColor;
	params.InDesaturation = InDesaturation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Blue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Blue()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Blue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Blue");

	UEngine_KismetMathLibrary_LinearColor_Blue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LinearColor_Black
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_LinearColor_Black()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Black");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColor_Black");

	UEngine_KismetMathLibrary_LinearColor_Black_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessLess_VectorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_LessLess_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessLess_VectorRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessLess_VectorRotator");

	UEngine_KismetMathLibrary_LessLess_VectorRotator_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LessEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan");

	UEngine_KismetMathLibrary_LessEqual_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LessEqual_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_IntInt");

	UEngine_KismetMathLibrary_LessEqual_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LessEqual_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_Int64Int64");

	UEngine_KismetMathLibrary_LessEqual_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LessEqual_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_FloatFloat");

	UEngine_KismetMathLibrary_LessEqual_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LessEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime");

	UEngine_KismetMathLibrary_LessEqual_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.LessEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_LessEqual_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_ByteByte");

	UEngine_KismetMathLibrary_LessEqual_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Less_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_TimespanTimespan");

	UEngine_KismetMathLibrary_Less_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Less_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_IntInt");

	UEngine_KismetMathLibrary_Less_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Less_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_Int64Int64");

	UEngine_KismetMathLibrary_Less_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Less_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_FloatFloat");

	UEngine_KismetMathLibrary_Less_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Less_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_DateTimeDateTime");

	UEngine_KismetMathLibrary_Less_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Less_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Less_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_ByteByte");

	UEngine_KismetMathLibrary_Less_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Lerp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Lerp(float A, float B, float ALPHA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Lerp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Lerp");

	UEngine_KismetMathLibrary_Lerp_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsZero2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_IsZero2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsZero2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsZero2D");

	UEngine_KismetMathLibrary_IsZero2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsPointInBoxWithTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              BoxWorldTransform              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_IsPointInBoxWithTransform(const struct FVector& Point, const struct FTransform& BoxWorldTransform, const struct FVector& BoxExtent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBoxWithTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBoxWithTransform");

	UEngine_KismetMathLibrary_IsPointInBoxWithTransform_Params params;
	params.Point = Point;
	params.BoxWorldTransform = BoxWorldTransform;
	params.BoxExtent = BoxExtent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsPointInBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxOrigin                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_IsPointInBox(const struct FVector& Point, const struct FVector& BoxOrigin, const struct FVector& BoxExtent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBox");

	UEngine_KismetMathLibrary_IsPointInBox_Params params;
	params.Point = Point;
	params.BoxOrigin = BoxOrigin;
	params.BoxExtent = BoxExtent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsNearlyZero2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_IsNearlyZero2D(const struct FVector2D& A, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsNearlyZero2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsNearlyZero2D");

	UEngine_KismetMathLibrary_IsNearlyZero2D_Params params;
	params.A = A;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsMorning
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_IsMorning(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsMorning");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsMorning");

	UEngine_KismetMathLibrary_IsMorning_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsLeapYear
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Year                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_IsLeapYear(int Year)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsLeapYear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsLeapYear");

	UEngine_KismetMathLibrary_IsLeapYear_Params params;
	params.Year = Year;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.IsAfternoon
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_IsAfternoon(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsAfternoon");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsAfternoon");

	UEngine_KismetMathLibrary_IsAfternoon_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.InvertTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              T                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_InvertTransform(const struct FTransform& T)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InvertTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InvertTransform");

	UEngine_KismetMathLibrary_InvertTransform_Params params;
	params.T = T;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.InverseTransformRotation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              T                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_InverseTransformRotation(const struct FTransform& T, const struct FRotator& Rotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformRotation");

	UEngine_KismetMathLibrary_InverseTransformRotation_Params params;
	params.T = T;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.InverseTransformLocation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              T                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_InverseTransformLocation(const struct FTransform& T, const struct FVector& Location)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformLocation");

	UEngine_KismetMathLibrary_InverseTransformLocation_Params params;
	params.T = T;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.InverseTransformDirection
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              T                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_InverseTransformDirection(const struct FTransform& T, const struct FVector& Direction)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformDirection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformDirection");

	UEngine_KismetMathLibrary_InverseTransformDirection_Params params;
	params.T = T;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.InRange_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Min                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            Max                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InclusiveMin                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InclusiveMax                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_InRange_IntInt(int Value, int Min, int Max, bool InclusiveMin, bool InclusiveMax)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_IntInt");

	UEngine_KismetMathLibrary_InRange_IntInt_Params params;
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;
	params.InclusiveMin = InclusiveMin;
	params.InclusiveMax = InclusiveMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.InRange_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        Value                          (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        Min                            (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        Max                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InclusiveMin                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InclusiveMax                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_InRange_Int64Int64(int64_t Value, int64_t Min, int64_t Max, bool InclusiveMin, bool InclusiveMax)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_Int64Int64");

	UEngine_KismetMathLibrary_InRange_Int64Int64_Params params;
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;
	params.InclusiveMin = InclusiveMin;
	params.InclusiveMax = InclusiveMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.InRange_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Min                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InclusiveMin                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InclusiveMax                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_InRange_FloatFloat(float Value, float Min, float Max, bool InclusiveMin, bool InclusiveMax)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_FloatFloat");

	UEngine_KismetMathLibrary_InRange_FloatFloat_Params params;
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;
	params.InclusiveMin = InclusiveMin;
	params.InclusiveMax = InclusiveMax;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Hypotenuse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Width                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Height                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Hypotenuse(float Width, float Height)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Hypotenuse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Hypotenuse");

	UEngine_KismetMathLibrary_Hypotenuse_Params params;
	params.Width = Width;
	params.Height = Height;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.HSVToRGBLinear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            HSV                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_HSVToRGBLinear(const struct FLinearColor& HSV)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGBLinear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGBLinear");

	UEngine_KismetMathLibrary_HSVToRGBLinear_Params params;
	params.HSV = HSV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.HSVToRGB_Vector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            HSV                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            RGB                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_HSVToRGB_Vector(const struct FLinearColor& HSV, struct FLinearColor* RGB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB_Vector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB_Vector");

	UEngine_KismetMathLibrary_HSVToRGB_Vector_Params params;
	params.HSV = HSV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (RGB != nullptr)
		*RGB = params.RGB;
}


// Function Engine.KismetMathLibrary.HSVToRGB
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          H                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          S                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          V                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_HSVToRGB(float H, float S, float V, float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB");

	UEngine_KismetMathLibrary_HSVToRGB_Params params;
	params.H = H;
	params.S = S;
	params.V = V;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GridSnap_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Location                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          GridSize                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GridSnap_Float(float Location, float GridSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GridSnap_Float");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GridSnap_Float");

	UEngine_KismetMathLibrary_GridSnap_Float_Params params;
	params.Location = Location;
	params.GridSize = GridSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_GreaterGreater_VectorRotator(const struct FVector& A, const struct FRotator& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator");

	UEngine_KismetMathLibrary_GreaterGreater_VectorRotator_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_GreaterEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan");

	UEngine_KismetMathLibrary_GreaterEqual_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_GreaterEqual_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_IntInt");

	UEngine_KismetMathLibrary_GreaterEqual_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_GreaterEqual_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_Int64Int64");

	UEngine_KismetMathLibrary_GreaterEqual_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_GreaterEqual_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat");

	UEngine_KismetMathLibrary_GreaterEqual_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_GreaterEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime");

	UEngine_KismetMathLibrary_GreaterEqual_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GreaterEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_GreaterEqual_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_ByteByte");

	UEngine_KismetMathLibrary_GreaterEqual_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Greater_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_TimespanTimespan");

	UEngine_KismetMathLibrary_Greater_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Greater_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_IntInt");

	UEngine_KismetMathLibrary_Greater_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Greater_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_Int64Int64");

	UEngine_KismetMathLibrary_Greater_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Greater_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_FloatFloat");

	UEngine_KismetMathLibrary_Greater_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Greater_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_DateTimeDateTime");

	UEngine_KismetMathLibrary_Greater_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Greater_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Greater_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_ByteByte");

	UEngine_KismetMathLibrary_Greater_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetYear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetYear(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYear");

	UEngine_KismetMathLibrary_GetYear_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetYawPitchFromVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Yaw                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_GetYawPitchFromVector(const struct FVector& InVec, float* Yaw, float* Pitch)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYawPitchFromVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYawPitchFromVector");

	UEngine_KismetMathLibrary_GetYawPitchFromVector_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Yaw != nullptr)
		*Yaw = params.Yaw;
	if (Pitch != nullptr)
		*Pitch = params.Pitch;
}


// Function Engine.KismetMathLibrary.GetVectorArrayAverage
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FVector>         Vectors                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_GetVectorArrayAverage(TArray<struct FVector> Vectors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetVectorArrayAverage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetVectorArrayAverage");

	UEngine_KismetMathLibrary_GetVectorArrayAverage_Params params;
	params.Vectors = Vectors;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetUpVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_GetUpVector(const struct FRotator& InRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetUpVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetUpVector");

	UEngine_KismetMathLibrary_GetUpVector_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetTotalSeconds(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalSeconds");

	UEngine_KismetMathLibrary_GetTotalSeconds_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetTotalMinutes(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMinutes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMinutes");

	UEngine_KismetMathLibrary_GetTotalMinutes_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetTotalMilliseconds(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMilliseconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMilliseconds");

	UEngine_KismetMathLibrary_GetTotalMilliseconds_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetTotalHours(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalHours");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalHours");

	UEngine_KismetMathLibrary_GetTotalHours_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTotalDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetTotalDays(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalDays");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalDays");

	UEngine_KismetMathLibrary_GetTotalDays_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTimeOfDay
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_GetTimeOfDay(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTimeOfDay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTimeOfDay");

	UEngine_KismetMathLibrary_GetTimeOfDay_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetTAU
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetTAU()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTAU");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTAU");

	UEngine_KismetMathLibrary_GetTAU_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetSlopeDegreeAngles
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 MyRightYAxis                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 FloorNormal                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 UpVector                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          OutSlopePitchDegreeAngle       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          OutSlopeRollDegreeAngle        (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_GetSlopeDegreeAngles(const struct FVector& MyRightYAxis, const struct FVector& FloorNormal, const struct FVector& UpVector, float* OutSlopePitchDegreeAngle, float* OutSlopeRollDegreeAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSlopeDegreeAngles");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSlopeDegreeAngles");

	UEngine_KismetMathLibrary_GetSlopeDegreeAngles_Params params;
	params.MyRightYAxis = MyRightYAxis;
	params.FloorNormal = FloorNormal;
	params.UpVector = UpVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutSlopePitchDegreeAngle != nullptr)
		*OutSlopePitchDegreeAngle = params.OutSlopePitchDegreeAngle;
	if (OutSlopeRollDegreeAngle != nullptr)
		*OutSlopeRollDegreeAngle = params.OutSlopeRollDegreeAngle;
}


// Function Engine.KismetMathLibrary.GetSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetSeconds(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSeconds");

	UEngine_KismetMathLibrary_GetSeconds_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetSecond
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetSecond(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSecond");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSecond");

	UEngine_KismetMathLibrary_GetSecond_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetRotated2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngleDeg                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_GetRotated2D(const struct FVector2D& A, float AngleDeg)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRotated2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRotated2D");

	UEngine_KismetMathLibrary_GetRotated2D_Params params;
	params.A = A;
	params.AngleDeg = AngleDeg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetRightVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_GetRightVector(const struct FRotator& InRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRightVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRightVector");

	UEngine_KismetMathLibrary_GetRightVector_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetReflectionVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Direction                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SurfaceNormal                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_GetReflectionVector(const struct FVector& Direction, const struct FVector& SurfaceNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetReflectionVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetReflectionVector");

	UEngine_KismetMathLibrary_GetReflectionVector_Params params;
	params.Direction = Direction;
	params.SurfaceNormal = SurfaceNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetPointDistanceToSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SegmentStart                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SegmentEnd                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetPointDistanceToSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPointDistanceToSegment");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPointDistanceToSegment");

	UEngine_KismetMathLibrary_GetPointDistanceToSegment_Params params;
	params.Point = Point;
	params.SegmentStart = SegmentStart;
	params.SegmentEnd = SegmentEnd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetPointDistanceToLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineOrigin                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineDirection                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetPointDistanceToLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPointDistanceToLine");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPointDistanceToLine");

	UEngine_KismetMathLibrary_GetPointDistanceToLine_Params params;
	params.Point = Point;
	params.LineOrigin = LineOrigin;
	params.LineDirection = LineDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetPI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetPI()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPI");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPI");

	UEngine_KismetMathLibrary_GetPI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMonth
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetMonth(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMonth");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMonth");

	UEngine_KismetMathLibrary_GetMonth_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetMinutes(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinutes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinutes");

	UEngine_KismetMathLibrary_GetMinutes_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMinute
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetMinute(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinute");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinute");

	UEngine_KismetMathLibrary_GetMinute_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMinElement
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetMinElement(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinElement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinElement");

	UEngine_KismetMathLibrary_GetMinElement_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMin2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetMin2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMin2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMin2D");

	UEngine_KismetMathLibrary_GetMin2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetMilliseconds(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMilliseconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMilliseconds");

	UEngine_KismetMathLibrary_GetMilliseconds_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMillisecond
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetMillisecond(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMillisecond");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMillisecond");

	UEngine_KismetMathLibrary_GetMillisecond_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMaxElement
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetMaxElement(const struct FVector& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMaxElement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMaxElement");

	UEngine_KismetMathLibrary_GetMaxElement_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetMax2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMax2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMax2D");

	UEngine_KismetMathLibrary_GetMax2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetHours(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHours");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHours");

	UEngine_KismetMathLibrary_GetHours_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetHour12
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetHour12(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour12");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour12");

	UEngine_KismetMathLibrary_GetHour12_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetHour
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetHour(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour");

	UEngine_KismetMathLibrary_GetHour_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetForwardVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_GetForwardVector(const struct FRotator& InRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetForwardVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetForwardVector");

	UEngine_KismetMathLibrary_GetForwardVector_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDuration
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_GetDuration(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDuration");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDuration");

	UEngine_KismetMathLibrary_GetDuration_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDirectionUnitVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 From                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 To                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_GetDirectionUnitVector(const struct FVector& From, const struct FVector& To)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDirectionUnitVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDirectionUnitVector");

	UEngine_KismetMathLibrary_GetDirectionUnitVector_Params params;
	params.From = From;
	params.To = To;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetDays(const struct FTimespan& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDays");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDays");

	UEngine_KismetMathLibrary_GetDays_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDayOfYear
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetDayOfYear(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDayOfYear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDayOfYear");

	UEngine_KismetMathLibrary_GetDayOfYear_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDay
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_GetDay(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDay");

	UEngine_KismetMathLibrary_GetDay_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetDate
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_GetDate(const struct FDateTime& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDate");

	UEngine_KismetMathLibrary_GetDate_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetAzimuthAndElevation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InDirection                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReferenceFrame                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Azimuth                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Elevation                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_GetAzimuthAndElevation(const struct FVector& InDirection, const struct FTransform& ReferenceFrame, float* Azimuth, float* Elevation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAzimuthAndElevation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAzimuthAndElevation");

	UEngine_KismetMathLibrary_GetAzimuthAndElevation_Params params;
	params.InDirection = InDirection;
	params.ReferenceFrame = ReferenceFrame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Azimuth != nullptr)
		*Azimuth = params.Azimuth;
	if (Elevation != nullptr)
		*Elevation = params.Elevation;
}


// Function Engine.KismetMathLibrary.GetAxes
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 X                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Y                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Z                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_GetAxes(const struct FRotator& A, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAxes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAxes");

	UEngine_KismetMathLibrary_GetAxes_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;
}


// Function Engine.KismetMathLibrary.GetAbsMax2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_GetAbsMax2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAbsMax2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAbsMax2D");

	UEngine_KismetMathLibrary_GetAbsMax2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.GetAbs2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_GetAbs2D(const struct FVector2D& A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAbs2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAbs2D");

	UEngine_KismetMathLibrary_GetAbs2D_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FTruncVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVector                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FIntVector              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntVector UEngine_KismetMathLibrary::STATIC_FTruncVector(const struct FVector& InVector)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTruncVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTruncVector");

	UEngine_KismetMathLibrary_FTruncVector_Params params;
	params.InVector = InVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FTrunc64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_FTrunc64(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTrunc64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTrunc64");

	UEngine_KismetMathLibrary_FTrunc64_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FTrunc
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_FTrunc(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTrunc");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FTrunc");

	UEngine_KismetMathLibrary_FTrunc_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromSeconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Seconds                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_FromSeconds(float Seconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromSeconds");

	UEngine_KismetMathLibrary_FromSeconds_Params params;
	params.Seconds = Seconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromMinutes
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Minutes                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_FromMinutes(float Minutes)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMinutes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMinutes");

	UEngine_KismetMathLibrary_FromMinutes_Params params;
	params.Minutes = Minutes;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromMilliseconds
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Milliseconds                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_FromMilliseconds(float Milliseconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMilliseconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMilliseconds");

	UEngine_KismetMathLibrary_FromMilliseconds_Params params;
	params.Milliseconds = Milliseconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromHours
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Hours                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_FromHours(float Hours)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromHours");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromHours");

	UEngine_KismetMathLibrary_FromHours_Params params;
	params.Hours = Hours;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FromDays
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Days                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_FromDays(float Days)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromDays");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromDays");

	UEngine_KismetMathLibrary_FromDays_Params params;
	params.Days = Days;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Fraction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Fraction(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Fraction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Fraction");

	UEngine_KismetMathLibrary_Fraction_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FMod
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Dividend                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Divisor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Remainder                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_FMod(float Dividend, float Divisor, float* Remainder)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMod");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMod");

	UEngine_KismetMathLibrary_FMod_Params params;
	params.Dividend = Dividend;
	params.Divisor = Divisor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Remainder != nullptr)
		*Remainder = params.Remainder;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FMin(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMin");

	UEngine_KismetMathLibrary_FMin_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FMax(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMax");

	UEngine_KismetMathLibrary_FMax_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FloatSpringInterp
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// float                          Current                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Target                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_FloatSpringState SpringState                    (Parm, OutParm, ReferenceParm)
// float                          Stiffness                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          CriticalDampingFactor          (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Mass                           (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FloatSpringInterp(float Current, float Target, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, struct FEngine_FloatSpringState* SpringState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FloatSpringInterp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FloatSpringInterp");

	UEngine_KismetMathLibrary_FloatSpringInterp_Params params;
	params.Current = Current;
	params.Target = Target;
	params.Stiffness = Stiffness;
	params.CriticalDampingFactor = CriticalDampingFactor;
	params.DeltaTime = DeltaTime;
	params.Mass = Mass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SpringState != nullptr)
		*SpringState = params.SpringState;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FixedTurn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          InCurrent                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InDesired                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InDeltaRate                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FixedTurn(float InCurrent, float InDesired, float InDeltaRate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FixedTurn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FixedTurn");

	UEngine_KismetMathLibrary_FixedTurn_Params params;
	params.InCurrent = InCurrent;
	params.InDesired = InDesired;
	params.InDeltaRate = InDeltaRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FInterpTo_Constant
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Current                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FInterpTo_Constant(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo_Constant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo_Constant");

	UEngine_KismetMathLibrary_FInterpTo_Constant_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FInterpTo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Current                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FInterpTo(float Current, float Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo");

	UEngine_KismetMathLibrary_FInterpTo_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FInterpEaseInOut
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Exponent                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FInterpEaseInOut(float A, float B, float ALPHA, float Exponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpEaseInOut");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpEaseInOut");

	UEngine_KismetMathLibrary_FInterpEaseInOut_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;
	params.Exponent = Exponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Segment1Start                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Segment1End                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Segment2Start                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Segment2End                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Segment1Point                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Segment2Point                  (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_FindNearestPointsOnLineSegments(const struct FVector& Segment1Start, const struct FVector& Segment1End, const struct FVector& Segment2Start, const struct FVector& Segment2End, struct FVector* Segment1Point, struct FVector* Segment2Point)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments");

	UEngine_KismetMathLibrary_FindNearestPointsOnLineSegments_Params params;
	params.Segment1Start = Segment1Start;
	params.Segment1End = Segment1End;
	params.Segment2Start = Segment2Start;
	params.Segment2End = Segment2End;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Segment1Point != nullptr)
		*Segment1Point = params.Segment1Point;
	if (Segment2Point != nullptr)
		*Segment2Point = params.Segment2Point;
}


// Function Engine.KismetMathLibrary.FindLookAtRotation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Start                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Target                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_FindLookAtRotation(const struct FVector& Start, const struct FVector& Target)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindLookAtRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindLookAtRotation");

	UEngine_KismetMathLibrary_FindLookAtRotation_Params params;
	params.Start = Start;
	params.Target = Target;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FindClosestPointOnSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SegmentStart                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SegmentEnd                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_FindClosestPointOnSegment(const struct FVector& Point, const struct FVector& SegmentStart, const struct FVector& SegmentEnd)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindClosestPointOnSegment");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindClosestPointOnSegment");

	UEngine_KismetMathLibrary_FindClosestPointOnSegment_Params params;
	params.Point = Point;
	params.SegmentStart = SegmentStart;
	params.SegmentEnd = SegmentEnd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FindClosestPointOnLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 Point                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineOrigin                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineDirection                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_FindClosestPointOnLine(const struct FVector& Point, const struct FVector& LineOrigin, const struct FVector& LineDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindClosestPointOnLine");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindClosestPointOnLine");

	UEngine_KismetMathLibrary_FindClosestPointOnLine_Params params;
	params.Point = Point;
	params.LineOrigin = LineOrigin;
	params.LineDirection = LineDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FFloor64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_FFloor64(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor64");

	UEngine_KismetMathLibrary_FFloor64_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FFloor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_FFloor(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor");

	UEngine_KismetMathLibrary_FFloor_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FClamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Min                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_FClamp(float Value, float Min, float Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FClamp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FClamp");

	UEngine_KismetMathLibrary_FClamp_Params params;
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FCeil64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_FCeil64(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil64");

	UEngine_KismetMathLibrary_FCeil64_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.FCeil
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_FCeil(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil");

	UEngine_KismetMathLibrary_FCeil_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Exp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Exp(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Exp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Exp");

	UEngine_KismetMathLibrary_Exp_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualExactly_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualExactly_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_VectorVector");

	UEngine_KismetMathLibrary_EqualExactly_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualExactly_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualExactly_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_Vector4Vector4");

	UEngine_KismetMathLibrary_EqualExactly_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualExactly_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualExactly_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualExactly_Vector2DVector2D");

	UEngine_KismetMathLibrary_EqualExactly_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_VectorVector");

	UEngine_KismetMathLibrary_EqualEqual_VectorVector_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_Vector4Vector4(const struct FVector4& A, const struct FVector4& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Vector4Vector4");

	UEngine_KismetMathLibrary_EqualEqual_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D");

	UEngine_KismetMathLibrary_EqualEqual_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_TransformTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_TransformTransform(const struct FTransform& A, const struct FTransform& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TransformTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TransformTransform");

	UEngine_KismetMathLibrary_EqualEqual_TransformTransform_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan");

	UEngine_KismetMathLibrary_EqualEqual_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ErrorTolerance                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B, float ErrorTolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator");

	UEngine_KismetMathLibrary_EqualEqual_RotatorRotator_Params params;
	params.A = A;
	params.B = B;
	params.ErrorTolerance = ErrorTolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_QuatQuat
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_QuatQuat(const struct FQuat& A, const struct FQuat& B, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_QuatQuat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_QuatQuat");

	UEngine_KismetMathLibrary_EqualEqual_QuatQuat_Params params;
	params.A = A;
	params.B = B;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_ObjectObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_ObjectObject(class UObject* A, class UObject* B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ObjectObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ObjectObject");

	UEngine_KismetMathLibrary_EqualEqual_ObjectObject_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_NameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_NameName(const struct FName& A, const struct FName& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_NameName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_NameName");

	UEngine_KismetMathLibrary_EqualEqual_NameName_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_MatrixMatrix
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          Tolerance                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B, float Tolerance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_MatrixMatrix");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_MatrixMatrix");

	UEngine_KismetMathLibrary_EqualEqual_MatrixMatrix_Params params;
	params.A = A;
	params.B = B;
	params.Tolerance = Tolerance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_LinearColorLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_LinearColorLinearColor");

	UEngine_KismetMathLibrary_EqualEqual_LinearColorLinearColor_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_IntInt");

	UEngine_KismetMathLibrary_EqualEqual_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_Int64Int64");

	UEngine_KismetMathLibrary_EqualEqual_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_FloatFloat");

	UEngine_KismetMathLibrary_EqualEqual_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime");

	UEngine_KismetMathLibrary_EqualEqual_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_ClassClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_ClassClass(class UClass* A, class UClass* B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ClassClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ClassClass");

	UEngine_KismetMathLibrary_EqualEqual_ClassClass_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ByteByte");

	UEngine_KismetMathLibrary_EqualEqual_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.EqualEqual_BoolBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_EqualEqual_BoolBool(bool A, bool B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_BoolBool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_BoolBool");

	UEngine_KismetMathLibrary_EqualEqual_BoolBool_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Ease
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          BlendExp                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            Steps                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Ease(float A, float B, float ALPHA, TEnumAsByte<FEngine_Engine_EEasingFunc> EasingFunc, float BlendExp, int Steps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Ease");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Ease");

	UEngine_KismetMathLibrary_Ease_Params params;
	params.A = A;
	params.B = B;
	params.ALPHA = ALPHA;
	params.EasingFunc = EasingFunc;
	params.BlendExp = BlendExp;
	params.Steps = Steps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 CurrentSample                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PreviousSample                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxDistance                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinWeight                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxWeight                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_DynamicWeightedMovingAverage_FVector(const struct FVector& CurrentSample, const struct FVector& PreviousSample, float MaxDistance, float MinWeight, float MaxWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FVector");

	UEngine_KismetMathLibrary_DynamicWeightedMovingAverage_FVector_Params params;
	params.CurrentSample = CurrentSample;
	params.PreviousSample = PreviousSample;
	params.MaxDistance = MaxDistance;
	params.MinWeight = MinWeight;
	params.MaxWeight = MaxWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                CurrentSample                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                PreviousSample                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxDistance                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinWeight                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxWeight                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_DynamicWeightedMovingAverage_FRotator(const struct FRotator& CurrentSample, const struct FRotator& PreviousSample, float MaxDistance, float MinWeight, float MaxWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_FRotator");

	UEngine_KismetMathLibrary_DynamicWeightedMovingAverage_FRotator_Params params;
	params.CurrentSample = CurrentSample;
	params.PreviousSample = PreviousSample;
	params.MaxDistance = MaxDistance;
	params.MinWeight = MinWeight;
	params.MaxWeight = MaxWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          CurrentSample                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          PreviousSample                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxDistance                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinWeight                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxWeight                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DynamicWeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float MaxDistance, float MinWeight, float MaxWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_Float");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DynamicWeightedMovingAverage_Float");

	UEngine_KismetMathLibrary_DynamicWeightedMovingAverage_Float_Params params;
	params.CurrentSample = CurrentSample;
	params.PreviousSample = PreviousSample;
	params.MaxDistance = MaxDistance;
	params.MinWeight = MinWeight;
	params.MaxWeight = MaxWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DotProduct2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DotProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DotProduct2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DotProduct2D");

	UEngine_KismetMathLibrary_DotProduct2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Dot_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Dot_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Dot_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Dot_VectorVector");

	UEngine_KismetMathLibrary_Dot_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Divide_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorVector");

	UEngine_KismetMathLibrary_Divide_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Divide_VectorInt(const struct FVector& A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorInt");

	UEngine_KismetMathLibrary_Divide_VectorInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Divide_VectorFloat(const struct FVector& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorFloat");

	UEngine_KismetMathLibrary_Divide_VectorFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Divide_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector4Vector4");

	UEngine_KismetMathLibrary_Divide_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Divide_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DVector2D");

	UEngine_KismetMathLibrary_Divide_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Divide_Vector2DFloat(const struct FVector2D& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DFloat");

	UEngine_KismetMathLibrary_Divide_Vector2DFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_TimespanFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// float                          Scalar                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_Divide_TimespanFloat(const struct FTimespan& A, float Scalar)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_TimespanFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_TimespanFloat");

	UEngine_KismetMathLibrary_Divide_TimespanFloat_Params params;
	params.A = A;
	params.Scalar = Scalar;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Divide_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_LinearColorLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_LinearColorLinearColor");

	UEngine_KismetMathLibrary_Divide_LinearColorLinearColor_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Divide_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_IntInt");

	UEngine_KismetMathLibrary_Divide_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Divide_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Int64Int64");

	UEngine_KismetMathLibrary_Divide_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Divide_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_FloatFloat");

	UEngine_KismetMathLibrary_Divide_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Divide_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_Divide_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_ByteByte");

	UEngine_KismetMathLibrary_Divide_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DistanceSquared2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               v1                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               v2                             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DistanceSquared2D(const struct FVector2D& v1, const struct FVector2D& v2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DistanceSquared2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DistanceSquared2D");

	UEngine_KismetMathLibrary_DistanceSquared2D_Params params;
	params.v1 = v1;
	params.v2 = v2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Distance2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               v1                             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               v2                             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Distance2D(const struct FVector2D& v1, const struct FVector2D& v2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Distance2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Distance2D");

	UEngine_KismetMathLibrary_Distance2D_Params params;
	params.v1 = v1;
	params.v2 = v2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegTan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegTan(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegTan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegTan");

	UEngine_KismetMathLibrary_DegTan_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegSin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegSin(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegSin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegSin");

	UEngine_KismetMathLibrary_DegSin_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegreesToRadians
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegreesToRadians(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegreesToRadians");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegreesToRadians");

	UEngine_KismetMathLibrary_DegreesToRadians_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegCos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegCos(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegCos");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegCos");

	UEngine_KismetMathLibrary_DegCos_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAtan2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegAtan2(float Y, float X)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan2");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan2");

	UEngine_KismetMathLibrary_DegAtan2_Params params;
	params.Y = Y;
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAtan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegAtan(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan");

	UEngine_KismetMathLibrary_DegAtan_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAsin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegAsin(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAsin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAsin");

	UEngine_KismetMathLibrary_DegAsin_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DegAcos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_DegAcos(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAcos");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAcos");

	UEngine_KismetMathLibrary_DegAcos_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DaysInYear
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Year                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_DaysInYear(int Year)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInYear");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInYear");

	UEngine_KismetMathLibrary_DaysInYear_Params params;
	params.Year = Year;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DaysInMonth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Year                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            Month                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_DaysInMonth(int Year, int Month)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInMonth");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInMonth");

	UEngine_KismetMathLibrary_DaysInMonth_Params params;
	params.Year = Year;
	params.Month = Month;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeMinValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_DateTimeMinValue()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMinValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMinValue");

	UEngine_KismetMathLibrary_DateTimeMinValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeMaxValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_DateTimeMaxValue()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMaxValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMaxValue");

	UEngine_KismetMathLibrary_DateTimeMaxValue_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeFromString
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 DateTimeString                 (Parm, ZeroConstructor)
// struct FDateTime               Result                         (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_DateTimeFromString(const struct FString& DateTimeString, struct FDateTime* Result)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromString");

	UEngine_KismetMathLibrary_DateTimeFromString_Params params;
	params.DateTimeString = DateTimeString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.DateTimeFromIsoString
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 IsoString                      (Parm, ZeroConstructor)
// struct FDateTime               Result                         (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_DateTimeFromIsoString(const struct FString& IsoString, struct FDateTime* Result)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromIsoString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeFromIsoString");

	UEngine_KismetMathLibrary_DateTimeFromIsoString_Params params;
	params.IsoString = IsoString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Result != nullptr)
		*Result = params.Result;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.CrossProduct2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_CrossProduct2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CrossProduct2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CrossProduct2D");

	UEngine_KismetMathLibrary_CrossProduct2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Cross_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Cross_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cross_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cross_VectorVector");

	UEngine_KismetMathLibrary_Cross_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.CreateVectorFromYawPitch
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Yaw                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Length                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_CreateVectorFromYawPitch(float Yaw, float Pitch, float Length)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CreateVectorFromYawPitch");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CreateVectorFromYawPitch");

	UEngine_KismetMathLibrary_CreateVectorFromYawPitch_Params params;
	params.Yaw = Yaw;
	params.Pitch = Pitch;
	params.Length = Length;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Cos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Cos(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cos");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cos");

	UEngine_KismetMathLibrary_Cos_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ConvertTransformToRelative
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              Transform                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              ParentTransform                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_ConvertTransformToRelative(const struct FTransform& Transform, const struct FTransform& ParentTransform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ConvertTransformToRelative");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ConvertTransformToRelative");

	UEngine_KismetMathLibrary_ConvertTransformToRelative_Params params;
	params.Transform = Transform;
	params.ParentTransform = ParentTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVector                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Conv_VectorToVector2D(const struct FVector& InVector)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToVector2D");

	UEngine_KismetMathLibrary_Conv_VectorToVector2D_Params params;
	params.InVector = InVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToTransform
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InLocation                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_Conv_VectorToTransform(const struct FVector& InLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToTransform");

	UEngine_KismetMathLibrary_Conv_VectorToTransform_Params params;
	params.InLocation = InLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToRotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_Conv_VectorToRotator(const struct FVector& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToRotator");

	UEngine_KismetMathLibrary_Conv_VectorToRotator_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToQuaterion
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Conv_VectorToQuaterion(const struct FVector& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToQuaterion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToQuaterion");

	UEngine_KismetMathLibrary_Conv_VectorToQuaterion_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_VectorToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Conv_VectorToLinearColor(const struct FVector& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToLinearColor");

	UEngine_KismetMathLibrary_Conv_VectorToLinearColor_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector4ToVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                InVector4                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Conv_Vector4ToVector(const struct FVector4& InVector4)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToVector");

	UEngine_KismetMathLibrary_Conv_Vector4ToVector_Params params;
	params.InVector4 = InVector4;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector4ToRotator
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                InVec                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_Conv_Vector4ToRotator(const struct FVector4& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToRotator");

	UEngine_KismetMathLibrary_Conv_Vector4ToRotator_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector4ToQuaterion
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                InVec                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Conv_Vector4ToQuaterion(const struct FVector4& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToQuaterion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector4ToQuaterion");

	UEngine_KismetMathLibrary_Conv_Vector4ToQuaterion_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector2DToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               InVector2D                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Conv_Vector2DToVector(const struct FVector2D& InVector2D, float Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToVector");

	UEngine_KismetMathLibrary_Conv_Vector2DToVector_Params params;
	params.InVector2D = InVector2D;
	params.Z = Z;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_Vector2DToIntPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               InVector2D                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FIntPoint               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntPoint UEngine_KismetMathLibrary::STATIC_Conv_Vector2DToIntPoint(const struct FVector2D& InVector2D)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToIntPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToIntPoint");

	UEngine_KismetMathLibrary_Conv_Vector2DToIntPoint_Params params;
	params.InVector2D = InVector2D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_TransformToMatrix
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              Transform                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Conv_TransformToMatrix(const struct FTransform& Transform)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_TransformToMatrix");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_TransformToMatrix");

	UEngine_KismetMathLibrary_Conv_TransformToMatrix_Params params;
	params.Transform = Transform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_RotatorToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Conv_RotatorToVector(const struct FRotator& InRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToVector");

	UEngine_KismetMathLibrary_Conv_RotatorToVector_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_RotatorToTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRotator                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_Conv_RotatorToTransform(const struct FRotator& InRotator)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToTransform");

	UEngine_KismetMathLibrary_Conv_RotatorToTransform_Params params;
	params.InRotator = InRotator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_MatrixToTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 InMatrix                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_Conv_MatrixToTransform(const struct FMatrix& InMatrix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_MatrixToTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_MatrixToTransform");

	UEngine_KismetMathLibrary_Conv_MatrixToTransform_Params params;
	params.InMatrix = InMatrix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_MatrixToRotator
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 InMatrix                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_Conv_MatrixToRotator(const struct FMatrix& InMatrix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_MatrixToRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_MatrixToRotator");

	UEngine_KismetMathLibrary_Conv_MatrixToRotator_Params params;
	params.InMatrix = InMatrix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_LinearColorToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InLinearColor                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Conv_LinearColorToVector(const struct FLinearColor& InLinearColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToVector");

	UEngine_KismetMathLibrary_Conv_LinearColorToVector_Params params;
	params.InLinearColor = InLinearColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_LinearColorToColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InLinearColor                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           InUseSRGB                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FColor UEngine_KismetMathLibrary::STATIC_Conv_LinearColorToColor(const struct FLinearColor& InLinearColor, bool InUseSRGB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToColor");

	UEngine_KismetMathLibrary_Conv_LinearColorToColor_Params params;
	params.InLinearColor = InLinearColor;
	params.InUseSRGB = InUseSRGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntVectorToVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector              InIntVector                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Conv_IntVectorToVector(const struct FIntVector& InIntVector)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntVectorToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntVectorToVector");

	UEngine_KismetMathLibrary_Conv_IntVectorToVector_Params params;
	params.InIntVector = InIntVector;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToIntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FIntVector              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FIntVector UEngine_KismetMathLibrary::STATIC_Conv_IntToIntVector(int inInt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToIntVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToIntVector");

	UEngine_KismetMathLibrary_Conv_IntToIntVector_Params params;
	params.inInt = inInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Conv_IntToInt64(int inInt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToInt64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToInt64");

	UEngine_KismetMathLibrary_Conv_IntToInt64_Params params;
	params.inInt = inInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Conv_IntToFloat(int inInt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToFloat");

	UEngine_KismetMathLibrary_Conv_IntToFloat_Params params;
	params.inInt = inInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_Conv_IntToByte(int inInt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToByte");

	UEngine_KismetMathLibrary_Conv_IntToByte_Params params;
	params.inInt = inInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_IntToBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_Conv_IntToBool(int inInt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToBool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToBool");

	UEngine_KismetMathLibrary_Conv_IntToBool_Params params;
	params.inInt = inInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_FloatToVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          InFloat                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Conv_FloatToVector(float InFloat)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToVector");

	UEngine_KismetMathLibrary_Conv_FloatToVector_Params params;
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_FloatToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          InFloat                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Conv_FloatToLinearColor(float InFloat)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToLinearColor");

	UEngine_KismetMathLibrary_Conv_FloatToLinearColor_Params params;
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ColorToLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FColor                  InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Conv_ColorToLinearColor(const struct FColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ColorToLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ColorToLinearColor");

	UEngine_KismetMathLibrary_Conv_ColorToLinearColor_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ByteToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  InByte                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Conv_ByteToInt(unsigned char InByte)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToInt");

	UEngine_KismetMathLibrary_Conv_ByteToInt_Params params;
	params.InByte = InByte;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_ByteToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  InByte                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Conv_ByteToFloat(unsigned char InByte)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToFloat");

	UEngine_KismetMathLibrary_Conv_ByteToFloat_Params params;
	params.InByte = InByte;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_BoolToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           InBool                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Conv_BoolToInt(bool InBool)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToInt");

	UEngine_KismetMathLibrary_Conv_BoolToInt_Params params;
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_BoolToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           InBool                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Conv_BoolToFloat(bool InBool)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToFloat");

	UEngine_KismetMathLibrary_Conv_BoolToFloat_Params params;
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Conv_BoolToByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           InBool                         (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_Conv_BoolToByte(bool InBool)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToByte");

	UEngine_KismetMathLibrary_Conv_BoolToByte_Params params;
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ComposeTransforms
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_KismetMathLibrary::STATIC_ComposeTransforms(const struct FTransform& A, const struct FTransform& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeTransforms");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeTransforms");

	UEngine_KismetMathLibrary_ComposeTransforms_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ComposeRotators
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_KismetMathLibrary::STATIC_ComposeRotators(const struct FRotator& A, const struct FRotator& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeRotators");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeRotators");

	UEngine_KismetMathLibrary_ComposeRotators_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClassIsChildOf
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  TestClass                      (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  ParentClass                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_ClassIsChildOf(class UClass* TestClass, class UClass* ParentClass)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClassIsChildOf");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClassIsChildOf");

	UEngine_KismetMathLibrary_ClassIsChildOf_Params params;
	params.TestClass = TestClass;
	params.ParentClass = ParentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampVectorSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          Min                            (Parm, ZeroConstructor, IsPlainOldData)
// float                          Max                            (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_ClampVectorSize(const struct FVector& A, float Min, float Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampVectorSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampVectorSize");

	UEngine_KismetMathLibrary_ClampVectorSize_Params params;
	params.A = A;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampInt64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        Value                          (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        Min                            (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        Max                            (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_ClampInt64(int64_t Value, int64_t Min, int64_t Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampInt64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampInt64");

	UEngine_KismetMathLibrary_ClampInt64_Params params;
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampAxis
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Angle                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_ClampAxis(float Angle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAxis");

	UEngine_KismetMathLibrary_ClampAxis_Params params;
	params.Angle = Angle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampAxes2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinAxisVal                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxAxisVal                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_ClampAxes2D(const struct FVector2D& A, float MinAxisVal, float MaxAxisVal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAxes2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAxes2D");

	UEngine_KismetMathLibrary_ClampAxes2D_Params params;
	params.A = A;
	params.MinAxisVal = MinAxisVal;
	params.MaxAxisVal = MaxAxisVal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.ClampAngle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          AngleDegrees                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          MinAngleDegrees                (Parm, ZeroConstructor, IsPlainOldData)
// float                          MaxAngleDegrees                (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAngle");

	UEngine_KismetMathLibrary_ClampAngle_Params params;
	params.AngleDegrees = AngleDegrees;
	params.MinAngleDegrees = MinAngleDegrees;
	params.MaxAngleDegrees = MaxAngleDegrees;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Clamp
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Min                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            Max                            (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Clamp(int Value, int Min, int Max)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Clamp");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Clamp");

	UEngine_KismetMathLibrary_Clamp_Params params;
	params.Value = Value;
	params.Min = Min;
	params.Max = Max;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.CInterpTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            Current                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Target                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          DeltaTime                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          InterpSpeed                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_CInterpTo(const struct FLinearColor& Current, const struct FLinearColor& Target, float DeltaTime, float InterpSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CInterpTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CInterpTo");

	UEngine_KismetMathLibrary_CInterpTo_Params params;
	params.Current = Current;
	params.Target = Target;
	params.DeltaTime = DeltaTime;
	params.InterpSpeed = InterpSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.BreakVector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                InVec                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// float                          X                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          W                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakVector4(const struct FVector4& InVec, float* X, float* Y, float* Z, float* W)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector4");

	UEngine_KismetMathLibrary_BreakVector4_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;
	if (W != nullptr)
		*W = params.W;
}


// Function Engine.KismetMathLibrary.BreakVector2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          X                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakVector2D(const struct FVector2D& InVec, float* X, float* Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector2D");

	UEngine_KismetMathLibrary_BreakVector2D_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
}


// Function Engine.KismetMathLibrary.BreakVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          X                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Y                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Z                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakVector(const struct FVector& InVec, float* X, float* Y, float* Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector");

	UEngine_KismetMathLibrary_BreakVector_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;
}


// Function Engine.KismetMathLibrary.BreakTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              InTransform                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 Location                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Scale                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakTransform(const struct FTransform& InTransform, struct FVector* Location, struct FRotator* Rotation, struct FVector* Scale)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTransform");

	UEngine_KismetMathLibrary_BreakTransform_Params params;
	params.InTransform = InTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Location != nullptr)
		*Location = params.Location;
	if (Rotation != nullptr)
		*Rotation = params.Rotation;
	if (Scale != nullptr)
		*Scale = params.Scale;
}


// Function Engine.KismetMathLibrary.BreakTimespan2
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               InTimespan                     (Parm, ZeroConstructor)
// int                            Days                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Hours                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Minutes                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Seconds                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            FractionNano                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakTimespan2(const struct FTimespan& InTimespan, int* Days, int* Hours, int* Minutes, int* Seconds, int* FractionNano)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTimespan2");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTimespan2");

	UEngine_KismetMathLibrary_BreakTimespan2_Params params;
	params.InTimespan = InTimespan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Days != nullptr)
		*Days = params.Days;
	if (Hours != nullptr)
		*Hours = params.Hours;
	if (Minutes != nullptr)
		*Minutes = params.Minutes;
	if (Seconds != nullptr)
		*Seconds = params.Seconds;
	if (FractionNano != nullptr)
		*FractionNano = params.FractionNano;
}


// Function Engine.KismetMathLibrary.BreakTimespan
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               InTimespan                     (Parm, ZeroConstructor)
// int                            Days                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Hours                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Minutes                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Seconds                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Milliseconds                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakTimespan(const struct FTimespan& InTimespan, int* Days, int* Hours, int* Minutes, int* Seconds, int* Milliseconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTimespan");

	UEngine_KismetMathLibrary_BreakTimespan_Params params;
	params.InTimespan = InTimespan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Days != nullptr)
		*Days = params.Days;
	if (Hours != nullptr)
		*Hours = params.Hours;
	if (Minutes != nullptr)
		*Minutes = params.Minutes;
	if (Seconds != nullptr)
		*Seconds = params.Seconds;
	if (Milliseconds != nullptr)
		*Milliseconds = params.Milliseconds;
}


// Function Engine.KismetMathLibrary.BreakRotIntoAxes
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 X                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Y                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Z                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakRotIntoAxes(const struct FRotator& InRot, struct FVector* X, struct FVector* Y, struct FVector* Z)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotIntoAxes");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotIntoAxes");

	UEngine_KismetMathLibrary_BreakRotIntoAxes_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (X != nullptr)
		*X = params.X;
	if (Y != nullptr)
		*Y = params.Y;
	if (Z != nullptr)
		*Z = params.Z;
}


// Function Engine.KismetMathLibrary.BreakRotator
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Roll                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Pitch                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          Yaw                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakRotator(const struct FRotator& InRot, float* Roll, float* Pitch, float* Yaw)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotator");

	UEngine_KismetMathLibrary_BreakRotator_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Roll != nullptr)
		*Roll = params.Roll;
	if (Pitch != nullptr)
		*Pitch = params.Pitch;
	if (Yaw != nullptr)
		*Yaw = params.Yaw;
}


// Function Engine.KismetMathLibrary.BreakRandomStream
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRandomStream           InRandomStream                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// int                            InitialSeed                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakRandomStream(const struct FRandomStream& InRandomStream, int* InitialSeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRandomStream");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRandomStream");

	UEngine_KismetMathLibrary_BreakRandomStream_Params params;
	params.InRandomStream = InRandomStream;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InitialSeed != nullptr)
		*InitialSeed = params.InitialSeed;
}


// Function Engine.KismetMathLibrary.BreakQualifiedFrameTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQualifiedFrameTime     InFrameTime                    (ConstParm, Parm, OutParm, ReferenceParm)
// struct FFrameNumber            Frame                          (Parm, OutParm)
// struct FFrameRate              FrameRate                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          SubFrame                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakQualifiedFrameTime(const struct FQualifiedFrameTime& InFrameTime, struct FFrameNumber* Frame, struct FFrameRate* FrameRate, float* SubFrame)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakQualifiedFrameTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakQualifiedFrameTime");

	UEngine_KismetMathLibrary_BreakQualifiedFrameTime_Params params;
	params.InFrameTime = InFrameTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Frame != nullptr)
		*Frame = params.Frame;
	if (FrameRate != nullptr)
		*FrameRate = params.FrameRate;
	if (SubFrame != nullptr)
		*SubFrame = params.SubFrame;
}


// Function Engine.KismetMathLibrary.BreakFrameRate
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrameRate              InFrameRate                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            Numerator                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Denominator                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakFrameRate(const struct FFrameRate& InFrameRate, int* Numerator, int* Denominator)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakFrameRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakFrameRate");

	UEngine_KismetMathLibrary_BreakFrameRate_Params params;
	params.InFrameRate = InFrameRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Numerator != nullptr)
		*Numerator = params.Numerator;
	if (Denominator != nullptr)
		*Denominator = params.Denominator;
}


// Function Engine.KismetMathLibrary.BreakDateTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               InDateTime                     (Parm, ZeroConstructor)
// int                            Year                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Month                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Day                            (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Hour                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Minute                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Second                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Millisecond                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakDateTime(const struct FDateTime& InDateTime, int* Year, int* Month, int* Day, int* Hour, int* Minute, int* Second, int* Millisecond)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakDateTime");

	UEngine_KismetMathLibrary_BreakDateTime_Params params;
	params.InDateTime = InDateTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Year != nullptr)
		*Year = params.Year;
	if (Month != nullptr)
		*Month = params.Month;
	if (Day != nullptr)
		*Day = params.Day;
	if (Hour != nullptr)
		*Hour = params.Hour;
	if (Minute != nullptr)
		*Minute = params.Minute;
	if (Second != nullptr)
		*Second = params.Second;
	if (Millisecond != nullptr)
		*Millisecond = params.Millisecond;
}


// Function Engine.KismetMathLibrary.BreakColor
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          R                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          G                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          A                              (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetMathLibrary::STATIC_BreakColor(const struct FLinearColor& InColor, float* R, float* G, float* B, float* A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakColor");

	UEngine_KismetMathLibrary_BreakColor_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (R != nullptr)
		*R = params.R;
	if (G != nullptr)
		*G = params.G;
	if (B != nullptr)
		*B = params.B;
	if (A != nullptr)
		*A = params.A;
}


// Function Engine.KismetMathLibrary.BooleanXOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_BooleanXOR(bool A, bool B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanXOR");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanXOR");

	UEngine_KismetMathLibrary_BooleanXOR_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_BooleanOR(bool A, bool B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanOR");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanOR");

	UEngine_KismetMathLibrary_BooleanOR_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanNOR
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_BooleanNOR(bool A, bool B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNOR");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNOR");

	UEngine_KismetMathLibrary_BooleanNOR_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanNAND
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_BooleanNAND(bool A, bool B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNAND");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanNAND");

	UEngine_KismetMathLibrary_BooleanNAND_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.BooleanAND
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           A                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           B                              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetMathLibrary::STATIC_BooleanAND(bool A, bool B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanAND");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanAND");

	UEngine_KismetMathLibrary_BooleanAND_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.BMin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_BMin(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BMin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BMin");

	UEngine_KismetMathLibrary_BMin_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.BMax
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_BMax(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BMax");

	UEngine_KismetMathLibrary_BMax_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Atan2
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Y                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          X                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Atan2(float Y, float X)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan2");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan2");

	UEngine_KismetMathLibrary_Atan2_Params params;
	params.Y = Y;
	params.X = X;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Atan
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Atan(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan");

	UEngine_KismetMathLibrary_Atan_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Asin
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Asin(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Asin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Asin");

	UEngine_KismetMathLibrary_Asin_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.And_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_And_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_IntInt");

	UEngine_KismetMathLibrary_And_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.And_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_And_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_Int64Int64");

	UEngine_KismetMathLibrary_And_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_VectorVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Add_VectorVector(const struct FVector& A, const struct FVector& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorVector");

	UEngine_KismetMathLibrary_Add_VectorVector_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_VectorInt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Add_VectorInt(const struct FVector& A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorInt");

	UEngine_KismetMathLibrary_Add_VectorInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_VectorFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_KismetMathLibrary::STATIC_Add_VectorFloat(const struct FVector& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorFloat");

	UEngine_KismetMathLibrary_Add_VectorFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Vector4Vector4
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector4                A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector4                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector4 UEngine_KismetMathLibrary::STATIC_Add_Vector4Vector4(const struct FVector4& A, const struct FVector4& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector4Vector4");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector4Vector4");

	UEngine_KismetMathLibrary_Add_Vector4Vector4_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Vector2DVector2D
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Add_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DVector2D");

	UEngine_KismetMathLibrary_Add_Vector2DVector2D_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Vector2DFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_KismetMathLibrary::STATIC_Add_Vector2DFloat(const struct FVector2D& A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DFloat");

	UEngine_KismetMathLibrary_Add_Vector2DFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_TimespanTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// struct FTimespan               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FTimespan UEngine_KismetMathLibrary::STATIC_Add_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_TimespanTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_TimespanTimespan");

	UEngine_KismetMathLibrary_Add_TimespanTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_QuatQuat
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FQuat                   A                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   B                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FQuat                   ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FQuat UEngine_KismetMathLibrary::STATIC_Add_QuatQuat(const struct FQuat& A, const struct FQuat& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_QuatQuat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_QuatQuat");

	UEngine_KismetMathLibrary_Add_QuatQuat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_MatrixMatrix
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FMatrix                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FMatrix UEngine_KismetMathLibrary::STATIC_Add_MatrixMatrix(const struct FMatrix& A, const struct FMatrix& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_MatrixMatrix");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_MatrixMatrix");

	UEngine_KismetMathLibrary_Add_MatrixMatrix_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_LinearColorLinearColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            A                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            B                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetMathLibrary::STATIC_Add_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_LinearColorLinearColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_LinearColorLinearColor");

	UEngine_KismetMathLibrary_Add_LinearColorLinearColor_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_IntInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            B                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Add_IntInt(int A, int B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_IntInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_IntInt");

	UEngine_KismetMathLibrary_Add_IntInt_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_Int64Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        B                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Add_Int64Int64(int64_t A, int64_t B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Int64Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Int64Int64");

	UEngine_KismetMathLibrary_Add_Int64Int64_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          B                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Add_FloatFloat(float A, float B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_FloatFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_FloatFloat");

	UEngine_KismetMathLibrary_Add_FloatFloat_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_DateTimeTimespan
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FTimespan               B                              (Parm, ZeroConstructor)
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_Add_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeTimespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeTimespan");

	UEngine_KismetMathLibrary_Add_DateTimeTimespan_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_DateTimeDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               A                              (Parm, ZeroConstructor)
// struct FDateTime               B                              (Parm, ZeroConstructor)
// struct FDateTime               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FDateTime UEngine_KismetMathLibrary::STATIC_Add_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeDateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeDateTime");

	UEngine_KismetMathLibrary_Add_DateTimeDateTime_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Add_ByteByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  A                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  B                              (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetMathLibrary::STATIC_Add_ByteByte(unsigned char A, unsigned char B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_ByteByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_ByteByte");

	UEngine_KismetMathLibrary_Add_ByteByte_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Acos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Acos(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Acos");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Acos");

	UEngine_KismetMathLibrary_Acos_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Abs_Int64
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        A                              (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetMathLibrary::STATIC_Abs_Int64(int64_t A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int64");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int64");

	UEngine_KismetMathLibrary_Abs_Int64_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Abs_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            A                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetMathLibrary::STATIC_Abs_Int(int A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int");

	UEngine_KismetMathLibrary_Abs_Int_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetMathLibrary.Abs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          A                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetMathLibrary::STATIC_Abs(float A)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs");

	UEngine_KismetMathLibrary_Abs_Params params;
	params.A = A;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.MarkBit
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetNodeHelperLibrary::STATIC_MarkBit(int Index, int* Data)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.MarkBit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.MarkBit");

	UEngine_KismetNodeHelperLibrary_MarkBit_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumBits                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetNodeHelperLibrary::STATIC_HasUnmarkedBit(int Data, int NumBits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit");

	UEngine_KismetNodeHelperLibrary_HasUnmarkedBit_Params params;
	params.Data = Data;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.HasMarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumBits                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetNodeHelperLibrary::STATIC_HasMarkedBit(int Data, int NumBits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasMarkedBit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasMarkedBit");

	UEngine_KismetNodeHelperLibrary_HasMarkedBit_Params params;
	params.Data = Data;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetValidValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                   Enum                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  EnumeratorValue                (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetNodeHelperLibrary::STATIC_GetValidValue(class UEnum* Enum, unsigned char EnumeratorValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetValidValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetValidValue");

	UEngine_KismetNodeHelperLibrary_GetValidValue_Params params;
	params.Enum = Enum;
	params.EnumeratorValue = EnumeratorValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            StartIdx                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumBits                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bRandom                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetNodeHelperLibrary::STATIC_GetUnmarkedBit(int Data, int StartIdx, int NumBits, bool bRandom)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit");

	UEngine_KismetNodeHelperLibrary_GetUnmarkedBit_Params params;
	params.Data = Data;
	params.StartIdx = StartIdx;
	params.NumBits = NumBits;
	params.bRandom = bRandom;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            StartIdx                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumBits                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetNodeHelperLibrary::STATIC_GetRandomUnmarkedBit(int Data, int StartIdx, int NumBits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit");

	UEngine_KismetNodeHelperLibrary_GetRandomUnmarkedBit_Params params;
	params.Data = Data;
	params.StartIdx = StartIdx;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            StartIdx                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumBits                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetNodeHelperLibrary::STATIC_GetFirstUnmarkedBit(int Data, int StartIdx, int NumBits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit");

	UEngine_KismetNodeHelperLibrary_GetFirstUnmarkedBit_Params params;
	params.Data = Data;
	params.StartIdx = StartIdx;
	params.NumBits = NumBits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                   Enum                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  EnumeratorIndex                (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetNodeHelperLibrary::STATIC_GetEnumeratorValueFromIndex(class UEnum* Enum, unsigned char EnumeratorIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex");

	UEngine_KismetNodeHelperLibrary_GetEnumeratorValueFromIndex_Params params;
	params.Enum = Enum;
	params.EnumeratorIndex = EnumeratorIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                   Enum                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  EnumeratorValue                (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetNodeHelperLibrary::STATIC_GetEnumeratorUserFriendlyName(class UEnum* Enum, unsigned char EnumeratorValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName");

	UEngine_KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName_Params params;
	params.Enum = Enum;
	params.EnumeratorValue = EnumeratorValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.GetEnumeratorName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEnum*                   Enum                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  EnumeratorValue                (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_KismetNodeHelperLibrary::STATIC_GetEnumeratorName(class UEnum* Enum, unsigned char EnumeratorValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorName");

	UEngine_KismetNodeHelperLibrary_GetEnumeratorName_Params params;
	params.Enum = Enum;
	params.EnumeratorValue = EnumeratorValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetNodeHelperLibrary.ClearBit
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetNodeHelperLibrary::STATIC_ClearBit(int Index, int* Data)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearBit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearBit");

	UEngine_KismetNodeHelperLibrary_ClearBit_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.KismetNodeHelperLibrary.ClearAllBits
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetNodeHelperLibrary::STATIC_ClearAllBits(int* Data)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearAllBits");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearAllBits");

	UEngine_KismetNodeHelperLibrary_ClearAllBits_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Data != nullptr)
		*Data = params.Data;
}


// Function Engine.KismetNodeHelperLibrary.BitIsMarked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Data                           (Parm, ZeroConstructor, IsPlainOldData)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetNodeHelperLibrary::STATIC_BitIsMarked(int Data, int Index)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.BitIsMarked");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.BitIsMarked");

	UEngine_KismetNodeHelperLibrary_BitIsMarked_Params params;
	params.Data = Data;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.SetCastInsetShadowForAllAttachments
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* PrimitiveComponent             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// bool                           bCastInsetShadow               (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLightAttachmentsAsGroup       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetRenderingLibrary::STATIC_SetCastInsetShadowForAllAttachments(class UEngine_PrimitiveComponent* PrimitiveComponent, bool bCastInsetShadow, bool bLightAttachmentsAsGroup)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.SetCastInsetShadowForAllAttachments");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.SetCastInsetShadowForAllAttachments");

	UEngine_KismetRenderingLibrary_SetCastInsetShadowForAllAttachments_Params params;
	params.PrimitiveComponent = PrimitiveComponent;
	params.bCastInsetShadow = bCastInsetShadow;
	params.bLightAttachmentsAsGroup = bLightAttachmentsAsGroup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_TextureRenderTarget2D* RenderTarget                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Name                           (Parm, ZeroConstructor)
// TEnumAsByte<FEngine_Engine_ETextureCompressionSettings> CompressionSettings            (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETextureMipGenSettings> MipSettings                    (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture2D*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Texture2D* UEngine_KismetRenderingLibrary::STATIC_RenderTargetCreateStaticTexture2DEditorOnly(class UEngine_TextureRenderTarget2D* RenderTarget, const struct FString& Name, TEnumAsByte<FEngine_Engine_ETextureCompressionSettings> CompressionSettings, TEnumAsByte<FEngine_Engine_ETextureMipGenSettings> MipSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly");

	UEngine_KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly_Params params;
	params.RenderTarget = RenderTarget;
	params.Name = Name;
	params.CompressionSettings = CompressionSettings;
	params.MipSettings = MipSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetRenderingLibrary::STATIC_ReleaseRenderTarget2D(class UEngine_TextureRenderTarget2D* TextureRenderTarget)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D");

	UEngine_KismetRenderingLibrary_ReleaseRenderTarget2D_Params params;
	params.TextureRenderTarget = TextureRenderTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetUV
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// float                          U                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FColor UEngine_KismetRenderingLibrary::STATIC_ReadRenderTargetUV(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, float U, float V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetUV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetUV");

	UEngine_KismetRenderingLibrary_ReadRenderTargetUV_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;
	params.U = U;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// float                          U                              (Parm, ZeroConstructor, IsPlainOldData)
// float                          V                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetRenderingLibrary::STATIC_ReadRenderTargetRawUV(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, float U, float V)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV");

	UEngine_KismetRenderingLibrary_ReadRenderTargetRawUV_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;
	params.U = U;
	params.V = V;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// int                            X                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            Y                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_KismetRenderingLibrary::STATIC_ReadRenderTargetRawPixel(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, int X, int Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel");

	UEngine_KismetRenderingLibrary_ReadRenderTargetRawPixel_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// int                            X                              (Parm, ZeroConstructor, IsPlainOldData)
// int                            Y                              (Parm, ZeroConstructor, IsPlainOldData)
// struct FColor                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FColor UEngine_KismetRenderingLibrary::STATIC_ReadRenderTargetPixel(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, int X, int Y)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel");

	UEngine_KismetRenderingLibrary_ReadRenderTargetPixel_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;
	params.X = X;
	params.Y = Y;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.MakeSkinWeightInfo
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Bone0                          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight0                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            Bone1                          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight1                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            Bone2                          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight2                        (Parm, ZeroConstructor, IsPlainOldData)
// int                            Bone3                          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight3                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_SkelMeshSkinWeightInfo ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FEngine_SkelMeshSkinWeightInfo UEngine_KismetRenderingLibrary::STATIC_MakeSkinWeightInfo(int Bone0, unsigned char Weight0, int Bone1, unsigned char Weight1, int Bone2, unsigned char Weight2, int Bone3, unsigned char Weight3)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.MakeSkinWeightInfo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.MakeSkinWeightInfo");

	UEngine_KismetRenderingLibrary_MakeSkinWeightInfo_Params params;
	params.Bone0 = Bone0;
	params.Weight0 = Weight0;
	params.Bone1 = Bone1;
	params.Weight1 = Weight1;
	params.Bone2 = Bone2;
	params.Weight2 = Weight2;
	params.Bone3 = Bone3;
	params.Weight3 = Weight3;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Filename                       (Parm, ZeroConstructor)
// class UEngine_Texture2D*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Texture2D* UEngine_KismetRenderingLibrary::STATIC_ImportFileAsTexture2D(class UObject* WorldContextObject, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D");

	UEngine_KismetRenderingLibrary_ImportFileAsTexture2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ImportBufferAsTexture2D
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<unsigned char>          Buffer                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UEngine_Texture2D*       ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Texture2D* UEngine_KismetRenderingLibrary::STATIC_ImportBufferAsTexture2D(class UObject* WorldContextObject, TArray<unsigned char> Buffer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ImportBufferAsTexture2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ImportBufferAsTexture2D");

	UEngine_KismetRenderingLibrary_ImportBufferAsTexture2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Buffer = Buffer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ExportTexture2D
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture2D*       Texture                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FilePath                       (Parm, ZeroConstructor)
// struct FString                 Filename                       (Parm, ZeroConstructor)

void UEngine_KismetRenderingLibrary::STATIC_ExportTexture2D(class UObject* WorldContextObject, class UEngine_Texture2D* Texture, const struct FString& FilePath, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportTexture2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportTexture2D");

	UEngine_KismetRenderingLibrary_ExportTexture2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Texture = Texture;
	params.FilePath = FilePath;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.ExportRenderTarget
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FilePath                       (Parm, ZeroConstructor)
// struct FString                 Filename                       (Parm, ZeroConstructor)

void UEngine_KismetRenderingLibrary::STATIC_ExportRenderTarget(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, const struct FString& FilePath, const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportRenderTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportRenderTarget");

	UEngine_KismetRenderingLibrary_ExportRenderTarget_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;
	params.FilePath = FilePath;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DrawToRenderTargetContext Context                        (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_KismetRenderingLibrary::STATIC_EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, const struct FEngine_DrawToRenderTargetContext& Context)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget");

	UEngine_KismetRenderingLibrary_EndDrawCanvasToRenderTarget_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Context = Context;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetRenderingLibrary::STATIC_DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, class UEngine_MaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget");

	UEngine_KismetRenderingLibrary_DrawMaterialToRenderTarget_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.CreateRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// int                            Width                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            Height                         (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETextureRenderTargetFormat> Format                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ClearColor                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAutoGenerateMipMaps           (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_TextureRenderTarget2D* UEngine_KismetRenderingLibrary::STATIC_CreateRenderTarget2D(class UObject* WorldContextObject, int Width, int Height, TEnumAsByte<FEngine_Engine_ETextureRenderTargetFormat> Format, const struct FLinearColor& ClearColor, bool bAutoGenerateMipMaps)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.CreateRenderTarget2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.CreateRenderTarget2D");

	UEngine_KismetRenderingLibrary_CreateRenderTarget2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Width = Width;
	params.Height = Height;
	params.Format = Format;
	params.ClearColor = ClearColor;
	params.bAutoGenerateMipMaps = bAutoGenerateMipMaps;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* RenderTarget                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture2D*       Texture                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetRenderingLibrary::STATIC_ConvertRenderTargetToTexture2DEditorOnly(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* RenderTarget, class UEngine_Texture2D* Texture)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly");

	UEngine_KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly_Params params;
	params.WorldContextObject = WorldContextObject;
	params.RenderTarget = RenderTarget;
	params.Texture = Texture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.ClearRenderTarget2D
// (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ClearColor                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetRenderingLibrary::STATIC_ClearRenderTarget2D(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, const struct FLinearColor& ClearColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ClearRenderTarget2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ClearRenderTarget2D");

	UEngine_KismetRenderingLibrary_ClearRenderTarget2D_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;
	params.ClearColor = ClearColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetRenderingLibrary.BreakSkinWeightInfo
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_SkelMeshSkinWeightInfo InWeight                       (Parm, ZeroConstructor, IsPlainOldData)
// int                            Bone0                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight0                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Bone1                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight1                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Bone2                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight2                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            Bone3                          (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Weight3                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetRenderingLibrary::STATIC_BreakSkinWeightInfo(const struct FEngine_SkelMeshSkinWeightInfo& InWeight, int* Bone0, unsigned char* Weight0, int* Bone1, unsigned char* Weight1, int* Bone2, unsigned char* Weight2, int* Bone3, unsigned char* Weight3)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.BreakSkinWeightInfo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.BreakSkinWeightInfo");

	UEngine_KismetRenderingLibrary_BreakSkinWeightInfo_Params params;
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Bone0 != nullptr)
		*Bone0 = params.Bone0;
	if (Weight0 != nullptr)
		*Weight0 = params.Weight0;
	if (Bone1 != nullptr)
		*Bone1 = params.Bone1;
	if (Weight1 != nullptr)
		*Weight1 = params.Weight1;
	if (Bone2 != nullptr)
		*Bone2 = params.Bone2;
	if (Weight2 != nullptr)
		*Weight2 = params.Weight2;
	if (Bone3 != nullptr)
		*Bone3 = params.Bone3;
	if (Weight3 != nullptr)
		*Weight3 = params.Weight3;
}


// Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget
// (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureRenderTarget2D* TextureRenderTarget            (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Canvas*          Canvas                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Size                           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DrawToRenderTargetContext Context                        (Parm, OutParm)

void UEngine_KismetRenderingLibrary::STATIC_BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UEngine_TextureRenderTarget2D* TextureRenderTarget, class UEngine_Canvas** Canvas, struct FVector2D* Size, struct FEngine_DrawToRenderTargetContext* Context)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget");

	UEngine_KismetRenderingLibrary_BeginDrawCanvasToRenderTarget_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextureRenderTarget = TextureRenderTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Canvas != nullptr)
		*Canvas = params.Canvas;
	if (Size != nullptr)
		*Size = params.Size;
	if (Context != nullptr)
		*Context = params.Context;
}


// Function Engine.KismetStringLibrary.TrimTrailing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_TrimTrailing(const struct FString& SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TrimTrailing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TrimTrailing");

	UEngine_KismetStringLibrary_TrimTrailing_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Trim
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Trim(const struct FString& SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Trim");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Trim");

	UEngine_KismetStringLibrary_Trim_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.ToUpper
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_ToUpper(const struct FString& SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToUpper");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToUpper");

	UEngine_KismetStringLibrary_ToUpper_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.ToLower
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_ToLower(const struct FString& SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToLower");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToLower");

	UEngine_KismetStringLibrary_ToLower_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.TimeSecondsToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          InSeconds                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_TimeSecondsToString(float InSeconds)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TimeSecondsToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TimeSecondsToString");

	UEngine_KismetStringLibrary_TimeSecondsToString_Params params;
	params.InSeconds = InSeconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.StartsWith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 InPrefix                       (Parm, ZeroConstructor)
// TEnumAsByte<FCoreUObject_ESearchCase> SearchCase                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_StartsWith(const struct FString& SourceString, const struct FString& InPrefix, TEnumAsByte<FCoreUObject_ESearchCase> SearchCase)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.StartsWith");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.StartsWith");

	UEngine_KismetStringLibrary_StartsWith_Params params;
	params.SourceString = SourceString;
	params.InPrefix = InPrefix;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Split
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 InStr                          (Parm, ZeroConstructor)
// struct FString                 LeftS                          (Parm, OutParm, ZeroConstructor)
// struct FString                 RightS                         (Parm, OutParm, ZeroConstructor)
// TEnumAsByte<FCoreUObject_ESearchCase> SearchCase                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FCoreUObject_ESearchDir> SearchDir                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_Split(const struct FString& SourceString, const struct FString& InStr, TEnumAsByte<FCoreUObject_ESearchCase> SearchCase, TEnumAsByte<FCoreUObject_ESearchDir> SearchDir, struct FString* LeftS, struct FString* RightS)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Split");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Split");

	UEngine_KismetStringLibrary_Split_Params params;
	params.SourceString = SourceString;
	params.InStr = InStr;
	params.SearchCase = SearchCase;
	params.SearchDir = SearchDir;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (LeftS != nullptr)
		*LeftS = params.LeftS;
	if (RightS != nullptr)
		*RightS = params.RightS;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.RightPad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            ChCount                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_RightPad(const struct FString& SourceString, int ChCount)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightPad");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightPad");

	UEngine_KismetStringLibrary_RightPad_Params params;
	params.SourceString = SourceString;
	params.ChCount = ChCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.RightChop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            count                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_RightChop(const struct FString& SourceString, int count)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightChop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightChop");

	UEngine_KismetStringLibrary_RightChop_Params params;
	params.SourceString = SourceString;
	params.count = count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Right
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            count                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Right(const struct FString& SourceString, int count)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Right");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Right");

	UEngine_KismetStringLibrary_Right_Params params;
	params.SourceString = SourceString;
	params.count = count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Reverse
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Reverse(const struct FString& SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Reverse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Reverse");

	UEngine_KismetStringLibrary_Reverse_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.ReplaceInline
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FString                 SourceString                   (Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FString                 SearchText                     (Parm, ZeroConstructor)
// struct FString                 ReplacementText                (Parm, ZeroConstructor)
// TEnumAsByte<FCoreUObject_ESearchCase> SearchCase                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetStringLibrary::STATIC_ReplaceInline(const struct FString& SearchText, const struct FString& ReplacementText, TEnumAsByte<FCoreUObject_ESearchCase> SearchCase, struct FString* SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ReplaceInline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ReplaceInline");

	UEngine_KismetStringLibrary_ReplaceInline_Params params;
	params.SearchText = SearchText;
	params.ReplacementText = ReplacementText;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (SourceString != nullptr)
		*SourceString = params.SourceString;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Replace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 From                           (Parm, ZeroConstructor)
// struct FString                 To                             (Parm, ZeroConstructor)
// TEnumAsByte<FCoreUObject_ESearchCase> SearchCase                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Replace(const struct FString& SourceString, const struct FString& From, const struct FString& To, TEnumAsByte<FCoreUObject_ESearchCase> SearchCase)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Replace");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Replace");

	UEngine_KismetStringLibrary_Replace_Params params;
	params.SourceString = SourceString;
	params.From = From;
	params.To = To;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.ParseIntoArray
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 Delimiter                      (Parm, ZeroConstructor)
// bool                           CullEmptyStrings               (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UEngine_KismetStringLibrary::STATIC_ParseIntoArray(const struct FString& SourceString, const struct FString& Delimiter, bool CullEmptyStrings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ParseIntoArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ParseIntoArray");

	UEngine_KismetStringLibrary_ParseIntoArray_Params params;
	params.SourceString = SourceString;
	params.Delimiter = Delimiter;
	params.CullEmptyStrings = CullEmptyStrings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.NotEqual_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 A                              (Parm, ZeroConstructor)
// struct FString                 B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_NotEqual_StrStr(const struct FString& A, const struct FString& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StrStr");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StrStr");

	UEngine_KismetStringLibrary_NotEqual_StrStr_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.NotEqual_StriStri
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 A                              (Parm, ZeroConstructor)
// struct FString                 B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_NotEqual_StriStri(const struct FString& A, const struct FString& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StriStri");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StriStri");

	UEngine_KismetStringLibrary_NotEqual_StriStri_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Mid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            Start                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            count                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Mid(const struct FString& SourceString, int Start, int count)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Mid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Mid");

	UEngine_KismetStringLibrary_Mid_Params params;
	params.SourceString = SourceString;
	params.Start = Start;
	params.count = count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.MatchesWildcard
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 Wildcard                       (Parm, ZeroConstructor)
// TEnumAsByte<FCoreUObject_ESearchCase> SearchCase                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_MatchesWildcard(const struct FString& SourceString, const struct FString& Wildcard, TEnumAsByte<FCoreUObject_ESearchCase> SearchCase)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.MatchesWildcard");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.MatchesWildcard");

	UEngine_KismetStringLibrary_MatchesWildcard_Params params;
	params.SourceString = SourceString;
	params.Wildcard = Wildcard;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Len
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 S                              (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetStringLibrary::STATIC_Len(const struct FString& S)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Len");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Len");

	UEngine_KismetStringLibrary_Len_Params params;
	params.S = S;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.LeftPad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            ChCount                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_LeftPad(const struct FString& SourceString, int ChCount)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftPad");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftPad");

	UEngine_KismetStringLibrary_LeftPad_Params params;
	params.SourceString = SourceString;
	params.ChCount = ChCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.LeftChop
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            count                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_LeftChop(const struct FString& SourceString, int count)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftChop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftChop");

	UEngine_KismetStringLibrary_LeftChop_Params params;
	params.SourceString = SourceString;
	params.count = count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Left
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            count                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Left(const struct FString& SourceString, int count)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Left");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Left");

	UEngine_KismetStringLibrary_Left_Params params;
	params.SourceString = SourceString;
	params.count = count;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.JoinStringArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FString>         SourceArray                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FString                 Separator                      (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_JoinStringArray(TArray<struct FString> SourceArray, const struct FString& Separator)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.JoinStringArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.JoinStringArray");

	UEngine_KismetStringLibrary_JoinStringArray_Params params;
	params.SourceArray = SourceArray;
	params.Separator = Separator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.IsNumeric
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_IsNumeric(const struct FString& SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.IsNumeric");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.IsNumeric");

	UEngine_KismetStringLibrary_IsNumeric_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.GetSubstring
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            StartIndex                     (Parm, ZeroConstructor, IsPlainOldData)
// int                            Length                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_GetSubstring(const struct FString& SourceString, int StartIndex, int Length)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetSubstring");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetSubstring");

	UEngine_KismetStringLibrary_GetSubstring_Params params;
	params.SourceString = SourceString;
	params.StartIndex = StartIndex;
	params.Length = Length;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.GetCharacterAsNumber
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetStringLibrary::STATIC_GetCharacterAsNumber(const struct FString& SourceString, int Index)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterAsNumber");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterAsNumber");

	UEngine_KismetStringLibrary_GetCharacterAsNumber_Params params;
	params.SourceString = SourceString;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.GetCharacterArrayFromString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UEngine_KismetStringLibrary::STATIC_GetCharacterArrayFromString(const struct FString& SourceString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterArrayFromString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterArrayFromString");

	UEngine_KismetStringLibrary_GetCharacterArrayFromString_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.FindSubstring
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SearchIn                       (Parm, ZeroConstructor)
// struct FString                 Substring                      (Parm, ZeroConstructor)
// bool                           bUseCase                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSearchFromEnd                 (Parm, ZeroConstructor, IsPlainOldData)
// int                            StartPosition                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetStringLibrary::STATIC_FindSubstring(const struct FString& SearchIn, const struct FString& Substring, bool bUseCase, bool bSearchFromEnd, int StartPosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.FindSubstring");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.FindSubstring");

	UEngine_KismetStringLibrary_FindSubstring_Params params;
	params.SearchIn = SearchIn;
	params.Substring = Substring;
	params.bUseCase = bUseCase;
	params.bSearchFromEnd = bSearchFromEnd;
	params.StartPosition = StartPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.EqualEqual_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 A                              (Parm, ZeroConstructor)
// struct FString                 B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_EqualEqual_StrStr(const struct FString& A, const struct FString& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StrStr");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StrStr");

	UEngine_KismetStringLibrary_EqualEqual_StrStr_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.EqualEqual_StriStri
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 A                              (Parm, ZeroConstructor)
// struct FString                 B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_EqualEqual_StriStri(const struct FString& A, const struct FString& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StriStri");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StriStri");

	UEngine_KismetStringLibrary_EqualEqual_StriStri_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.EndsWith
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// struct FString                 InSuffix                       (Parm, ZeroConstructor)
// TEnumAsByte<FCoreUObject_ESearchCase> SearchCase                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_EndsWith(const struct FString& SourceString, const struct FString& InSuffix, TEnumAsByte<FCoreUObject_ESearchCase> SearchCase)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EndsWith");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EndsWith");

	UEngine_KismetStringLibrary_EndsWith_Params params;
	params.SourceString = SourceString;
	params.InSuffix = InSuffix;
	params.SearchCase = SearchCase;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.CullArray
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SourceString                   (Parm, ZeroConstructor)
// TArray<struct FString>         inArray                        (Parm, OutParm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetStringLibrary::STATIC_CullArray(const struct FString& SourceString, TArray<struct FString>* inArray)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.CullArray");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.CullArray");

	UEngine_KismetStringLibrary_CullArray_Params params;
	params.SourceString = SourceString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (inArray != nullptr)
		*inArray = params.inArray;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_VectorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_VectorToString(const struct FVector& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_VectorToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_VectorToString");

	UEngine_KismetStringLibrary_Conv_VectorToString_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_Vector2dToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_Vector2dToString(const struct FVector2D& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_Vector2dToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_Vector2dToString");

	UEngine_KismetStringLibrary_Conv_Vector2dToString_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_TransformToString
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              InTrans                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_TransformToString(const struct FTransform& InTrans)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_TransformToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_TransformToString");

	UEngine_KismetStringLibrary_Conv_TransformToString_Params params;
	params.InTrans = InTrans;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToVector2D
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// struct FVector2D               OutConvertedVector2D           (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsValid                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetStringLibrary::STATIC_Conv_StringToVector2D(const struct FString& inString, struct FVector2D* OutConvertedVector2D, bool* OutIsValid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToVector2D");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToVector2D");

	UEngine_KismetStringLibrary_Conv_StringToVector2D_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutConvertedVector2D != nullptr)
		*OutConvertedVector2D = params.OutConvertedVector2D;
	if (OutIsValid != nullptr)
		*OutIsValid = params.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_StringToVector
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// struct FVector                 OutConvertedVector             (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsValid                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetStringLibrary::STATIC_Conv_StringToVector(const struct FString& inString, struct FVector* OutConvertedVector, bool* OutIsValid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToVector");

	UEngine_KismetStringLibrary_Conv_StringToVector_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutConvertedVector != nullptr)
		*OutConvertedVector = params.OutConvertedVector;
	if (OutIsValid != nullptr)
		*OutIsValid = params.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_StringToRotator
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// struct FRotator                OutConvertedRotator            (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsValid                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetStringLibrary::STATIC_Conv_StringToRotator(const struct FString& inString, struct FRotator* OutConvertedRotator, bool* OutIsValid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToRotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToRotator");

	UEngine_KismetStringLibrary_Conv_StringToRotator_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutConvertedRotator != nullptr)
		*OutConvertedRotator = params.OutConvertedRotator;
	if (OutIsValid != nullptr)
		*OutIsValid = params.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_StringToName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_KismetStringLibrary::STATIC_Conv_StringToName(const struct FString& inString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToName");

	UEngine_KismetStringLibrary_Conv_StringToName_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetStringLibrary::STATIC_Conv_StringToInt(const struct FString& inString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToInt");

	UEngine_KismetStringLibrary_Conv_StringToInt_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetStringLibrary::STATIC_Conv_StringToFloat(const struct FString& inString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToFloat");

	UEngine_KismetStringLibrary_Conv_StringToFloat_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_StringToColor
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// struct FLinearColor            OutConvertedColor              (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           OutIsValid                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetStringLibrary::STATIC_Conv_StringToColor(const struct FString& inString, struct FLinearColor* OutConvertedColor, bool* OutIsValid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToColor");

	UEngine_KismetStringLibrary_Conv_StringToColor_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutConvertedColor != nullptr)
		*OutConvertedColor = params.OutConvertedColor;
	if (OutIsValid != nullptr)
		*OutIsValid = params.OutIsValid;
}


// Function Engine.KismetStringLibrary.Conv_RotatorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_RotatorToString(const struct FRotator& InRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_RotatorToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_RotatorToString");

	UEngine_KismetStringLibrary_Conv_RotatorToString_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_ObjectToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 InObj                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_ObjectToString(class UObject* InObj)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ObjectToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ObjectToString");

	UEngine_KismetStringLibrary_Conv_ObjectToString_Params params;
	params.InObj = InObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_NameToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_NameToString(const struct FName& InName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_NameToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_NameToString");

	UEngine_KismetStringLibrary_Conv_NameToString_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_MatrixToString
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMatrix                 InMatrix                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_MatrixToString(const struct FMatrix& InMatrix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_MatrixToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_MatrixToString");

	UEngine_KismetStringLibrary_Conv_MatrixToString_Params params;
	params.InMatrix = InMatrix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_IntVectorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FIntVector              InIntVec                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_IntVectorToString(const struct FIntVector& InIntVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntVectorToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntVectorToString");

	UEngine_KismetStringLibrary_Conv_IntVectorToString_Params params;
	params.InIntVec = InIntVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_IntToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_IntToString(int inInt)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntToString");

	UEngine_KismetStringLibrary_Conv_IntToString_Params params;
	params.inInt = inInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_FloatToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          InFloat                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_FloatToString(float InFloat)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_FloatToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_FloatToString");

	UEngine_KismetStringLibrary_Conv_FloatToString_Params params;
	params.InFloat = InFloat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_ColorToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_ColorToString(const struct FLinearColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ColorToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ColorToString");

	UEngine_KismetStringLibrary_Conv_ColorToString_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_ByteToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  InByte                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_ByteToString(unsigned char InByte)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ByteToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ByteToString");

	UEngine_KismetStringLibrary_Conv_ByteToString_Params params;
	params.InByte = InByte;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Conv_BoolToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           InBool                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Conv_BoolToString(bool InBool)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_BoolToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_BoolToString");

	UEngine_KismetStringLibrary_Conv_BoolToString_Params params;
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Contains
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 SearchIn                       (Parm, ZeroConstructor)
// struct FString                 Substring                      (Parm, ZeroConstructor)
// bool                           bUseCase                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSearchFromEnd                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringLibrary::STATIC_Contains(const struct FString& SearchIn, const struct FString& Substring, bool bUseCase, bool bSearchFromEnd)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Contains");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Contains");

	UEngine_KismetStringLibrary_Contains_Params params;
	params.SearchIn = SearchIn;
	params.Substring = Substring;
	params.bUseCase = bUseCase;
	params.bSearchFromEnd = bSearchFromEnd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.Concat_StrStr
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 A                              (Parm, ZeroConstructor)
// struct FString                 B                              (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_Concat_StrStr(const struct FString& A, const struct FString& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Concat_StrStr");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Concat_StrStr");

	UEngine_KismetStringLibrary_Concat_StrStr_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Vector2d
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// struct FVector2D               InVector2D                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Vector2d(const struct FString& AppendTo, const struct FString& Prefix, const struct FVector2D& InVector2D, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector2d");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector2d");

	UEngine_KismetStringLibrary_BuildString_Vector2d_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InVector2D = InVector2D;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Vector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// struct FVector                 InVector                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Vector(const struct FString& AppendTo, const struct FString& Prefix, const struct FVector& InVector, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector");

	UEngine_KismetStringLibrary_BuildString_Vector_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InVector = InVector;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Rotator
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Rotator(const struct FString& AppendTo, const struct FString& Prefix, const struct FRotator& InRot, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Rotator");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Rotator");

	UEngine_KismetStringLibrary_BuildString_Rotator_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InRot = InRot;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Object
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// class UObject*                 InObj                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Object(const struct FString& AppendTo, const struct FString& Prefix, class UObject* InObj, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Object");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Object");

	UEngine_KismetStringLibrary_BuildString_Object_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InObj = InObj;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Name
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Name(const struct FString& AppendTo, const struct FString& Prefix, const struct FName& InName, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Name");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Name");

	UEngine_KismetStringLibrary_BuildString_Name_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InName = InName;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_IntVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// struct FIntVector              InIntVector                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_IntVector(const struct FString& AppendTo, const struct FString& Prefix, const struct FIntVector& InIntVector, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_IntVector");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_IntVector");

	UEngine_KismetStringLibrary_BuildString_IntVector_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InIntVector = InIntVector;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Int
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// int                            inInt                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Int(const struct FString& AppendTo, const struct FString& Prefix, int inInt, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Int");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Int");

	UEngine_KismetStringLibrary_BuildString_Int_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.inInt = inInt;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// float                          InFloat                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Float(const struct FString& AppendTo, const struct FString& Prefix, float InFloat, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Float");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Float");

	UEngine_KismetStringLibrary_BuildString_Float_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InFloat = InFloat;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Color
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Color(const struct FString& AppendTo, const struct FString& Prefix, const struct FLinearColor& InColor, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Color");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Color");

	UEngine_KismetStringLibrary_BuildString_Color_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InColor = InColor;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringLibrary.BuildString_Bool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 AppendTo                       (Parm, ZeroConstructor)
// struct FString                 Prefix                         (Parm, ZeroConstructor)
// bool                           InBool                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Suffix                         (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringLibrary::STATIC_BuildString_Bool(const struct FString& AppendTo, const struct FString& Prefix, bool InBool, const struct FString& Suffix)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Bool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Bool");

	UEngine_KismetStringLibrary_BuildString_Bool_Params params;
	params.AppendTo = AppendTo;
	params.Prefix = Prefix;
	params.InBool = InBool;
	params.Suffix = Suffix;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.IsRegisteredTableId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringTableLibrary::STATIC_IsRegisteredTableId(const struct FName& TableId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.IsRegisteredTableId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.IsRegisteredTableId");

	UEngine_KismetStringTableLibrary_IsRegisteredTableId_Params params;
	params.TableId = TableId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.IsRegisteredTableEntry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Key                            (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetStringTableLibrary::STATIC_IsRegisteredTableEntry(const struct FName& TableId, const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.IsRegisteredTableEntry");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.IsRegisteredTableEntry");

	UEngine_KismetStringTableLibrary_IsRegisteredTableEntry_Params params;
	params.TableId = TableId;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetTableNamespace
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringTableLibrary::STATIC_GetTableNamespace(const struct FName& TableId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableNamespace");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableNamespace");

	UEngine_KismetStringTableLibrary_GetTableNamespace_Params params;
	params.TableId = TableId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetTableEntrySourceString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Key                            (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringTableLibrary::STATIC_GetTableEntrySourceString(const struct FName& TableId, const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableEntrySourceString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableEntrySourceString");

	UEngine_KismetStringTableLibrary_GetTableEntrySourceString_Params params;
	params.TableId = TableId;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetTableEntryMetaData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Key                            (Parm, ZeroConstructor)
// struct FName                   MetaDataId                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetStringTableLibrary::STATIC_GetTableEntryMetaData(const struct FName& TableId, const struct FString& Key, const struct FName& MetaDataId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableEntryMetaData");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetTableEntryMetaData");

	UEngine_KismetStringTableLibrary_GetTableEntryMetaData_Params params;
	params.TableId = TableId;
	params.Key = Key;
	params.MetaDataId = MetaDataId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetRegisteredStringTables
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FName>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FName> UEngine_KismetStringTableLibrary::STATIC_GetRegisteredStringTables()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetRegisteredStringTables");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetRegisteredStringTables");

	UEngine_KismetStringTableLibrary_GetRegisteredStringTables_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetMetaDataIdsFromStringTableEntry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Key                            (Parm, ZeroConstructor)
// TArray<struct FName>           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FName> UEngine_KismetStringTableLibrary::STATIC_GetMetaDataIdsFromStringTableEntry(const struct FName& TableId, const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetMetaDataIdsFromStringTableEntry");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetMetaDataIdsFromStringTableEntry");

	UEngine_KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry_Params params;
	params.TableId = TableId;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetStringTableLibrary.GetKeysFromStringTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UEngine_KismetStringTableLibrary::STATIC_GetKeysFromStringTable(const struct FName& TableId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetKeysFromStringTable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetStringTableLibrary.GetKeysFromStringTable");

	UEngine_KismetStringTableLibrary_GetKeysFromStringTable_Params params;
	params.TableId = TableId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.UnregisterForRemoteNotifications
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_UnregisterForRemoteNotifications()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnregisterForRemoteNotifications");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnregisterForRemoteNotifications");

	UEngine_KismetSystemLibrary_UnregisterForRemoteNotifications_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.UnloadPrimaryAssetList
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FPrimaryAssetId> PrimaryAssetIdList             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_UnloadPrimaryAssetList(TArray<struct FPrimaryAssetId> PrimaryAssetIdList)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnloadPrimaryAssetList");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnloadPrimaryAssetList");

	UEngine_KismetSystemLibrary_UnloadPrimaryAssetList_Params params;
	params.PrimaryAssetIdList = PrimaryAssetIdList;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.UnloadPrimaryAsset
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_UnloadPrimaryAsset(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnloadPrimaryAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.UnloadPrimaryAsset");

	UEngine_KismetSystemLibrary_UnloadPrimaryAsset_Params params;
	params.PrimaryAssetId = PrimaryAssetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.TransactObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_TransactObject(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.TransactObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.TransactObject");

	UEngine_KismetSystemLibrary_TransactObject_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.StackTrace
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_StackTrace()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.StackTrace");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.StackTrace");

	UEngine_KismetSystemLibrary_StackTrace_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects");

	UEngine_KismetSystemLibrary_SphereTraceSingleForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleByProfile");

	UEngine_KismetSystemLibrary_SphereTraceSingleByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceSingle
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingle");

	UEngine_KismetSystemLibrary_SphereTraceSingle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects");

	UEngine_KismetSystemLibrary_SphereTraceMultiForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiByProfile");

	UEngine_KismetSystemLibrary_SphereTraceMultiByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereTraceMulti
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMulti");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMulti");

	UEngine_KismetSystemLibrary_SphereTraceMulti_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereOverlapComponents
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SpherePos                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          SphereRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ComponentClassFilter           (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class UEngine_PrimitiveComponent*> OutComponents                  (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereOverlapComponents(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class UEngine_PrimitiveComponent*>* OutComponents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapComponents");

	UEngine_KismetSystemLibrary_SphereOverlapComponents_Params params;
	params.WorldContextObject = WorldContextObject;
	params.SpherePos = SpherePos;
	params.SphereRadius = SphereRadius;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SphereOverlapActors
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SpherePos                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          SphereRadius                   (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ActorClassFilter               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_SphereOverlapActors(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActors");

	UEngine_KismetSystemLibrary_SphereOverlapActors_Params params;
	params.WorldContextObject = WorldContextObject;
	params.SpherePos = SpherePos;
	params.SphereRadius = SphereRadius;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.SnapshotObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SnapshotObject(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SnapshotObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SnapshotObject");

	UEngine_KismetSystemLibrary_SnapshotObject_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 CategoryName                   (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_ShowPlatformSpecificLeaderboardScreen(const struct FString& CategoryName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen");

	UEngine_KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen_Params params;
	params.CategoryName = CategoryName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerController* SpecificPlayer                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_ShowPlatformSpecificAchievementsScreen(class AEngine_PlayerController* SpecificPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen");

	UEngine_KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen_Params params;
	params.SpecificPlayer = SpecificPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ShowInterstitialAd
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_ShowInterstitialAd()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowInterstitialAd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowInterstitialAd");

	UEngine_KismetSystemLibrary_ShowInterstitialAd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ShowAdBanner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            AdIdIndex                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShowOnBottomOfScreen          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_ShowAdBanner(int AdIdIndex, bool bShowOnBottomOfScreen)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowAdBanner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowAdBanner");

	UEngine_KismetSystemLibrary_ShowAdBanner_Params params;
	params.AdIdIndex = AdIdIndex;
	params.bShowOnBottomOfScreen = bShowOnBottomOfScreen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetWindowTitle
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FText                   Title                          (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_SetWindowTitle(const struct FText& Title)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetWindowTitle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetWindowTitle");

	UEngine_KismetSystemLibrary_SetWindowTitle_Params params;
	params.Title = Title;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetVolumeButtonsHandledBySystem(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem");

	UEngine_KismetSystemLibrary_SetVolumeButtonsHandledBySystem_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetVectorPropertyByName
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetVectorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FVector& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVectorPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVectorPropertyByName");

	UEngine_KismetSystemLibrary_SetVectorPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetUserActivity
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_UserActivity    UserActivity                   (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_SetUserActivity(const struct FEngine_UserActivity& UserActivity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetUserActivity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetUserActivity");

	UEngine_KismetSystemLibrary_SetUserActivity_Params params;
	params.UserActivity = UserActivity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetTransformPropertyByName
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              Value                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetTransformPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FTransform& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTransformPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTransformPropertyByName");

	UEngine_KismetSystemLibrary_SetTransformPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetTextPropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   Value                          (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_SetTextPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FText& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTextPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTextPropertyByName");

	UEngine_KismetSystemLibrary_SetTextPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bState                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetSuppressViewportTransitionMessage(class UObject* WorldContextObject, bool bState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage");

	UEngine_KismetSystemLibrary_SetSuppressViewportTransitionMessage_Params params;
	params.WorldContextObject = WorldContextObject;
	params.bState = bState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetStructurePropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_GenericStruct   Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetStructurePropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FEngine_GenericStruct& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStructurePropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStructurePropertyByName");

	UEngine_KismetSystemLibrary_SetStructurePropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetStringPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Value                          (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_SetStringPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStringPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStringPropertyByName");

	UEngine_KismetSystemLibrary_SetStringPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetSoftObjectPropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetSoftObjectPropertyByName(class UObject* Object, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSoftObjectPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSoftObjectPropertyByName");

	UEngine_KismetSystemLibrary_SetSoftObjectPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetSoftClassPropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetSoftClassPropertyByName(class UObject* Object, const struct FName& PropertyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSoftClassPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSoftClassPropertyByName");

	UEngine_KismetSystemLibrary_SetSoftClassPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetRotatorPropertyByName
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetRotatorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FRotator& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetRotatorPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetRotatorPropertyByName");

	UEngine_KismetSystemLibrary_SetRotatorPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetObjectPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetObjectPropertyByName(class UObject* Object, const struct FName& PropertyName, class UObject* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetObjectPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetObjectPropertyByName");

	UEngine_KismetSystemLibrary_SetObjectPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetNamePropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetNamePropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FName& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetNamePropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetNamePropertyByName");

	UEngine_KismetSystemLibrary_SetNamePropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetLinearColorPropertyByName(class UObject* Object, const struct FName& PropertyName, const struct FLinearColor& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName");

	UEngine_KismetSystemLibrary_SetLinearColorPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetIntPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetIntPropertyByName(class UObject* Object, const struct FName& PropertyName, int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetIntPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetIntPropertyByName");

	UEngine_KismetSystemLibrary_SetIntPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetInterfacePropertyByName
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// TScriptInterface<class UInterface> Value                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetInterfacePropertyByName(class UObject* Object, const struct FName& PropertyName, const TScriptInterface<class UInterface>& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetInterfacePropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetInterfacePropertyByName");

	UEngine_KismetSystemLibrary_SetInterfacePropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetInt64PropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// int64_t                        Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetInt64PropertyByName(class UObject* Object, const struct FName& PropertyName, int64_t Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetInt64PropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetInt64PropertyByName");

	UEngine_KismetSystemLibrary_SetInt64PropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetFloatPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetFloatPropertyByName(class UObject* Object, const struct FName& PropertyName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetFloatPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetFloatPropertyByName");

	UEngine_KismetSystemLibrary_SetFloatPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_CollisionProfileName Value                          (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_SetCollisionProfileNameProperty(class UObject* Object, const struct FName& PropertyName, const struct FEngine_CollisionProfileName& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty");

	UEngine_KismetSystemLibrary_SetCollisionProfileNameProperty_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetClassPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetClassPropertyByName(class UObject* Object, const struct FName& PropertyName, class UClass* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetClassPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetClassPropertyByName");

	UEngine_KismetSystemLibrary_SetClassPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetBytePropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetBytePropertyByName(class UObject* Object, const struct FName& PropertyName, unsigned char Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBytePropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBytePropertyByName");

	UEngine_KismetSystemLibrary_SetBytePropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.SetBoolPropertyByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   PropertyName                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_SetBoolPropertyByName(class UObject* Object, const struct FName& PropertyName, bool Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBoolPropertyByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBoolPropertyByName");

	UEngine_KismetSystemLibrary_SetBoolPropertyByName_Params params;
	params.Object = Object;
	params.PropertyName = PropertyName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.RetriggerableDelay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)

void UEngine_KismetSystemLibrary::STATIC_RetriggerableDelay(class UObject* WorldContextObject, float Duration, const struct FEngine_LatentActionInfo& LatentInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RetriggerableDelay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RetriggerableDelay");

	UEngine_KismetSystemLibrary_RetriggerableDelay_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Duration = Duration;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_ResetGamepadAssignmentToController(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController");

	UEngine_KismetSystemLibrary_ResetGamepadAssignmentToController_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ResetGamepadAssignments
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_ResetGamepadAssignments()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignments");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ResetGamepadAssignments");

	UEngine_KismetSystemLibrary_ResetGamepadAssignments_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_RegisterForRemoteNotifications()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RegisterForRemoteNotifications");

	UEngine_KismetSystemLibrary_RegisterForRemoteNotifications_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.QuitGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// class AEngine_PlayerController* SpecificPlayer                 (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EQuitPreference> QuitPreference                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIgnorePlatformRestrictions    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_QuitGame(class UObject* WorldContextObject, class AEngine_PlayerController* SpecificPlayer, TEnumAsByte<FEngine_Engine_EQuitPreference> QuitPreference, bool bIgnorePlatformRestrictions)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.QuitGame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.QuitGame");

	UEngine_KismetSystemLibrary_QuitGame_Params params;
	params.WorldContextObject = WorldContextObject;
	params.SpecificPlayer = SpecificPlayer;
	params.QuitPreference = QuitPreference;
	params.bIgnorePlatformRestrictions = bIgnorePlatformRestrictions;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.PrintWarning
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_PrintWarning(const struct FString& inString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintWarning");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintWarning");

	UEngine_KismetSystemLibrary_PrintWarning_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.PrintText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   InText                         (ConstParm, Parm)
// bool                           bPrintToScreen                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPrintToLog                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TextColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_PrintText(class UObject* WorldContextObject, const struct FText& InText, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintText");

	UEngine_KismetSystemLibrary_PrintText_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InText = InText;
	params.bPrintToScreen = bPrintToScreen;
	params.bPrintToLog = bPrintToLog;
	params.TextColor = TextColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.PrintString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 inString                       (Parm, ZeroConstructor)
// bool                           bPrintToScreen                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bPrintToLog                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TextColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_PrintString(class UObject* WorldContextObject, const struct FString& inString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintString");

	UEngine_KismetSystemLibrary_PrintString_Params params;
	params.WorldContextObject = WorldContextObject;
	params.inString = inString;
	params.bPrintToScreen = bPrintToScreen;
	params.bPrintToLog = bPrintToLog;
	params.TextColor = TextColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature
// (Public, Delegate)
// Parameters:
// class UObject*                 Loaded                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::OnAssetLoaded__DelegateSignature(class UObject* Loaded)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature");

	UEngine_KismetSystemLibrary_OnAssetLoaded__DelegateSignature_Params params;
	params.Loaded = Loaded;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature
// (Public, Delegate)
// Parameters:
// class UClass*                  Loaded                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::OnAssetClassLoaded__DelegateSignature(class UClass* Loaded)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature");

	UEngine_KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature_Params params;
	params.Loaded = Loaded;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.NotEqual_SoftObjectReference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_NotEqual_SoftObjectReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_SoftObjectReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_SoftObjectReference");

	UEngine_KismetSystemLibrary_NotEqual_SoftObjectReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NotEqual_SoftClassReference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_NotEqual_SoftClassReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_SoftClassReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_SoftClassReference");

	UEngine_KismetSystemLibrary_NotEqual_SoftClassReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType       A                              (Parm, ZeroConstructor)
// struct FPrimaryAssetType       B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_NotEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetType");

	UEngine_KismetSystemLibrary_NotEqual_PrimaryAssetType_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         A                              (Parm, ZeroConstructor)
// struct FPrimaryAssetId         B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_NotEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetId");

	UEngine_KismetSystemLibrary_NotEqual_PrimaryAssetId_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.NormalizeFilename
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 InFilename                     (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_NormalizeFilename(const struct FString& InFilename)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NormalizeFilename");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.NormalizeFilename");

	UEngine_KismetSystemLibrary_NormalizeFilename_Params params;
	params.InFilename = InFilename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MoveComponentTo
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 TargetRelativeLocation         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                TargetRelativeRotation         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEaseOut                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEaseIn                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          OverTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bForceShortestRotationPath     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EMoveComponentAction> MoveAction                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)

void UEngine_KismetSystemLibrary::STATIC_MoveComponentTo(class UEngine_SceneComponent* Component, const struct FVector& TargetRelativeLocation, const struct FRotator& TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, TEnumAsByte<FEngine_Engine_EMoveComponentAction> MoveAction, const struct FEngine_LatentActionInfo& LatentInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MoveComponentTo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MoveComponentTo");

	UEngine_KismetSystemLibrary_MoveComponentTo_Params params;
	params.Component = Component;
	params.TargetRelativeLocation = TargetRelativeLocation;
	params.TargetRelativeRotation = TargetRelativeRotation;
	params.bEaseOut = bEaseOut;
	params.bEaseIn = bEaseIn;
	params.OverTime = OverTime;
	params.bForceShortestRotationPath = bForceShortestRotationPath;
	params.MoveAction = MoveAction;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.MakeSoftObjectPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 PathString                     (Parm, ZeroConstructor)
// struct FSoftObjectPath         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FSoftObjectPath UEngine_KismetSystemLibrary::STATIC_MakeSoftObjectPath(const struct FString& PathString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeSoftObjectPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeSoftObjectPath");

	UEngine_KismetSystemLibrary_MakeSoftObjectPath_Params params;
	params.PathString = PathString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeSoftClassPath
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 PathString                     (Parm, ZeroConstructor)
// struct FSoftClassPath          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FSoftClassPath UEngine_KismetSystemLibrary::STATIC_MakeSoftClassPath(const struct FString& PathString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeSoftClassPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeSoftClassPath");

	UEngine_KismetSystemLibrary_MakeSoftClassPath_Params params;
	params.PathString = PathString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   Value                          (Parm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetSystemLibrary::STATIC_MakeLiteralText(const struct FText& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralText");

	UEngine_KismetSystemLibrary_MakeLiteralText_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Value                          (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_MakeLiteralString(const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralString");

	UEngine_KismetSystemLibrary_MakeLiteralString_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   Value                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_KismetSystemLibrary::STATIC_MakeLiteralName(const struct FName& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralName");

	UEngine_KismetSystemLibrary_MakeLiteralName_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralInt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_MakeLiteralInt(int Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralInt");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralInt");

	UEngine_KismetSystemLibrary_MakeLiteralInt_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_MakeLiteralFloat(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralFloat");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralFloat");

	UEngine_KismetSystemLibrary_MakeLiteralFloat_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralByte
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  Value                          (Parm, ZeroConstructor, IsPlainOldData)
// unsigned char                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

unsigned char UEngine_KismetSystemLibrary::STATIC_MakeLiteralByte(unsigned char Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralByte");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralByte");

	UEngine_KismetSystemLibrary_MakeLiteralByte_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.MakeLiteralBool
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_MakeLiteralBool(bool Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralBool");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralBool");

	UEngine_KismetSystemLibrary_MakeLiteralBool_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LoadInterstitialAd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            AdIdIndex                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_LoadInterstitialAd(int AdIdIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadInterstitialAd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadInterstitialAd");

	UEngine_KismetSystemLibrary_LoadInterstitialAd_Params params;
	params.AdIdIndex = AdIdIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.LoadClassAsset_Blocking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UEngine_KismetSystemLibrary::STATIC_LoadClassAsset_Blocking()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadClassAsset_Blocking");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadClassAsset_Blocking");

	UEngine_KismetSystemLibrary_LoadClassAsset_Blocking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LoadAssetClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FScriptDelegate         OnLoaded                       (Parm, ZeroConstructor)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)

void UEngine_KismetSystemLibrary::STATIC_LoadAssetClass(class UObject* WorldContextObject, const struct FScriptDelegate& OnLoaded, const struct FEngine_LatentActionInfo& LatentInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAssetClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAssetClass");

	UEngine_KismetSystemLibrary_LoadAssetClass_Params params;
	params.WorldContextObject = WorldContextObject;
	params.OnLoaded = OnLoaded;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.LoadAsset_Blocking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UEngine_KismetSystemLibrary::STATIC_LoadAsset_Blocking()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAsset_Blocking");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAsset_Blocking");

	UEngine_KismetSystemLibrary_LoadAsset_Blocking_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LoadAsset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FScriptDelegate         OnLoaded                       (Parm, ZeroConstructor)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)

void UEngine_KismetSystemLibrary::STATIC_LoadAsset(class UObject* WorldContextObject, const struct FScriptDelegate& OnLoaded, const struct FEngine_LatentActionInfo& LatentInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAsset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LoadAsset");

	UEngine_KismetSystemLibrary_LoadAsset_Params params;
	params.WorldContextObject = WorldContextObject;
	params.OnLoaded = OnLoaded;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.LineTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_LineTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleForObjects");

	UEngine_KismetSystemLibrary_LineTraceSingleForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_LineTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleByProfile");

	UEngine_KismetSystemLibrary_LineTraceSingleByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceSingle
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_LineTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingle");

	UEngine_KismetSystemLibrary_LineTraceSingle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_LineTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiForObjects");

	UEngine_KismetSystemLibrary_LineTraceMultiForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_LineTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiByProfile");

	UEngine_KismetSystemLibrary_LineTraceMultiByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LineTraceMulti
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_LineTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMulti");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMulti");

	UEngine_KismetSystemLibrary_LineTraceMulti_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.LaunchURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 URL                            (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_LaunchURL(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LaunchURL");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LaunchURL");

	UEngine_KismetSystemLibrary_LaunchURL_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)

void UEngine_KismetSystemLibrary::STATIC_K2_UnPauseTimerHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle");

	UEngine_KismetSystemLibrary_K2_UnPauseTimerHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_K2_UnPauseTimerDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate");

	UEngine_KismetSystemLibrary_K2_UnPauseTimerDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_UnPauseTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_K2_UnPauseTimer(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimer");

	UEngine_KismetSystemLibrary_K2_UnPauseTimer_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_TimerExistsHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_TimerExistsHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsHandle");

	UEngine_KismetSystemLibrary_K2_TimerExistsHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_TimerExistsDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate");

	UEngine_KismetSystemLibrary_K2_TimerExistsDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_TimerExists
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_TimerExists(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExists");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExists");

	UEngine_KismetSystemLibrary_K2_TimerExists_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_SetTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLooping                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          InitialStartDelay              (Parm, ZeroConstructor, IsPlainOldData)
// float                          InitialStartDelayVariance      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEngine_TimerHandle UEngine_KismetSystemLibrary::STATIC_K2_SetTimerDelegate(const struct FScriptDelegate& Delegate, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerDelegate");

	UEngine_KismetSystemLibrary_K2_SetTimerDelegate_Params params;
	params.Delegate = Delegate;
	params.Time = Time;
	params.bLooping = bLooping;
	params.InitialStartDelay = InitialStartDelay;
	params.InitialStartDelayVariance = InitialStartDelayVariance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_SetTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)
// float                          Time                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bLooping                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          InitialStartDelay              (Parm, ZeroConstructor, IsPlainOldData)
// float                          InitialStartDelayVariance      (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEngine_TimerHandle UEngine_KismetSystemLibrary::STATIC_K2_SetTimer(class UObject* Object, const struct FString& FunctionName, float Time, bool bLooping, float InitialStartDelay, float InitialStartDelayVariance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimer");

	UEngine_KismetSystemLibrary_K2_SetTimer_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;
	params.Time = Time;
	params.bLooping = bLooping;
	params.InitialStartDelay = InitialStartDelay;
	params.InitialStartDelayVariance = InitialStartDelayVariance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_PauseTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)

void UEngine_KismetSystemLibrary::STATIC_K2_PauseTimerHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerHandle");

	UEngine_KismetSystemLibrary_K2_PauseTimerHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_K2_PauseTimerDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate");

	UEngine_KismetSystemLibrary_K2_PauseTimerDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_PauseTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_K2_PauseTimer(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimer");

	UEngine_KismetSystemLibrary_K2_PauseTimer_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEngine_TimerHandle     Handle                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_IsValidTimerHandle(const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle");

	UEngine_KismetSystemLibrary_K2_IsValidTimerHandle_Params params;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_IsTimerPausedHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle");

	UEngine_KismetSystemLibrary_K2_IsTimerPausedHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_IsTimerPausedDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate");

	UEngine_KismetSystemLibrary_K2_IsTimerPausedDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerPaused
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_IsTimerPaused(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPaused");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPaused");

	UEngine_KismetSystemLibrary_K2_IsTimerPaused_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_IsTimerActiveHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle");

	UEngine_KismetSystemLibrary_K2_IsTimerActiveHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_IsTimerActiveDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate");

	UEngine_KismetSystemLibrary_K2_IsTimerActiveDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_IsTimerActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_K2_IsTimerActive(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActive");

	UEngine_KismetSystemLibrary_K2_IsTimerActive_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_TimerHandle     Handle                         (Parm, OutParm, ReferenceParm)
// struct FEngine_TimerHandle     ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEngine_TimerHandle UEngine_KismetSystemLibrary::STATIC_K2_InvalidateTimerHandle(struct FEngine_TimerHandle* Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle");

	UEngine_KismetSystemLibrary_K2_InvalidateTimerHandle_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Handle != nullptr)
		*Handle = params.Handle;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_K2_GetTimerRemainingTimeHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle");

	UEngine_KismetSystemLibrary_K2_GetTimerRemainingTimeHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_K2_GetTimerRemainingTimeDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate");

	UEngine_KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_K2_GetTimerRemainingTime(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime");

	UEngine_KismetSystemLibrary_K2_GetTimerRemainingTime_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_K2_GetTimerElapsedTimeHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle");

	UEngine_KismetSystemLibrary_K2_GetTimerElapsedTimeHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_K2_GetTimerElapsedTimeDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate");

	UEngine_KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_K2_GetTimerElapsedTime(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime");

	UEngine_KismetSystemLibrary_K2_GetTimerElapsedTime_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.K2_ClearTimerHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm)

void UEngine_KismetSystemLibrary::STATIC_K2_ClearTimerHandle(class UObject* WorldContextObject, const struct FEngine_TimerHandle& Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerHandle");

	UEngine_KismetSystemLibrary_K2_ClearTimerHandle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Handle = Handle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScriptDelegate         Delegate                       (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_K2_ClearTimerDelegate(const struct FScriptDelegate& Delegate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate");

	UEngine_KismetSystemLibrary_K2_ClearTimerDelegate_Params params;
	params.Delegate = Delegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_ClearTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 FunctionName                   (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_K2_ClearTimer(class UObject* Object, const struct FString& FunctionName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimer");

	UEngine_KismetSystemLibrary_K2_ClearTimer_Params params;
	params.Object = Object;
	params.FunctionName = FunctionName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_TimerHandle     Handle                         (Parm, OutParm, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_K2_ClearAndInvalidateTimerHandle(class UObject* WorldContextObject, struct FEngine_TimerHandle* Handle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle");

	UEngine_KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Handle != nullptr)
		*Handle = params.Handle;
}


// Function Engine.KismetSystemLibrary.IsValidSoftObjectReference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsValidSoftObjectReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidSoftObjectReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidSoftObjectReference");

	UEngine_KismetSystemLibrary_IsValidSoftObjectReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidSoftClassReference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsValidSoftClassReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidSoftClassReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidSoftClassReference");

	UEngine_KismetSystemLibrary_IsValidSoftClassReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType       PrimaryAssetType               (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsValidPrimaryAssetType(const struct FPrimaryAssetType& PrimaryAssetType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidPrimaryAssetType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidPrimaryAssetType");

	UEngine_KismetSystemLibrary_IsValidPrimaryAssetType_Params params;
	params.PrimaryAssetType = PrimaryAssetType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsValidPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidPrimaryAssetId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidPrimaryAssetId");

	UEngine_KismetSystemLibrary_IsValidPrimaryAssetId_Params params;
	params.PrimaryAssetId = PrimaryAssetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValidClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsValidClass(class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValidClass");

	UEngine_KismetSystemLibrary_IsValidClass_Params params;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsValid(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValid");

	UEngine_KismetSystemLibrary_IsValid_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsUnattended
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsUnattended()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsUnattended");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsUnattended");

	UEngine_KismetSystemLibrary_IsUnattended_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsStandalone
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsStandalone(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsStandalone");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsStandalone");

	UEngine_KismetSystemLibrary_IsStandalone_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsServer(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsServer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsServer");

	UEngine_KismetSystemLibrary_IsServer_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsScreensaverEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsScreensaverEnabled()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsScreensaverEnabled");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsScreensaverEnabled");

	UEngine_KismetSystemLibrary_IsScreensaverEnabled_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsPackagedForDistribution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsPackagedForDistribution()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsPackagedForDistribution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsPackagedForDistribution");

	UEngine_KismetSystemLibrary_IsPackagedForDistribution_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsLoggedIn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_PlayerController* SpecificPlayer                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsLoggedIn(class AEngine_PlayerController* SpecificPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsLoggedIn");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsLoggedIn");

	UEngine_KismetSystemLibrary_IsLoggedIn_Params params;
	params.SpecificPlayer = SpecificPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsInterstitialAdRequested
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsInterstitialAdRequested()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsInterstitialAdRequested");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsInterstitialAdRequested");

	UEngine_KismetSystemLibrary_IsInterstitialAdRequested_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsInterstitialAdAvailable()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable");

	UEngine_KismetSystemLibrary_IsInterstitialAdAvailable_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsDedicatedServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsDedicatedServer(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsDedicatedServer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsDedicatedServer");

	UEngine_KismetSystemLibrary_IsDedicatedServer_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_IsControllerAssignedToGamepad(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad");

	UEngine_KismetSystemLibrary_IsControllerAssignedToGamepad_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.HideAdBanner
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_HideAdBanner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.HideAdBanner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.HideAdBanner");

	UEngine_KismetSystemLibrary_HideAdBanner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_GetVolumeButtonsHandledBySystem()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem");

	UEngine_KismetSystemLibrary_GetVolumeButtonsHandledBySystem_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetUniqueDeviceId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetUniqueDeviceId()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetUniqueDeviceId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetUniqueDeviceId");

	UEngine_KismetSystemLibrary_GetUniqueDeviceId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FIntPoint>       Resolutions                    (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_GetSupportedFullscreenResolutions(TArray<struct FIntPoint>* Resolutions)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions");

	UEngine_KismetSystemLibrary_GetSupportedFullscreenResolutions_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Resolutions != nullptr)
		*Resolutions = params.Resolutions;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetSoftObjectReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_GetSoftObjectReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftObjectReferenceFromPrimaryAssetId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftObjectReferenceFromPrimaryAssetId");

	UEngine_KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId_Params params;
	params.PrimaryAssetId = PrimaryAssetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.GetSoftClassReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_GetSoftClassReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftClassReferenceFromPrimaryAssetId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetSoftClassReferenceFromPrimaryAssetId");

	UEngine_KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId_Params params;
	params.PrimaryAssetId = PrimaryAssetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_GetRenderingMaterialQualityLevel()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel");

	UEngine_KismetSystemLibrary_GetRenderingMaterialQualityLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetRenderingDetailMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_GetRenderingDetailMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingDetailMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingDetailMode");

	UEngine_KismetSystemLibrary_GetRenderingDetailMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetProjectSavedDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetProjectSavedDirectory()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectSavedDirectory");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectSavedDirectory");

	UEngine_KismetSystemLibrary_GetProjectSavedDirectory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetProjectDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetProjectDirectory()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectDirectory");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectDirectory");

	UEngine_KismetSystemLibrary_GetProjectDirectory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetProjectContentDirectory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetProjectContentDirectory()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectContentDirectory");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetProjectContentDirectory");

	UEngine_KismetSystemLibrary_GetProjectContentDirectory_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetsWithBundleState
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FName>           RequiredBundles                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FName>           ExcludedBundles                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<struct FPrimaryAssetType> ValidTypes                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bForceCurrentState             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FPrimaryAssetId> OutPrimaryAssetIdList          (Parm, OutParm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_GetPrimaryAssetsWithBundleState(TArray<struct FName> RequiredBundles, TArray<struct FName> ExcludedBundles, TArray<struct FPrimaryAssetType> ValidTypes, bool bForceCurrentState, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetsWithBundleState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetsWithBundleState");

	UEngine_KismetSystemLibrary_GetPrimaryAssetsWithBundleState_Params params;
	params.RequiredBundles = RequiredBundles;
	params.ExcludedBundles = ExcludedBundles;
	params.ValidTypes = ValidTypes;
	params.bForceCurrentState = bForceCurrentState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPrimaryAssetIdList != nullptr)
		*OutPrimaryAssetIdList = params.OutPrimaryAssetIdList;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdList
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetType       PrimaryAssetType               (Parm, ZeroConstructor)
// TArray<struct FPrimaryAssetId> OutPrimaryAssetIdList          (Parm, OutParm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_GetPrimaryAssetIdList(const struct FPrimaryAssetType& PrimaryAssetType, TArray<struct FPrimaryAssetId>* OutPrimaryAssetIdList)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdList");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdList");

	UEngine_KismetSystemLibrary_GetPrimaryAssetIdList_Params params;
	params.PrimaryAssetType = PrimaryAssetType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutPrimaryAssetIdList != nullptr)
		*OutPrimaryAssetIdList = params.OutPrimaryAssetIdList;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftObjectReference
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FPrimaryAssetId UEngine_KismetSystemLibrary::STATIC_GetPrimaryAssetIdFromSoftObjectReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftObjectReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftObjectReference");

	UEngine_KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftClassReference
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FPrimaryAssetId UEngine_KismetSystemLibrary::STATIC_GetPrimaryAssetIdFromSoftClassReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftClassReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftClassReference");

	UEngine_KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromObject
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FPrimaryAssetId         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FPrimaryAssetId UEngine_KismetSystemLibrary::STATIC_GetPrimaryAssetIdFromObject(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromObject");

	UEngine_KismetSystemLibrary_GetPrimaryAssetIdFromObject_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromClass
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FPrimaryAssetId         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FPrimaryAssetId UEngine_KismetSystemLibrary::STATIC_GetPrimaryAssetIdFromClass(class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromClass");

	UEngine_KismetSystemLibrary_GetPrimaryAssetIdFromClass_Params params;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPreferredLanguages
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UEngine_KismetSystemLibrary::STATIC_GetPreferredLanguages()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPreferredLanguages");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPreferredLanguages");

	UEngine_KismetSystemLibrary_GetPreferredLanguages_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPlatformUserName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetPlatformUserName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPlatformUserName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPlatformUserName");

	UEngine_KismetSystemLibrary_GetPlatformUserName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetPathName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetPathName(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPathName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPathName");

	UEngine_KismetSystemLibrary_GetPathName_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetOuterObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UEngine_KismetSystemLibrary::STATIC_GetOuterObject(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetOuterObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetOuterObject");

	UEngine_KismetSystemLibrary_GetOuterObject_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetObjectName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetObjectName(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectName");

	UEngine_KismetSystemLibrary_GetObjectName_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetObjectFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UEngine_KismetSystemLibrary::STATIC_GetObjectFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectFromPrimaryAssetId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetObjectFromPrimaryAssetId");

	UEngine_KismetSystemLibrary_GetObjectFromPrimaryAssetId_Params params;
	params.PrimaryAssetId = PrimaryAssetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetMinYResolutionForUI
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_GetMinYResolutionForUI()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetMinYResolutionForUI");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetMinYResolutionForUI");

	UEngine_KismetSystemLibrary_GetMinYResolutionForUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_GetMinYResolutionFor3DView()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView");

	UEngine_KismetSystemLibrary_GetMinYResolutionFor3DView_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetLocalCurrencySymbol()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol");

	UEngine_KismetSystemLibrary_GetLocalCurrencySymbol_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetLocalCurrencyCode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetLocalCurrencyCode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencyCode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetLocalCurrencyCode");

	UEngine_KismetSystemLibrary_GetLocalCurrencyCode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGameTimeInSeconds
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_GetGameTimeInSeconds(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameTimeInSeconds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameTimeInSeconds");

	UEngine_KismetSystemLibrary_GetGameTimeInSeconds_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGamepadControllerName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ControllerId                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetGamepadControllerName(int ControllerId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGamepadControllerName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGamepadControllerName");

	UEngine_KismetSystemLibrary_GetGamepadControllerName_Params params;
	params.ControllerId = ControllerId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGameName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetGameName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameName");

	UEngine_KismetSystemLibrary_GetGameName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetGameBundleId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetGameBundleId()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameBundleId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameBundleId");

	UEngine_KismetSystemLibrary_GetGameBundleId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetFrameCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int64_t UEngine_KismetSystemLibrary::STATIC_GetFrameCount()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetFrameCount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetFrameCount");

	UEngine_KismetSystemLibrary_GetFrameCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetEngineVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetEngineVersion()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetEngineVersion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetEngineVersion");

	UEngine_KismetSystemLibrary_GetEngineVersion_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetDisplayName(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDisplayName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDisplayName");

	UEngine_KismetSystemLibrary_GetDisplayName_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDeviceId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetDeviceId()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDeviceId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDeviceId");

	UEngine_KismetSystemLibrary_GetDeviceId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDefaultLocale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetDefaultLocale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDefaultLocale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDefaultLocale");

	UEngine_KismetSystemLibrary_GetDefaultLocale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetDefaultLanguage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetDefaultLanguage()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDefaultLanguage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDefaultLanguage");

	UEngine_KismetSystemLibrary_GetDefaultLanguage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetCurrentBundleState
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)
// bool                           bForceCurrentState             (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FName>           OutBundles                     (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_GetCurrentBundleState(const struct FPrimaryAssetId& PrimaryAssetId, bool bForceCurrentState, TArray<struct FName>* OutBundles)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetCurrentBundleState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetCurrentBundleState");

	UEngine_KismetSystemLibrary_GetCurrentBundleState_Params params;
	params.PrimaryAssetId = PrimaryAssetId;
	params.bForceCurrentState = bForceCurrentState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutBundles != nullptr)
		*OutBundles = params.OutBundles;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FIntPoint>       Resolutions                    (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_GetConvenientWindowedResolutions(TArray<struct FIntPoint>* Resolutions)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions");

	UEngine_KismetSystemLibrary_GetConvenientWindowedResolutions_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Resolutions != nullptr)
		*Resolutions = params.Resolutions;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetConsoleVariableIntValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 VariableName                   (Parm, ZeroConstructor)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_GetConsoleVariableIntValue(const struct FString& VariableName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableIntValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableIntValue");

	UEngine_KismetSystemLibrary_GetConsoleVariableIntValue_Params params;
	params.VariableName = VariableName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetConsoleVariableFloatValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 VariableName                   (Parm, ZeroConstructor)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_KismetSystemLibrary::STATIC_GetConsoleVariableFloatValue(const struct FString& VariableName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableFloatValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableFloatValue");

	UEngine_KismetSystemLibrary_GetConsoleVariableFloatValue_Params params;
	params.VariableName = VariableName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetConsoleVariableBoolValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 VariableName                   (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_GetConsoleVariableBoolValue(const struct FString& VariableName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableBoolValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetConsoleVariableBoolValue");

	UEngine_KismetSystemLibrary_GetConsoleVariableBoolValue_Params params;
	params.VariableName = VariableName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetComponentBounds
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UEngine_SceneComponent*  Component                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 Origin                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// float                          SphereRadius                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_GetComponentBounds(class UEngine_SceneComponent* Component, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetComponentBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetComponentBounds");

	UEngine_KismetSystemLibrary_GetComponentBounds_Params params;
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Origin != nullptr)
		*Origin = params.Origin;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;
	if (SphereRadius != nullptr)
		*SphereRadius = params.SphereRadius;
}


// Function Engine.KismetSystemLibrary.GetCommandLine
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetCommandLine()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetCommandLine");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetCommandLine");

	UEngine_KismetSystemLibrary_GetCommandLine_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetClassFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UEngine_KismetSystemLibrary::STATIC_GetClassFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassFromPrimaryAssetId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassFromPrimaryAssetId");

	UEngine_KismetSystemLibrary_GetClassFromPrimaryAssetId_Params params;
	params.PrimaryAssetId = PrimaryAssetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetClassDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_GetClassDisplayName(class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassDisplayName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassDisplayName");

	UEngine_KismetSystemLibrary_GetClassDisplayName_Params params;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetAdIDCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_GetAdIDCount()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetAdIDCount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetAdIDCount");

	UEngine_KismetSystemLibrary_GetAdIDCount_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.GetActorListFromComponentList
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<class UEngine_PrimitiveComponent*> ComponentList                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ActorClassFilter               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   OutActorList                   (Parm, OutParm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_GetActorListFromComponentList(TArray<class UEngine_PrimitiveComponent*> ComponentList, class UClass* ActorClassFilter, TArray<class AEngine_Actor*>* OutActorList)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorListFromComponentList");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorListFromComponentList");

	UEngine_KismetSystemLibrary_GetActorListFromComponentList_Params params;
	params.ComponentList = ComponentList;
	params.ActorClassFilter = ActorClassFilter;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActorList != nullptr)
		*OutActorList = params.OutActorList;
}


// Function Engine.KismetSystemLibrary.GetActorBounds
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_Actor*           Actor                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_GetActorBounds(class AEngine_Actor* Actor, struct FVector* Origin, struct FVector* BoxExtent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorBounds");

	UEngine_KismetSystemLibrary_GetActorBounds_Params params;
	params.Actor = Actor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Origin != nullptr)
		*Origin = params.Origin;
	if (BoxExtent != nullptr)
		*BoxExtent = params.BoxExtent;
}


// Function Engine.KismetSystemLibrary.ForceCloseAdBanner
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_ForceCloseAdBanner()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ForceCloseAdBanner");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ForceCloseAdBanner");

	UEngine_KismetSystemLibrary_ForceCloseAdBanner_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.FlushPersistentDebugLines
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_FlushPersistentDebugLines(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushPersistentDebugLines");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushPersistentDebugLines");

	UEngine_KismetSystemLibrary_FlushPersistentDebugLines_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.FlushDebugStrings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_FlushDebugStrings(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushDebugStrings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushDebugStrings");

	UEngine_KismetSystemLibrary_FlushDebugStrings_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ExecuteConsoleCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Command                        (Parm, ZeroConstructor)
// class AEngine_PlayerController* SpecificPlayer                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_ExecuteConsoleCommand(class UObject* WorldContextObject, const struct FString& Command, class AEngine_PlayerController* SpecificPlayer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ExecuteConsoleCommand");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ExecuteConsoleCommand");

	UEngine_KismetSystemLibrary_ExecuteConsoleCommand_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Command = Command;
	params.SpecificPlayer = SpecificPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.EqualEqual_SoftObjectReference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_EqualEqual_SoftObjectReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_SoftObjectReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_SoftObjectReference");

	UEngine_KismetSystemLibrary_EqualEqual_SoftObjectReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EqualEqual_SoftClassReference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_EqualEqual_SoftClassReference()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_SoftClassReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_SoftClassReference");

	UEngine_KismetSystemLibrary_EqualEqual_SoftClassReference_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType       A                              (Parm, ZeroConstructor)
// struct FPrimaryAssetType       B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_EqualEqual_PrimaryAssetType(const struct FPrimaryAssetType& A, const struct FPrimaryAssetType& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetType");

	UEngine_KismetSystemLibrary_EqualEqual_PrimaryAssetType_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         A                              (Parm, ZeroConstructor)
// struct FPrimaryAssetId         B                              (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_EqualEqual_PrimaryAssetId(const struct FPrimaryAssetId& A, const struct FPrimaryAssetId& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetId");

	UEngine_KismetSystemLibrary_EqualEqual_PrimaryAssetId_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.EndTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_EndTransaction()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EndTransaction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.EndTransaction");

	UEngine_KismetSystemLibrary_EndTransaction_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.DrawDebugString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 TextLocation                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Text                           (Parm, ZeroConstructor)
// class AEngine_Actor*           TestBaseActor                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TextColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugString(class UObject* WorldContextObject, const struct FVector& TextLocation, const struct FString& Text, class AEngine_Actor* TestBaseActor, const struct FLinearColor& TextColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugString");

	UEngine_KismetSystemLibrary_DrawDebugString_Params params;
	params.WorldContextObject = WorldContextObject;
	params.TextLocation = TextLocation;
	params.Text = Text;
	params.TestBaseActor = TestBaseActor;
	params.TextColor = TextColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugSphere
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Center                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            Segments                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugSphere(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int Segments, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugSphere");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugSphere");

	UEngine_KismetSystemLibrary_DrawDebugSphere_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.Radius = Radius;
	params.Segments = Segments;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugPoint
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Position                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Size                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            PointColor                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugPoint(class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPoint");

	UEngine_KismetSystemLibrary_DrawDebugPoint_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Position = Position;
	params.Size = Size;
	params.PointColor = PointColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugPlane
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FPlane                  PlaneCoordinates               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 Location                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Size                           (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            PlaneColor                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugPlane(class UObject* WorldContextObject, const struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPlane");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPlane");

	UEngine_KismetSystemLibrary_DrawDebugPlane_Params params;
	params.WorldContextObject = WorldContextObject;
	params.PlaneCoordinates = PlaneCoordinates;
	params.Location = Location;
	params.Size = Size;
	params.PlaneColor = PlaneColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugLine
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineStart                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineEnd                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugLine(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugLine");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugLine");

	UEngine_KismetSystemLibrary_DrawDebugLine_Params params;
	params.WorldContextObject = WorldContextObject;
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugFrustum
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              FrustumTransform               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FLinearColor            FrustumColor                   (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugFrustum(class UObject* WorldContextObject, const struct FTransform& FrustumTransform, const struct FLinearColor& FrustumColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFrustum");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFrustum");

	UEngine_KismetSystemLibrary_DrawDebugFrustum_Params params;
	params.WorldContextObject = WorldContextObject;
	params.FrustumTransform = FrustumTransform;
	params.FrustumColor = FrustumColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DebugFloatHistory FloatHistory                   (ConstParm, Parm, OutParm, ReferenceParm)
// struct FTransform              DrawTransform                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector2D               DrawSize                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            DrawColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugFloatHistoryTransform(class UObject* WorldContextObject, const struct FEngine_DebugFloatHistory& FloatHistory, const struct FTransform& DrawTransform, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform");

	UEngine_KismetSystemLibrary_DrawDebugFloatHistoryTransform_Params params;
	params.WorldContextObject = WorldContextObject;
	params.FloatHistory = FloatHistory;
	params.DrawTransform = DrawTransform;
	params.DrawSize = DrawSize;
	params.DrawColor = DrawColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DebugFloatHistory FloatHistory                   (ConstParm, Parm, OutParm, ReferenceParm)
// struct FVector                 DrawLocation                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               DrawSize                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            DrawColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugFloatHistoryLocation(class UObject* WorldContextObject, const struct FEngine_DebugFloatHistory& FloatHistory, const struct FVector& DrawLocation, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation");

	UEngine_KismetSystemLibrary_DrawDebugFloatHistoryLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.FloatHistory = FloatHistory;
	params.DrawLocation = DrawLocation;
	params.DrawSize = DrawSize;
	params.DrawColor = DrawColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugCylinder
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            Segments                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugCylinder(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int Segments, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCylinder");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCylinder");

	UEngine_KismetSystemLibrary_DrawDebugCylinder_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.Segments = Segments;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 AxisLoc                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                AxisRot                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugCoordinateSystem(class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem");

	UEngine_KismetSystemLibrary_DrawDebugCoordinateSystem_Params params;
	params.WorldContextObject = WorldContextObject;
	params.AxisLoc = AxisLoc;
	params.AxisRot = AxisRot;
	params.Scale = Scale;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Direction                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Length                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngleWidth                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngleHeight                    (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumSides                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugConeInDegrees(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees");

	UEngine_KismetSystemLibrary_DrawDebugConeInDegrees_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.Direction = Direction;
	params.Length = Length;
	params.AngleWidth = AngleWidth;
	params.AngleHeight = AngleHeight;
	params.NumSides = NumSides;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugCone
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Origin                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Direction                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Length                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngleWidth                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngleHeight                    (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumSides                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugCone(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCone");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCone");

	UEngine_KismetSystemLibrary_DrawDebugCone_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Origin = Origin;
	params.Direction = Direction;
	params.Length = Length;
	params.AngleWidth = AngleWidth;
	params.AngleHeight = AngleHeight;
	params.NumSides = NumSides;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugCircle
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Center                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// int                            NumSegments                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 YAxis                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ZAxis                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bDrawAxis                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugCircle(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int NumSegments, const struct FLinearColor& LineColor, float Duration, float Thickness, const struct FVector& YAxis, const struct FVector& ZAxis, bool bDrawAxis)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCircle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCircle");

	UEngine_KismetSystemLibrary_DrawDebugCircle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.Radius = Radius;
	params.NumSegments = NumSegments;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;
	params.YAxis = YAxis;
	params.ZAxis = ZAxis;
	params.bDrawAxis = bDrawAxis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugCapsule
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Center                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugCapsule(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCapsule");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCapsule");

	UEngine_KismetSystemLibrary_DrawDebugCapsule_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.HalfHeight = HalfHeight;
	params.Radius = Radius;
	params.Rotation = Rotation;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugCamera
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AEngine_CameraActor*     CameraActor                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            CameraColor                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugCamera(class AEngine_CameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCamera");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCamera");

	UEngine_KismetSystemLibrary_DrawDebugCamera_Params params;
	params.CameraActor = CameraActor;
	params.CameraColor = CameraColor;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Center                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Extent                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugBox(class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugBox");

	UEngine_KismetSystemLibrary_DrawDebugBox_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Center = Center;
	params.Extent = Extent;
	params.LineColor = LineColor;
	params.Rotation = Rotation;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DrawDebugArrow
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineStart                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LineEnd                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ArrowSize                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            LineColor                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_DrawDebugArrow(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration, float Thickness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugArrow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugArrow");

	UEngine_KismetSystemLibrary_DrawDebugArrow_Params params;
	params.WorldContextObject = WorldContextObject;
	params.LineStart = LineStart;
	params.LineEnd = LineEnd;
	params.ArrowSize = ArrowSize;
	params.LineColor = LineColor;
	params.Duration = Duration;
	params.Thickness = Thickness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.DoesImplementInterface
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 TestObject                     (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Interface                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_DoesImplementInterface(class UObject* TestObject, class UClass* Interface)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DoesImplementInterface");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DoesImplementInterface");

	UEngine_KismetSystemLibrary_DoesImplementInterface_Params params;
	params.TestObject = TestObject;
	params.Interface = Interface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Delay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// float                          Duration                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_LatentActionInfo LatentInfo                     (Parm)

void UEngine_KismetSystemLibrary::STATIC_Delay(class UObject* WorldContextObject, float Duration, const struct FEngine_LatentActionInfo& LatentInfo)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Delay");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Delay");

	UEngine_KismetSystemLibrary_Delay_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Duration = Duration;
	params.LatentInfo = LatentInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 ObjectToModify                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_CreateCopyForUndoBuffer(class UObject* ObjectToModify)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer");

	UEngine_KismetSystemLibrary_CreateCopyForUndoBuffer_Params params;
	params.ObjectToModify = ObjectToModify;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ConvertToRelativePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Filename                       (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_ConvertToRelativePath(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ConvertToRelativePath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ConvertToRelativePath");

	UEngine_KismetSystemLibrary_ConvertToRelativePath_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ConvertToAbsolutePath
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Filename                       (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_ConvertToAbsolutePath(const struct FString& Filename)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ConvertToAbsolutePath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ConvertToAbsolutePath");

	UEngine_KismetSystemLibrary_ConvertToAbsolutePath_Params params;
	params.Filename = Filename;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftObjPathToSoftObjRef
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath         SoftObjectPath                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_Conv_SoftObjPathToSoftObjRef(const struct FSoftObjectPath& SoftObjectPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjPathToSoftObjRef");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjPathToSoftObjRef");

	UEngine_KismetSystemLibrary_Conv_SoftObjPathToSoftObjRef_Params params;
	params.SoftObjectPath = SoftObjectPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToString
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_Conv_SoftObjectReferenceToString()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToString");

	UEngine_KismetSystemLibrary_Conv_SoftObjectReferenceToString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToObject
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UEngine_KismetSystemLibrary::STATIC_Conv_SoftObjectReferenceToObject()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToObject");

	UEngine_KismetSystemLibrary_Conv_SoftObjectReferenceToObject_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToString
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_Conv_SoftClassReferenceToString()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToString");

	UEngine_KismetSystemLibrary_Conv_SoftClassReferenceToString_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToClass
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UClass* UEngine_KismetSystemLibrary::STATIC_Conv_SoftClassReferenceToClass()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToClass");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToClass");

	UEngine_KismetSystemLibrary_Conv_SoftClassReferenceToClass_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_SoftClassPathToSoftClassRef
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftClassPath          SoftClassPath                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_KismetSystemLibrary::STATIC_Conv_SoftClassPathToSoftClassRef(const struct FSoftClassPath& SoftClassPath)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassPathToSoftClassRef");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_SoftClassPathToSoftClassRef");

	UEngine_KismetSystemLibrary_Conv_SoftClassPathToSoftClassRef_Params params;
	params.SoftClassPath = SoftClassPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetTypeToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetType       PrimaryAssetType               (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_Conv_PrimaryAssetTypeToString(const struct FPrimaryAssetType& PrimaryAssetType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_PrimaryAssetTypeToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_PrimaryAssetTypeToString");

	UEngine_KismetSystemLibrary_Conv_PrimaryAssetTypeToString_Params params;
	params.PrimaryAssetType = PrimaryAssetType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetIdToString
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPrimaryAssetId         PrimaryAssetId                 (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetSystemLibrary::STATIC_Conv_PrimaryAssetIdToString(const struct FPrimaryAssetId& PrimaryAssetId)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_PrimaryAssetIdToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_PrimaryAssetIdToString");

	UEngine_KismetSystemLibrary_Conv_PrimaryAssetIdToString_Params params;
	params.PrimaryAssetId = PrimaryAssetId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_ObjectToSoftObjectReference
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 Object                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_Conv_ObjectToSoftObjectReference(class UObject* Object)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_ObjectToSoftObjectReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_ObjectToSoftObjectReference");

	UEngine_KismetSystemLibrary_Conv_ObjectToSoftObjectReference_Params params;
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.Conv_InterfaceToObject
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// TScriptInterface<class UInterface> Interface                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// class UObject*                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UObject* UEngine_KismetSystemLibrary::STATIC_Conv_InterfaceToObject(const TScriptInterface<class UInterface>& Interface)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_InterfaceToObject");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_InterfaceToObject");

	UEngine_KismetSystemLibrary_Conv_InterfaceToObject_Params params;
	params.Interface = Interface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.Conv_ClassToSoftClassReference
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  Class                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_Conv_ClassToSoftClassReference(class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_ClassToSoftClassReference");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_ClassToSoftClassReference");

	UEngine_KismetSystemLibrary_Conv_ClassToSoftClassReference_Params params;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ControlScreensaver
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bAllowScreenSaver              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_ControlScreensaver(bool bAllowScreenSaver)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ControlScreensaver");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ControlScreensaver");

	UEngine_KismetSystemLibrary_ControlScreensaver_Params params;
	params.bAllowScreenSaver = bAllowScreenSaver;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.ComponentOverlapComponents
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FTransform              ComponentTransform             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ComponentClassFilter           (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class UEngine_PrimitiveComponent*> OutComponents                  (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_ComponentOverlapComponents(class UEngine_PrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class UEngine_PrimitiveComponent*>* OutComponents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapComponents");

	UEngine_KismetSystemLibrary_ComponentOverlapComponents_Params params;
	params.Component = Component;
	params.ComponentTransform = ComponentTransform;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.ComponentOverlapActors
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FTransform              ComponentTransform             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ActorClassFilter               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_ComponentOverlapActors(class UEngine_PrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapActors");

	UEngine_KismetSystemLibrary_ComponentOverlapActors_Params params;
	params.Component = Component;
	params.ComponentTransform = ComponentTransform;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CollectGarbage
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_KismetSystemLibrary::STATIC_CollectGarbage()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CollectGarbage");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CollectGarbage");

	UEngine_KismetSystemLibrary_CollectGarbage_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects");

	UEngine_KismetSystemLibrary_CapsuleTraceSingleForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleByProfile");

	UEngine_KismetSystemLibrary_CapsuleTraceSingleByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceSingle
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingle");

	UEngine_KismetSystemLibrary_CapsuleTraceSingle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects");

	UEngine_KismetSystemLibrary_CapsuleTraceMultiForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiByProfile");

	UEngine_KismetSystemLibrary_CapsuleTraceMultiByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleTraceMulti
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMulti");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMulti");

	UEngine_KismetSystemLibrary_CapsuleTraceMulti_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleOverlapComponents
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 CapsulePos                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ComponentClassFilter           (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class UEngine_PrimitiveComponent*> OutComponents                  (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleOverlapComponents(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class UEngine_PrimitiveComponent*>* OutComponents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapComponents");

	UEngine_KismetSystemLibrary_CapsuleOverlapComponents_Params params;
	params.WorldContextObject = WorldContextObject;
	params.CapsulePos = CapsulePos;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CapsuleOverlapActors
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 CapsulePos                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// float                          HalfHeight                     (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ActorClassFilter               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CapsuleOverlapActors(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapActors");

	UEngine_KismetSystemLibrary_CapsuleOverlapActors_Params params;
	params.WorldContextObject = WorldContextObject;
	params.CapsulePos = CapsulePos;
	params.Radius = Radius;
	params.HalfHeight = HalfHeight;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CanLaunchURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 URL                            (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_CanLaunchURL(const struct FString& URL)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CanLaunchURL");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CanLaunchURL");

	UEngine_KismetSystemLibrary_CanLaunchURL_Params params;
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.CancelTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int                            Index                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetSystemLibrary::STATIC_CancelTransaction(int Index)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CancelTransaction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CancelTransaction");

	UEngine_KismetSystemLibrary_CancelTransaction_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetSystemLibrary.BreakSoftObjectPath
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftObjectPath         InSoftObjectPath               (Parm, ZeroConstructor)
// struct FString                 PathString                     (Parm, OutParm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_BreakSoftObjectPath(const struct FSoftObjectPath& InSoftObjectPath, struct FString* PathString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BreakSoftObjectPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BreakSoftObjectPath");

	UEngine_KismetSystemLibrary_BreakSoftObjectPath_Params params;
	params.InSoftObjectPath = InSoftObjectPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PathString != nullptr)
		*PathString = params.PathString;
}


// Function Engine.KismetSystemLibrary.BreakSoftClassPath
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSoftClassPath          InSoftClassPath                (Parm, ZeroConstructor)
// struct FString                 PathString                     (Parm, OutParm, ZeroConstructor)

void UEngine_KismetSystemLibrary::STATIC_BreakSoftClassPath(const struct FSoftClassPath& InSoftClassPath, struct FString* PathString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BreakSoftClassPath");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BreakSoftClassPath");

	UEngine_KismetSystemLibrary_BreakSoftClassPath_Params params;
	params.InSoftClassPath = InSoftClassPath;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PathString != nullptr)
		*PathString = params.PathString;
}


// Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HalfSize                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Orientation                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects");

	UEngine_KismetSystemLibrary_BoxTraceSingleForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceSingleByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HalfSize                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Orientation                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxTraceSingleByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleByProfile");

	UEngine_KismetSystemLibrary_BoxTraceSingleByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceSingle
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HalfSize                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Orientation                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_HitResult       OutHit                         (Parm, OutParm, IsPlainOldData)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, struct FEngine_HitResult* OutHit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingle");

	UEngine_KismetSystemLibrary_BoxTraceSingle_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHit != nullptr)
		*OutHit = params.OutHit;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HalfSize                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Orientation                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects");

	UEngine_KismetSystemLibrary_BoxTraceMultiForObjects_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.ObjectTypes = ObjectTypes;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceMultiByProfile
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HalfSize                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Orientation                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxTraceMultiByProfile(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, const struct FName& ProfileName, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiByProfile");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiByProfile");

	UEngine_KismetSystemLibrary_BoxTraceMultiByProfile_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.ProfileName = ProfileName;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxTraceMulti
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Start                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 End                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 HalfSize                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Orientation                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bTraceComplex                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType                  (Parm, ZeroConstructor, IsPlainOldData)
// TArray<struct FEngine_HitResult> OutHits                        (Parm, OutParm, ZeroConstructor)
// bool                           bIgnoreSelf                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceColor                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            TraceHitColor                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          DrawTime                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TEnumAsByte<FEngine_Engine_ETraceTypeQuery> TraceChannel, bool bTraceComplex, TArray<class AEngine_Actor*> ActorsToIgnore, TEnumAsByte<FEngine_Engine_EDrawDebugTrace> DrawDebugType, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime, TArray<struct FEngine_HitResult>* OutHits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMulti");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMulti");

	UEngine_KismetSystemLibrary_BoxTraceMulti_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Start = Start;
	params.End = End;
	params.HalfSize = HalfSize;
	params.Orientation = Orientation;
	params.TraceChannel = TraceChannel;
	params.bTraceComplex = bTraceComplex;
	params.ActorsToIgnore = ActorsToIgnore;
	params.DrawDebugType = DrawDebugType;
	params.bIgnoreSelf = bIgnoreSelf;
	params.TraceColor = TraceColor;
	params.TraceHitColor = TraceHitColor;
	params.DrawTime = DrawTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutHits != nullptr)
		*OutHits = params.OutHits;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxOverlapComponents
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxPos                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Extent                         (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ComponentClassFilter           (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class UEngine_PrimitiveComponent*> OutComponents                  (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxOverlapComponents(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class UEngine_PrimitiveComponent*>* OutComponents)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapComponents");

	UEngine_KismetSystemLibrary_BoxOverlapComponents_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BoxPos = BoxPos;
	params.Extent = Extent;
	params.ObjectTypes = ObjectTypes;
	params.ComponentClassFilter = ComponentClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutComponents != nullptr)
		*OutComponents = params.OutComponents;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BoxOverlapActors
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxPos                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 BoxExtent                      (Parm, ZeroConstructor, IsPlainOldData)
// TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UClass*                  ActorClassFilter               (Parm, ZeroConstructor, IsPlainOldData)
// TArray<class AEngine_Actor*>   ActorsToIgnore                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TArray<class AEngine_Actor*>   OutActors                      (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetSystemLibrary::STATIC_BoxOverlapActors(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TArray<TEnumAsByte<FEngine_Engine_EObjectTypeQuery>> ObjectTypes, class UClass* ActorClassFilter, TArray<class AEngine_Actor*> ActorsToIgnore, TArray<class AEngine_Actor*>* OutActors)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapActors");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapActors");

	UEngine_KismetSystemLibrary_BoxOverlapActors_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BoxPos = BoxPos;
	params.BoxExtent = BoxExtent;
	params.ObjectTypes = ObjectTypes;
	params.ActorClassFilter = ActorClassFilter;
	params.ActorsToIgnore = ActorsToIgnore;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutActors != nullptr)
		*OutActors = params.OutActors;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.BeginTransaction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FString                 Context                        (Parm, ZeroConstructor)
// struct FText                   Description                    (Parm)
// class UObject*                 PrimaryObject                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_KismetSystemLibrary::STATIC_BeginTransaction(const struct FString& Context, const struct FText& Description, class UObject* PrimaryObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BeginTransaction");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BeginTransaction");

	UEngine_KismetSystemLibrary_BeginTransaction_Params params;
	params.Context = Context;
	params.Description = Description;
	params.PrimaryObject = PrimaryObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetSystemLibrary.AddFloatHistorySample
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_DebugFloatHistory FloatHistory                   (ConstParm, Parm, OutParm, ReferenceParm)
// struct FEngine_DebugFloatHistory ReturnValue                    (Parm, OutParm, ReturnParm)

struct FEngine_DebugFloatHistory UEngine_KismetSystemLibrary::STATIC_AddFloatHistorySample(float Value, const struct FEngine_DebugFloatHistory& FloatHistory)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.AddFloatHistorySample");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.AddFloatHistorySample");

	UEngine_KismetSystemLibrary_AddFloatHistorySample_Params params;
	params.Value = Value;
	params.FloatHistory = FloatHistory;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextTrimTrailing
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_TextTrimTrailing(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimTrailing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimTrailing");

	UEngine_KismetTextLibrary_TextTrimTrailing_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_TextTrimPrecedingAndTrailing(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing");

	UEngine_KismetTextLibrary_TextTrimPrecedingAndTrailing_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextTrimPreceding
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_TextTrimPreceding(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPreceding");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPreceding");

	UEngine_KismetTextLibrary_TextTrimPreceding_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextToUpper
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_TextToUpper(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextToUpper");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextToUpper");

	UEngine_KismetTextLibrary_TextToUpper_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextToLower
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_TextToLower(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextToLower");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextToLower");

	UEngine_KismetTextLibrary_TextToLower_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsTransient
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_TextIsTransient(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsTransient");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsTransient");

	UEngine_KismetTextLibrary_TextIsTransient_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsFromStringTable
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   Text                           (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_TextIsFromStringTable(const struct FText& Text)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsFromStringTable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsFromStringTable");

	UEngine_KismetTextLibrary_TextIsFromStringTable_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsEmpty
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_TextIsEmpty(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsEmpty");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsEmpty");

	UEngine_KismetTextLibrary_TextIsEmpty_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextIsCultureInvariant
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_TextIsCultureInvariant(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsCultureInvariant");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsCultureInvariant");

	UEngine_KismetTextLibrary_TextIsCultureInvariant_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.TextFromStringTable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   TableId                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Key                            (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_TextFromStringTable(const struct FName& TableId, const struct FString& Key)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextFromStringTable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextFromStringTable");

	UEngine_KismetTextLibrary_TextFromStringTable_Params params;
	params.TableId = TableId;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.StringTableIdAndKeyFromText
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   Text                           (Parm)
// struct FName                   OutTableId                     (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FString                 OutKey                         (Parm, OutParm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_StringTableIdAndKeyFromText(const struct FText& Text, struct FName* OutTableId, struct FString* OutKey)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.StringTableIdAndKeyFromText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.StringTableIdAndKeyFromText");

	UEngine_KismetTextLibrary_StringTableIdAndKeyFromText_Params params;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTableId != nullptr)
		*OutTableId = params.OutTableId;
	if (OutKey != nullptr)
		*OutKey = params.OutKey;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.PolyglotDataToText
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPolyglotTextData       PolyglotData                   (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_PolyglotDataToText(const struct FPolyglotTextData& PolyglotData)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.PolyglotDataToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.PolyglotDataToText");

	UEngine_KismetTextLibrary_PolyglotDataToText_Params params;
	params.PolyglotData = PolyglotData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.NotEqual_TextText
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   A                              (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   B                              (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_NotEqual_TextText(const struct FText& A, const struct FText& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_TextText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_TextText");

	UEngine_KismetTextLibrary_NotEqual_TextText_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   A                              (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   B                              (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_NotEqual_IgnoreCase_TextText(const struct FText& A, const struct FText& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText");

	UEngine_KismetTextLibrary_NotEqual_IgnoreCase_TextText_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.IsPolyglotDataValid
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPolyglotTextData       PolyglotData                   (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           IsValid                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FText                   ErrorMessage                   (Parm, OutParm)

void UEngine_KismetTextLibrary::STATIC_IsPolyglotDataValid(const struct FPolyglotTextData& PolyglotData, bool* IsValid, struct FText* ErrorMessage)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.IsPolyglotDataValid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.IsPolyglotDataValid");

	UEngine_KismetTextLibrary_IsPolyglotDataValid_Params params;
	params.PolyglotData = PolyglotData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (IsValid != nullptr)
		*IsValid = params.IsValid;
	if (ErrorMessage != nullptr)
		*ErrorMessage = params.ErrorMessage;
}


// Function Engine.KismetTextLibrary.GetEmptyText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_GetEmptyText()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.GetEmptyText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.GetEmptyText");

	UEngine_KismetTextLibrary_GetEmptyText_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Format
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InPattern                      (Parm)
// TArray<struct FEngine_FormatArgumentData> InArgs                         (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Format(const struct FText& InPattern, TArray<struct FEngine_FormatArgumentData> InArgs)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Format");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Format");

	UEngine_KismetTextLibrary_Format_Params params;
	params.InPattern = InPattern;
	params.InArgs = InArgs;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.FindTextInLocalizationTable
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 Namespace                      (Parm, ZeroConstructor)
// struct FString                 Key                            (Parm, ZeroConstructor)
// struct FText                   OutText                        (Parm, OutParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_FindTextInLocalizationTable(const struct FString& Namespace, const struct FString& Key, struct FText* OutText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.FindTextInLocalizationTable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.FindTextInLocalizationTable");

	UEngine_KismetTextLibrary_FindTextInLocalizationTable_Params params;
	params.Namespace = Namespace;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutText != nullptr)
		*OutText = params.OutText;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.EqualEqual_TextText
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   A                              (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   B                              (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_EqualEqual_TextText(const struct FText& A, const struct FText& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_TextText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_TextText");

	UEngine_KismetTextLibrary_EqualEqual_TextText_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   A                              (ConstParm, Parm, OutParm, ReferenceParm)
// struct FText                   B                              (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetTextLibrary::STATIC_EqualEqual_IgnoreCase_TextText(const struct FText& A, const struct FText& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText");

	UEngine_KismetTextLibrary_EqualEqual_IgnoreCase_TextText_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_VectorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                 InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_VectorToText(const struct FVector& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_VectorToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_VectorToText");

	UEngine_KismetTextLibrary_Conv_VectorToText_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_Vector2dToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D               InVec                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_Vector2dToText(const struct FVector2D& InVec)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_Vector2dToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_Vector2dToText");

	UEngine_KismetTextLibrary_Conv_Vector2dToText_Params params;
	params.InVec = InVec;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_TransformToText
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTransform              InTrans                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_TransformToText(const struct FTransform& InTrans)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TransformToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TransformToText");

	UEngine_KismetTextLibrary_Conv_TransformToText_Params params;
	params.InTrans = InTrans;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_TextToString
// (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FText                   InText                         (ConstParm, Parm, OutParm, ReferenceParm)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetTextLibrary::STATIC_Conv_TextToString(const struct FText& InText)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TextToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TextToString");

	UEngine_KismetTextLibrary_Conv_TextToString_Params params;
	params.InText = InText;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_StringToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 inString                       (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_StringToText(const struct FString& inString)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_StringToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_StringToText");

	UEngine_KismetTextLibrary_Conv_StringToText_Params params;
	params.inString = inString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_RotatorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                InRot                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_RotatorToText(const struct FRotator& InRot)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_RotatorToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_RotatorToText");

	UEngine_KismetTextLibrary_Conv_RotatorToText_Params params;
	params.InRot = InRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_ObjectToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 InObj                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_ObjectToText(class UObject* InObj)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ObjectToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ObjectToText");

	UEngine_KismetTextLibrary_Conv_ObjectToText_Params params;
	params.InObj = InObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_NameToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FName                   InName                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_NameToText(const struct FName& InName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_NameToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_NameToText");

	UEngine_KismetTextLibrary_Conv_NameToText_Params params;
	params.InName = InName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_IntToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAlwaysSign                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseGrouping                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_IntToText(int Value, bool bAlwaysSign, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_IntToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_IntToText");

	UEngine_KismetTextLibrary_Conv_IntToText_Params params;
	params.Value = Value;
	params.bAlwaysSign = bAlwaysSign;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_Int64ToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int64_t                        Value                          (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAlwaysSign                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseGrouping                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_Int64ToText(int64_t Value, bool bAlwaysSign, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_Int64ToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_Int64ToText");

	UEngine_KismetTextLibrary_Conv_Int64ToText_Params params;
	params.Value = Value;
	params.bAlwaysSign = bAlwaysSign;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_FloatToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAlwaysSign                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseGrouping                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_FloatToText(float Value, TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_FloatToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_FloatToText");

	UEngine_KismetTextLibrary_Conv_FloatToText_Params params;
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bAlwaysSign = bAlwaysSign;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_ColorToText
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor            InColor                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_ColorToText(const struct FLinearColor& InColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ColorToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ColorToText");

	UEngine_KismetTextLibrary_Conv_ColorToText_Params params;
	params.InColor = InColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_ByteToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// unsigned char                  Value                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_ByteToText(unsigned char Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ByteToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ByteToText");

	UEngine_KismetTextLibrary_Conv_ByteToText_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.Conv_BoolToText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                           InBool                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_Conv_BoolToText(bool InBool)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_BoolToText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_BoolToText");

	UEngine_KismetTextLibrary_Conv_BoolToText_Params params;
	params.InBool = InBool;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               InDateTime                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FString                 InTimeZone                     (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsTimeZoneTime_DateTime(const struct FDateTime& InDateTime, const struct FString& InTimeZone)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime");

	UEngine_KismetTextLibrary_AsTimeZoneTime_DateTime_Params params;
	params.InDateTime = InDateTime;
	params.InTimeZone = InTimeZone;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               InDateTime                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FString                 InTimeZone                     (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsTimeZoneDateTime_DateTime(const struct FDateTime& InDateTime, const struct FString& InTimeZone)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime");

	UEngine_KismetTextLibrary_AsTimeZoneDateTime_DateTime_Params params;
	params.InDateTime = InDateTime;
	params.InTimeZone = InTimeZone;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               InDateTime                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FString                 InTimeZone                     (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsTimeZoneDate_DateTime(const struct FDateTime& InDateTime, const struct FString& InTimeZone)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime");

	UEngine_KismetTextLibrary_AsTimeZoneDate_DateTime_Params params;
	params.InDateTime = InDateTime;
	params.InTimeZone = InTimeZone;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTimespan_Timespan
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan               InTimespan                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsTimespan_Timespan(const struct FTimespan& InTimespan)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimespan_Timespan");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimespan_Timespan");

	UEngine_KismetTextLibrary_AsTimespan_Timespan_Params params;
	params.InTimespan = InTimespan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsTime_DateTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               In                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsTime_DateTime(const struct FDateTime& In)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTime_DateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTime_DateTime");

	UEngine_KismetTextLibrary_AsTime_DateTime_Params params;
	params.In = In;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsPercent_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAlwaysSign                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseGrouping                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsPercent_Float(float Value, TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsPercent_Float");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsPercent_Float");

	UEngine_KismetTextLibrary_AsPercent_Float_Params params;
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bAlwaysSign = bAlwaysSign;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsDateTime_DateTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               In                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsDateTime_DateTime(const struct FDateTime& In)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDateTime_DateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDateTime_DateTime");

	UEngine_KismetTextLibrary_AsDateTime_DateTime_Params params;
	params.In = In;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsDate_DateTime
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDateTime               InDateTime                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsDate_DateTime(const struct FDateTime& InDateTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDate_DateTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDate_DateTime");

	UEngine_KismetTextLibrary_AsDate_DateTime_Params params;
	params.InDateTime = InDateTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsCurrencyBase
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            BaseValue                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 CurrencyCode                   (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsCurrencyBase(int BaseValue, const struct FString& CurrencyCode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrencyBase");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrencyBase");

	UEngine_KismetTextLibrary_AsCurrencyBase_Params params;
	params.BaseValue = BaseValue;
	params.CurrencyCode = CurrencyCode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsCurrency_Integer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int                            Value                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAlwaysSign                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseGrouping                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 CurrencyCode                   (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsCurrency_Integer(int Value, TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits, const struct FString& CurrencyCode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Integer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Integer");

	UEngine_KismetTextLibrary_AsCurrency_Integer_Params params;
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bAlwaysSign = bAlwaysSign;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;
	params.CurrencyCode = CurrencyCode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetTextLibrary.AsCurrency_Float
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAlwaysSign                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUseGrouping                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumIntegralDigits          (Parm, ZeroConstructor, IsPlainOldData)
// int                            MinimumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// int                            MaximumFractionalDigits        (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 CurrencyCode                   (Parm, ZeroConstructor)
// struct FText                   ReturnValue                    (Parm, OutParm, ReturnParm)

struct FText UEngine_KismetTextLibrary::STATIC_AsCurrency_Float(float Value, TEnumAsByte<FEngine_Engine_ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int MinimumIntegralDigits, int MaximumIntegralDigits, int MinimumFractionalDigits, int MaximumFractionalDigits, const struct FString& CurrencyCode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Float");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Float");

	UEngine_KismetTextLibrary_AsCurrency_Float_Params params;
	params.Value = Value;
	params.RoundingMode = RoundingMode;
	params.bAlwaysSign = bAlwaysSign;
	params.bUseGrouping = bUseGrouping;
	params.MinimumIntegralDigits = MinimumIntegralDigits;
	params.MaximumIntegralDigits = MaximumIntegralDigits;
	params.MinimumFractionalDigits = MinimumFractionalDigits;
	params.MaximumFractionalDigits = MaximumFractionalDigits;
	params.CurrencyCode = CurrencyCode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.World.K2_GetWorldSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_WorldSettings*   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_WorldSettings* UEngine_World::K2_GetWorldSettings()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.World.K2_GetWorldSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.World.K2_GetWorldSettings");

	UEngine_World_K2_GetWorldSettings_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.World.HandleTimelineScrubbed
// (Final, Native, Public)

void UEngine_World::HandleTimelineScrubbed()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.World.HandleTimelineScrubbed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.World.HandleTimelineScrubbed");

	UEngine_World_HandleTimelineScrubbed_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelStreaming.ShouldBeLoaded
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_LevelStreaming::ShouldBeLoaded()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.ShouldBeLoaded");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.ShouldBeLoaded");

	UEngine_LevelStreaming_ShouldBeLoaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreaming.SetShouldBeVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInShouldBeVisible             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LevelStreaming::SetShouldBeVisible(bool bInShouldBeVisible)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetShouldBeVisible");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetShouldBeVisible");

	UEngine_LevelStreaming_SetShouldBeVisible_Params params;
	params.bInShouldBeVisible = bInShouldBeVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelStreaming.SetShouldBeLoaded
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bInShouldBeLoaded              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LevelStreaming::SetShouldBeLoaded(bool bInShouldBeLoaded)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetShouldBeLoaded");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetShouldBeLoaded");

	UEngine_LevelStreaming_SetShouldBeLoaded_Params params;
	params.bInShouldBeLoaded = bInShouldBeLoaded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelStreaming.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            NewPriority                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LevelStreaming::SetPriority(int NewPriority)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetPriority");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetPriority");

	UEngine_LevelStreaming_SetPriority_Params params;
	params.NewPriority = NewPriority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelStreaming.SetLevelLODIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            LODIndex                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LevelStreaming::SetLevelLODIndex(int LODIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetLevelLODIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.SetLevelLODIndex");

	UEngine_LevelStreaming_SetLevelLODIndex_Params params;
	params.LODIndex = LODIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LevelStreaming.IsStreamingStatePending
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_LevelStreaming::IsStreamingStatePending()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsStreamingStatePending");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsStreamingStatePending");

	UEngine_LevelStreaming_IsStreamingStatePending_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreaming.IsLevelVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_LevelStreaming::IsLevelVisible()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelVisible");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelVisible");

	UEngine_LevelStreaming_IsLevelVisible_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreaming.IsLevelLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_LevelStreaming::IsLevelLoaded()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelLoaded");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelLoaded");

	UEngine_LevelStreaming_IsLevelLoaded_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreaming.GetWorldAssetPackageFName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_LevelStreaming::GetWorldAssetPackageFName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetWorldAssetPackageFName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetWorldAssetPackageFName");

	UEngine_LevelStreaming_GetWorldAssetPackageFName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreaming.GetLoadedLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_Level*           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Level* UEngine_LevelStreaming::GetLoadedLevel()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetLoadedLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetLoadedLevel");

	UEngine_LevelStreaming_GetLoadedLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreaming.GetLevelScriptActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_LevelScriptActor* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class AEngine_LevelScriptActor* UEngine_LevelStreaming::GetLevelScriptActor()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetLevelScriptActor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.GetLevelScriptActor");

	UEngine_LevelStreaming_GetLevelScriptActor_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreaming.CreateInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 UniqueInstanceName             (Parm, ZeroConstructor)
// class UEngine_LevelStreaming*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_LevelStreaming* UEngine_LevelStreaming::CreateInstance(const struct FString& UniqueInstanceName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.CreateInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.CreateInstance");

	UEngine_LevelStreaming_CreateInstance_Params params;
	params.UniqueInstanceName = UniqueInstanceName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.LevelStreamingDynamic.LoadLevelInstanceBySoftObjectPtr
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOutSuccess                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_LevelStreamingDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_LevelStreamingDynamic* UEngine_LevelStreamingDynamic::STATIC_LoadLevelInstanceBySoftObjectPtr(class UObject* WorldContextObject, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreamingDynamic.LoadLevelInstanceBySoftObjectPtr");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreamingDynamic.LoadLevelInstanceBySoftObjectPtr");

	UEngine_LevelStreamingDynamic_LoadLevelInstanceBySoftObjectPtr_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Location = Location;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bOutSuccess != nullptr)
		*bOutSuccess = params.bOutSuccess;

	return params.ReturnValue;
}


// Function Engine.LevelStreamingDynamic.LoadLevelInstance
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 LevelName                      (Parm, ZeroConstructor)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bOutSuccess                    (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_LevelStreamingDynamic* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_LevelStreamingDynamic* UEngine_LevelStreamingDynamic::STATIC_LoadLevelInstance(class UObject* WorldContextObject, const struct FString& LevelName, const struct FVector& Location, const struct FRotator& Rotation, bool* bOutSuccess)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LevelStreamingDynamic.LoadLevelInstance");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LevelStreamingDynamic.LoadLevelInstance");

	UEngine_LevelStreamingDynamic_LoadLevelInstance_Params params;
	params.WorldContextObject = WorldContextObject;
	params.LevelName = LevelName;
	params.Location = Location;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (bOutSuccess != nullptr)
		*bOutSuccess = params.bOutSuccess;

	return params.ReturnValue;
}


// Function Engine.LocalLightComponent.SetIntensityUnits
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_ELightUnits     NewIntensityUnits              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LocalLightComponent::SetIntensityUnits(FEngine_Engine_ELightUnits NewIntensityUnits)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.SetIntensityUnits");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.SetIntensityUnits");

	UEngine_LocalLightComponent_SetIntensityUnits_Params params;
	params.NewIntensityUnits = NewIntensityUnits;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalLightComponent.SetAttenuationRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewRadius                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_LocalLightComponent::SetAttenuationRadius(float NewRadius)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.SetAttenuationRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.SetAttenuationRadius");

	UEngine_LocalLightComponent_SetAttenuationRadius_Params params;
	params.NewRadius = NewRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.LocalLightComponent.GetUnitsConversionFactor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// FEngine_Engine_ELightUnits     SrcUnits                       (Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_ELightUnits     TargetUnits                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          CosHalfConeAngle               (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_LocalLightComponent::STATIC_GetUnitsConversionFactor(FEngine_Engine_ELightUnits SrcUnits, FEngine_Engine_ELightUnits TargetUnits, float CosHalfConeAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.GetUnitsConversionFactor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.LocalLightComponent.GetUnitsConversionFactor");

	UEngine_LocalLightComponent_GetUnitsConversionFactor_Params params;
	params.SrcUnits = SrcUnits;
	params.TargetUnits = TargetUnits;
	params.CosHalfConeAngle = CosHalfConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialBillboardComponent.SetElements
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<struct FEngine_MaterialSpriteElement> NewElements                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_MaterialBillboardComponent::SetElements(TArray<struct FEngine_MaterialSpriteElement> NewElements)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.SetElements");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.SetElements");

	UEngine_MaterialBillboardComponent_SetElements_Params params;
	params.NewElements = NewElements;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialBillboardComponent.AddElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_CurveFloat*      DistanceToOpacityCurve         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bSizeIsInScreenSpace           (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseSizeX                      (Parm, ZeroConstructor, IsPlainOldData)
// float                          BaseSizeY                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_CurveFloat*      DistanceToSizeCurve            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialBillboardComponent::AddElement(class UEngine_MaterialInterface* Material, class UEngine_CurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UEngine_CurveFloat* DistanceToSizeCurve)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.AddElement");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.AddElement");

	UEngine_MaterialBillboardComponent_AddElement_Params params;
	params.Material = Material;
	params.DistanceToOpacityCurve = DistanceToOpacityCurve;
	params.bSizeIsInScreenSpace = bSizeIsInScreenSpace;
	params.BaseSizeX = BaseSizeX;
	params.BaseSizeY = BaseSizeY;
	params.DistanceToSizeCurve = DistanceToSizeCurve;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.KismetGuidLibrary.Parse_StringToGuid
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FString                 GuidString                     (Parm, ZeroConstructor)
// struct FGuid                   OutGuid                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// bool                           success                        (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_KismetGuidLibrary::STATIC_Parse_StringToGuid(const struct FString& GuidString, struct FGuid* OutGuid, bool* success)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Parse_StringToGuid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Parse_StringToGuid");

	UEngine_KismetGuidLibrary_Parse_StringToGuid_Params params;
	params.GuidString = GuidString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutGuid != nullptr)
		*OutGuid = params.OutGuid;
	if (success != nullptr)
		*success = params.success;
}


// Function Engine.KismetGuidLibrary.NotEqual_GuidGuid
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                   A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FGuid                   B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetGuidLibrary::STATIC_NotEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NotEqual_GuidGuid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NotEqual_GuidGuid");

	UEngine_KismetGuidLibrary_NotEqual_GuidGuid_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetGuidLibrary.NewGuid
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FGuid UEngine_KismetGuidLibrary::STATIC_NewGuid()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NewGuid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.NewGuid");

	UEngine_KismetGuidLibrary_NewGuid_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetGuidLibrary.IsValid_Guid
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                   InGuid                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetGuidLibrary::STATIC_IsValid_Guid(const struct FGuid& InGuid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.IsValid_Guid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.IsValid_Guid");

	UEngine_KismetGuidLibrary_IsValid_Guid_Params params;
	params.InGuid = InGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetGuidLibrary.Invalidate_Guid
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FGuid                   InGuid                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_KismetGuidLibrary::STATIC_Invalidate_Guid(struct FGuid* InGuid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Invalidate_Guid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Invalidate_Guid");

	UEngine_KismetGuidLibrary_Invalidate_Guid_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (InGuid != nullptr)
		*InGuid = params.InGuid;
}


// Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                   A                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FGuid                   B                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_KismetGuidLibrary::STATIC_EqualEqual_GuidGuid(const struct FGuid& A, const struct FGuid& B)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid");

	UEngine_KismetGuidLibrary_EqualEqual_GuidGuid_Params params;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.KismetGuidLibrary.Conv_GuidToString
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGuid                   InGuid                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_KismetGuidLibrary::STATIC_Conv_GuidToString(const struct FGuid& InGuid)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Conv_GuidToString");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.KismetGuidLibrary.Conv_GuidToString");

	UEngine_KismetGuidLibrary_Conv_GuidToString_Params params;
	params.InGuid = InGuid;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.SetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInstanceDynamic::SetVectorParameterValue(const struct FName& ParameterName, const struct FLinearColor& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetVectorParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetVectorParameterValue");

	UEngine_MaterialInstanceDynamic_SetVectorParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceDynamic.SetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInstanceDynamic::SetTextureParameterValue(const struct FName& ParameterName, class UEngine_Texture* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetTextureParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetTextureParameterValue");

	UEngine_MaterialInstanceDynamic_SetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceDynamic.SetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInstanceDynamic::SetScalarParameterValue(const struct FName& ParameterName, float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetScalarParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetScalarParameterValue");

	UEngine_MaterialInstanceDynamic_SetScalarParameterValue_Params params;
	params.ParameterName = ParameterName;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInstance* SourceA                        (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInstance* SourceB                        (Parm, ZeroConstructor, IsPlainOldData)
// float                          ALPHA                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInstanceDynamic::K2_InterpolateMaterialInstanceParams(class UEngine_MaterialInstance* SourceA, class UEngine_MaterialInstance* SourceB, float ALPHA)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams");

	UEngine_MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams_Params params;
	params.SourceA = SourceA;
	params.SourceB = SourceB;
	params.ALPHA = ALPHA;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FLinearColor            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FLinearColor UEngine_MaterialInstanceDynamic::K2_GetVectorParameterValue(const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue");

	UEngine_MaterialInstanceDynamic_K2_GetVectorParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_Texture*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Texture* UEngine_MaterialInstanceDynamic::K2_GetTextureParameterValue(const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue");

	UEngine_MaterialInstanceDynamic_K2_GetTextureParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   ParameterName                  (Parm, ZeroConstructor, IsPlainOldData)
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_MaterialInstanceDynamic::K2_GetScalarParameterValue(const struct FName& ParameterName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue");

	UEngine_MaterialInstanceDynamic_K2_GetScalarParameterValue_Params params;
	params.ParameterName = ParameterName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Source                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bQuickParametersOnly           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInstanceDynamic::K2_CopyMaterialInstanceParameters(class UEngine_MaterialInterface* Source, bool bQuickParametersOnly)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters");

	UEngine_MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters_Params params;
	params.Source = Source;
	params.bQuickParametersOnly = bQuickParametersOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceDynamic.CopyParameterOverrides
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInstance* MaterialInstance               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInstanceDynamic::CopyParameterOverrides(class UEngine_MaterialInstance* MaterialInstance)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyParameterOverrides");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyParameterOverrides");

	UEngine_MaterialInstanceDynamic_CopyParameterOverrides_Params params;
	params.MaterialInstance = MaterialInstance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MaterialInstanceDynamic.CopyInterpParameters
// (Final, Native, Public)
// Parameters:
// class UEngine_MaterialInstance* Source                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MaterialInstanceDynamic::CopyInterpParameters(class UEngine_MaterialInstance* Source)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyInterpParameters");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyInterpParameters");

	UEngine_MaterialInstanceDynamic_CopyInterpParameters_Params params;
	params.Source = Source;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.Stop
// (Native, Public, BlueprintCallable)

void AEngine_MatineeActor::Stop()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Stop");

	AEngine_MatineeActor_Stop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.SetPosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewPosition                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bJump                          (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_MatineeActor::SetPosition(float NewPosition, bool bJump)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetPosition");

	AEngine_MatineeActor_SetPosition_Params params;
	params.NewPosition = NewPosition;
	params.bJump = bJump;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.SetLoopingState
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewLooping                    (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_MatineeActor::SetLoopingState(bool bNewLooping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetLoopingState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetLoopingState");

	AEngine_MatineeActor_SetLoopingState_Params params;
	params.bNewLooping = bNewLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.Reverse
// (Native, Public, BlueprintCallable)

void AEngine_MatineeActor::Reverse()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Reverse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Reverse");

	AEngine_MatineeActor_Reverse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.Play
// (Native, Public, BlueprintCallable)

void AEngine_MatineeActor::Play()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Play");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Play");

	AEngine_MatineeActor_Play_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.Pause
// (Native, Public, BlueprintCallable)

void AEngine_MatineeActor::Pause()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Pause");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Pause");

	AEngine_MatineeActor_Pause_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.EnableGroupByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 GroupName                      (Parm, ZeroConstructor)
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_MatineeActor::EnableGroupByName(const struct FString& GroupName, bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.EnableGroupByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.EnableGroupByName");

	AEngine_MatineeActor_EnableGroupByName_Params params;
	params.GroupName = GroupName;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MatineeActor.ChangePlaybackDirection
// (Native, Public, BlueprintCallable)

void AEngine_MatineeActor::ChangePlaybackDirection()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.ChangePlaybackDirection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.ChangePlaybackDirection");

	AEngine_MatineeActor_ChangePlaybackDirection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEngine_StaticMeshComponent* StaticMeshComponent            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_MeshVertexPainterKismetLibrary::STATIC_RemovePaintedVertices(class UEngine_StaticMeshComponent* StaticMeshComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices");

	UEngine_MeshVertexPainterKismetLibrary_RemovePaintedVertices_Params params;
	params.StaticMeshComponent = StaticMeshComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_StaticMeshComponent* StaticMeshComponent            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FLinearColor            FillColor                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           bConvertToSRGB                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MeshVertexPainterKismetLibrary::STATIC_PaintVerticesSingleColor(class UEngine_StaticMeshComponent* StaticMeshComponent, const struct FLinearColor& FillColor, bool bConvertToSRGB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor");

	UEngine_MeshVertexPainterKismetLibrary_PaintVerticesSingleColor_Params params;
	params.StaticMeshComponent = StaticMeshComponent;
	params.FillColor = FillColor;
	params.bConvertToSRGB = bConvertToSRGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis
// (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_StaticMeshComponent* StaticMeshComponent            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FLinearColor            StartColor                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FLinearColor            EndColor                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// FEngine_Engine_EVertexPaintAxis Axis                           (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bConvertToSRGB                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_MeshVertexPainterKismetLibrary::STATIC_PaintVerticesLerpAlongAxis(class UEngine_StaticMeshComponent* StaticMeshComponent, const struct FLinearColor& StartColor, const struct FLinearColor& EndColor, FEngine_Engine_EVertexPaintAxis Axis, bool bConvertToSRGB)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis");

	UEngine_MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis_Params params;
	params.StaticMeshComponent = StaticMeshComponent;
	params.StartColor = StartColor;
	params.EndColor = EndColor;
	params.Axis = Axis;
	params.bConvertToSRGB = bConvertToSRGB;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ParticleSystem.ContainsEmitterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                  TypeData                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ParticleSystem::ContainsEmitterType(class UClass* TypeData)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystem.ContainsEmitterType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystem.ContainsEmitterType");

	UEngine_ParticleSystem_ContainsEmitterType_Params params;
	params.TypeData = TypeData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InStrengthMultiplyer           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicalAnimationComponent::SetStrengthMultiplyer(float InStrengthMultiplyer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer");

	UEngine_PhysicalAnimationComponent_SetStrengthMultiplyer_Params params;
	params.InStrengthMultiplyer = InStrengthMultiplyer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SkeletalMeshComponent* InSkeletalMeshComponent        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_PhysicalAnimationComponent::SetSkeletalMeshComponent(class UEngine_SkeletalMeshComponent* InSkeletalMeshComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent");

	UEngine_PhysicalAnimationComponent_SetSkeletalMeshComponent_Params params;
	params.InSkeletalMeshComponent = InSkeletalMeshComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicalAnimationComponent.GetBodyTargetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   BodyName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_PhysicalAnimationComponent::GetBodyTargetTransform(const struct FName& BodyName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.GetBodyTargetTransform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.GetBodyTargetTransform");

	UEngine_PhysicalAnimationComponent_GetBodyTargetTransform_Params params;
	params.BodyName = BodyName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   BodyName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_PhysicalAnimationData PhysicalAnimationData          (ConstParm, Parm, OutParm, ReferenceParm)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicalAnimationComponent::ApplyPhysicalAnimationSettingsBelow(const struct FName& BodyName, const struct FEngine_PhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow");

	UEngine_PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow_Params params;
	params.BodyName = BodyName;
	params.PhysicalAnimationData = PhysicalAnimationData;
	params.bIncludeSelf = bIncludeSelf;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FName                   BodyName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FEngine_PhysicalAnimationData PhysicalAnimationData          (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_PhysicalAnimationComponent::ApplyPhysicalAnimationSettings(const struct FName& BodyName, const struct FEngine_PhysicalAnimationData& PhysicalAnimationData)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings");

	UEngine_PhysicalAnimationComponent_ApplyPhysicalAnimationSettings_Params params;
	params.BodyName = BodyName;
	params.PhysicalAnimationData = PhysicalAnimationData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BodyName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ProfileName                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bIncludeSelf                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bClearNotFound                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicalAnimationComponent::ApplyPhysicalAnimationProfileBelow(const struct FName& BodyName, const struct FName& ProfileName, bool bIncludeSelf, bool bClearNotFound)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow");

	UEngine_PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow_Params params;
	params.BodyName = BodyName;
	params.ProfileName = ProfileName;
	params.bIncludeSelf = bIncludeSelf;
	params.bClearNotFound = bClearNotFound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetOrientationDriveTwistAndSwing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableTwistDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableSwingDrive              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetOrientationDriveTwistAndSwing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetOrientationDriveTwistAndSwing");

	UEngine_PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing_Params params;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.bEnableSwingDrive = bEnableSwingDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetOrientationDriveSLERP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableSLERP                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetOrientationDriveSLERP(bool bEnableSLERP)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetOrientationDriveSLERP");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetOrientationDriveSLERP");

	UEngine_PhysicsConstraintComponent_SetOrientationDriveSLERP_Params params;
	params.bEnableSLERP = bEnableSLERP;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearZLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ELinearConstraintMotion> ConstraintType                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          LimitSize                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearZLimit(TEnumAsByte<FEngine_Engine_ELinearConstraintMotion> ConstraintType, float LimitSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearZLimit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearZLimit");

	UEngine_PhysicsConstraintComponent_SetLinearZLimit_Params params;
	params.ConstraintType = ConstraintType;
	params.LimitSize = LimitSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearYLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ELinearConstraintMotion> ConstraintType                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          LimitSize                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearYLimit(TEnumAsByte<FEngine_Engine_ELinearConstraintMotion> ConstraintType, float LimitSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearYLimit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearYLimit");

	UEngine_PhysicsConstraintComponent_SetLinearYLimit_Params params;
	params.ConstraintType = ConstraintType;
	params.LimitSize = LimitSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearXLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ELinearConstraintMotion> ConstraintType                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          LimitSize                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearXLimit(TEnumAsByte<FEngine_Engine_ELinearConstraintMotion> ConstraintType, float LimitSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearXLimit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearXLimit");

	UEngine_PhysicsConstraintComponent_SetLinearXLimit_Params params;
	params.ConstraintType = ConstraintType;
	params.LimitSize = LimitSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InVelTarget                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearVelocityTarget(const struct FVector& InVelTarget)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget");

	UEngine_PhysicsConstraintComponent_SetLinearVelocityTarget_Params params;
	params.InVelTarget = InVelTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableDriveX                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableDriveY                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableDriveZ                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive");

	UEngine_PhysicsConstraintComponent_SetLinearVelocityDrive_Params params;
	params.bEnableDriveX = bEnableDriveX;
	params.bEnableDriveY = bEnableDriveY;
	params.bEnableDriveZ = bEnableDriveZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InPosTarget                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearPositionTarget(const struct FVector& InPosTarget)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget");

	UEngine_PhysicsConstraintComponent_SetLinearPositionTarget_Params params;
	params.InPosTarget = InPosTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableDriveX                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableDriveY                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableDriveZ                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive");

	UEngine_PhysicsConstraintComponent_SetLinearPositionDrive_Params params;
	params.bEnableDriveX = bEnableDriveX;
	params.bEnableDriveY = bEnableDriveY;
	params.bEnableDriveZ = bEnableDriveZ;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          PositionStrength               (Parm, ZeroConstructor, IsPlainOldData)
// float                          VelocityStrength               (Parm, ZeroConstructor, IsPlainOldData)
// float                          InForceLimit                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearDriveParams");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearDriveParams");

	UEngine_PhysicsConstraintComponent_SetLinearDriveParams_Params params;
	params.PositionStrength = PositionStrength;
	params.VelocityStrength = VelocityStrength;
	params.InForceLimit = InForceLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetLinearBreakable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bLinearBreakable               (Parm, ZeroConstructor, IsPlainOldData)
// float                          LinearBreakThreshold           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearBreakable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearBreakable");

	UEngine_PhysicsConstraintComponent_SetLinearBreakable_Params params;
	params.bLinearBreakable = bLinearBreakable;
	params.LinearBreakThreshold = LinearBreakThreshold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetDisableCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bDisableCollision              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetDisableCollision(bool bDisableCollision)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetDisableCollision");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetDisableCollision");

	UEngine_PhysicsConstraintComponent_SetDisableCollision_Params params;
	params.bDisableCollision = bDisableCollision;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EConstraintFrame> Frame                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 RefPosition                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetConstraintReferencePosition(TEnumAsByte<FEngine_Engine_EConstraintFrame> Frame, const struct FVector& RefPosition)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition");

	UEngine_PhysicsConstraintComponent_SetConstraintReferencePosition_Params params;
	params.Frame = Frame;
	params.RefPosition = RefPosition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EConstraintFrame> Frame                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 PriAxis                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FVector                 SecAxis                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetConstraintReferenceOrientation(TEnumAsByte<FEngine_Engine_EConstraintFrame> Frame, const struct FVector& PriAxis, const struct FVector& SecAxis)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation");

	UEngine_PhysicsConstraintComponent_SetConstraintReferenceOrientation_Params params;
	params.Frame = Frame;
	params.PriAxis = PriAxis;
	params.SecAxis = SecAxis;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EConstraintFrame> Frame                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              RefFrame                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetConstraintReferenceFrame(TEnumAsByte<FEngine_Engine_EConstraintFrame> Frame, const struct FTransform& RefFrame)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame");

	UEngine_PhysicsConstraintComponent_SetConstraintReferenceFrame_Params params;
	params.Frame = Frame;
	params.RefFrame = RefFrame;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetConstrainedComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* Component1                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   BoneName1                      (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_PrimitiveComponent* Component2                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   BoneName2                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetConstrainedComponents(class UEngine_PrimitiveComponent* Component1, const struct FName& BoneName1, class UEngine_PrimitiveComponent* Component2, const struct FName& BoneName2)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstrainedComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstrainedComponents");

	UEngine_PhysicsConstraintComponent_SetConstrainedComponents_Params params;
	params.Component1 = Component1;
	params.BoneName1 = BoneName1;
	params.Component2 = Component2;
	params.BoneName2 = BoneName2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InVelTarget                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularVelocityTarget(const struct FVector& InVelTarget)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget");

	UEngine_PhysicsConstraintComponent_SetAngularVelocityTarget_Params params;
	params.InVelTarget = InVelTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveTwistAndSwing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableTwistDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableSwingDrive              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveTwistAndSwing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveTwistAndSwing");

	UEngine_PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing_Params params;
	params.bEnableTwistDrive = bEnableTwistDrive;
	params.bEnableSwingDrive = bEnableSwingDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveSLERP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableSLERP                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularVelocityDriveSLERP(bool bEnableSLERP)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveSLERP");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveSLERP");

	UEngine_PhysicsConstraintComponent_SetAngularVelocityDriveSLERP_Params params;
	params.bEnableSLERP = bEnableSLERP;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableSwingDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableTwistDrive              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive");

	UEngine_PhysicsConstraintComponent_SetAngularVelocityDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EAngularConstraintMotion> ConstraintType                 (Parm, ZeroConstructor, IsPlainOldData)
// float                          TwistLimitAngle                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularTwistLimit(TEnumAsByte<FEngine_Engine_EAngularConstraintMotion> ConstraintType, float TwistLimitAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit");

	UEngine_PhysicsConstraintComponent_SetAngularTwistLimit_Params params;
	params.ConstraintType = ConstraintType;
	params.TwistLimitAngle = TwistLimitAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EAngularConstraintMotion> MotionType                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Swing2LimitAngle               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularSwing2Limit(TEnumAsByte<FEngine_Engine_EAngularConstraintMotion> MotionType, float Swing2LimitAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit");

	UEngine_PhysicsConstraintComponent_SetAngularSwing2Limit_Params params;
	params.MotionType = MotionType;
	params.Swing2LimitAngle = Swing2LimitAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EAngularConstraintMotion> MotionType                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Swing1LimitAngle               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularSwing1Limit(TEnumAsByte<FEngine_Engine_EAngularConstraintMotion> MotionType, float Swing1LimitAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit");

	UEngine_PhysicsConstraintComponent_SetAngularSwing1Limit_Params params;
	params.MotionType = MotionType;
	params.Swing1LimitAngle = Swing1LimitAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                InPosTarget                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularOrientationTarget(const struct FRotator& InPosTarget)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget");

	UEngine_PhysicsConstraintComponent_SetAngularOrientationTarget_Params params;
	params.InPosTarget = InPosTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnableSwingDrive              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bEnableTwistDrive              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive");

	UEngine_PhysicsConstraintComponent_SetAngularOrientationDrive_Params params;
	params.bEnableSwingDrive = bEnableSwingDrive;
	params.bEnableTwistDrive = bEnableTwistDrive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularDriveParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          PositionStrength               (Parm, ZeroConstructor, IsPlainOldData)
// float                          VelocityStrength               (Parm, ZeroConstructor, IsPlainOldData)
// float                          InForceLimit                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveParams");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveParams");

	UEngine_PhysicsConstraintComponent_SetAngularDriveParams_Params params;
	params.PositionStrength = PositionStrength;
	params.VelocityStrength = VelocityStrength;
	params.InForceLimit = InForceLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularDriveMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EAngularDriveMode> DriveMode                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularDriveMode(TEnumAsByte<FEngine_Engine_EAngularDriveMode> DriveMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveMode");

	UEngine_PhysicsConstraintComponent_SetAngularDriveMode_Params params;
	params.DriveMode = DriveMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.SetAngularBreakable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bAngularBreakable              (Parm, ZeroConstructor, IsPlainOldData)
// float                          AngularBreakThreshold          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularBreakable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularBreakable");

	UEngine_PhysicsConstraintComponent_SetAngularBreakable_Params params;
	params.bAngularBreakable = bAngularBreakable;
	params.AngularBreakThreshold = AngularBreakThreshold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsConstraintComponent.IsBroken
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PhysicsConstraintComponent::IsBroken()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.IsBroken");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.IsBroken");

	UEngine_PhysicsConstraintComponent_IsBroken_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.GetCurrentTwist
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PhysicsConstraintComponent::GetCurrentTwist()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentTwist");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentTwist");

	UEngine_PhysicsConstraintComponent_GetCurrentTwist_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.GetCurrentSwing2
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PhysicsConstraintComponent::GetCurrentSwing2()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing2");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing2");

	UEngine_PhysicsConstraintComponent_GetCurrentSwing2_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.GetCurrentSwing1
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PhysicsConstraintComponent::GetCurrentSwing1()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing1");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetCurrentSwing1");

	UEngine_PhysicsConstraintComponent_GetCurrentSwing1_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsConstraintComponent.GetConstraintForce
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 OutLinearForce                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FVector                 OutAngularForce                (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsConstraintComponent::GetConstraintForce(struct FVector* OutLinearForce, struct FVector* OutAngularForce)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetConstraintForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetConstraintForce");

	UEngine_PhysicsConstraintComponent_GetConstraintForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutLinearForce != nullptr)
		*OutLinearForce = params.OutLinearForce;
	if (OutAngularForce != nullptr)
		*OutAngularForce = params.OutAngularForce;
}


// Function Engine.PhysicsConstraintComponent.BreakConstraint
// (Final, Native, Public, BlueprintCallable)

void UEngine_PhysicsConstraintComponent::BreakConstraint()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.BreakConstraint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.BreakConstraint");

	UEngine_PhysicsConstraintComponent_BreakConstraint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PawnNoiseEmitterComponent.MakeNoise
// (BlueprintAuthorityOnly, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           NoiseMaker                     (Parm, ZeroConstructor, IsPlainOldData)
// float                          Loudness                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 NoiseLocation                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_PawnNoiseEmitterComponent::MakeNoise(class AEngine_Actor* NoiseMaker, float Loudness, const struct FVector& NoiseLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PawnNoiseEmitterComponent.MakeNoise");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PawnNoiseEmitterComponent.MakeNoise");

	UEngine_PawnNoiseEmitterComponent_MakeNoise_Params params;
	params.NoiseMaker = NoiseMaker;
	params.Loudness = Loudness;
	params.NoiseLocation = NoiseLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetTargetRotation(const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetRotation");

	UEngine_PhysicsHandleComponent_SetTargetRotation_Params params;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                NewRotation                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetTargetLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation");

	UEngine_PhysicsHandleComponent_SetTargetLocationAndRotation_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetTargetLocation(const struct FVector& NewLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocation");

	UEngine_PhysicsHandleComponent_SetTargetLocation_Params params;
	params.NewLocation = NewLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetLinearStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLinearStiffness             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetLinearStiffness(float NewLinearStiffness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearStiffness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearStiffness");

	UEngine_PhysicsHandleComponent_SetLinearStiffness_Params params;
	params.NewLinearStiffness = NewLinearStiffness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetLinearDamping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLinearDamping               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetLinearDamping(float NewLinearDamping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearDamping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetLinearDamping");

	UEngine_PhysicsHandleComponent_SetLinearDamping_Params params;
	params.NewLinearDamping = NewLinearDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetInterpolationSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewInterpolationSpeed          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetInterpolationSpeed(float NewInterpolationSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetInterpolationSpeed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetInterpolationSpeed");

	UEngine_PhysicsHandleComponent_SetInterpolationSpeed_Params params;
	params.NewInterpolationSpeed = NewInterpolationSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetAngularStiffness
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewAngularStiffness            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetAngularStiffness(float NewAngularStiffness)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularStiffness");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularStiffness");

	UEngine_PhysicsHandleComponent_SetAngularStiffness_Params params;
	params.NewAngularStiffness = NewAngularStiffness;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.SetAngularDamping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewAngularDamping              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::SetAngularDamping(float NewAngularDamping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularDamping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetAngularDamping");

	UEngine_PhysicsHandleComponent_SetAngularDamping_Params params;
	params.NewAngularDamping = NewAngularDamping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.ReleaseComponent
// (Native, Public, BlueprintCallable)

void UEngine_PhysicsHandleComponent::ReleaseComponent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.ReleaseComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.ReleaseComponent");

	UEngine_PhysicsHandleComponent_ReleaseComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   InBoneName                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                Rotation                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::GrabComponentAtLocationWithRotation(class UEngine_PrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& Location, const struct FRotator& Rotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation");

	UEngine_PhysicsHandleComponent_GrabComponentAtLocationWithRotation_Params params;
	params.Component = Component;
	params.InBoneName = InBoneName;
	params.Location = Location;
	params.Rotation = Rotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.GrabComponentAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   InBoneName                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 GrabLocation                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::GrabComponentAtLocation(class UEngine_PrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& GrabLocation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponentAtLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponentAtLocation");

	UEngine_PhysicsHandleComponent_GrabComponentAtLocation_Params params;
	params.Component = Component;
	params.InBoneName = InBoneName;
	params.GrabLocation = GrabLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.GrabComponent
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FName                   InBoneName                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 GrabLocation                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bConstrainRotation             (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::GrabComponent(class UEngine_PrimitiveComponent* Component, const struct FName& InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponent");

	UEngine_PhysicsHandleComponent_GrabComponent_Params params;
	params.Component = Component;
	params.InBoneName = InBoneName;
	params.GrabLocation = GrabLocation;
	params.bConstrainRotation = bConstrainRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 TargetLocation                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// struct FRotator                TargetRotation                 (Parm, OutParm, ZeroConstructor, IsPlainOldData)

void UEngine_PhysicsHandleComponent::GetTargetLocationAndRotation(struct FVector* TargetLocation, struct FRotator* TargetRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation");

	UEngine_PhysicsHandleComponent_GetTargetLocationAndRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (TargetLocation != nullptr)
		*TargetLocation = params.TargetLocation;
	if (TargetRotation != nullptr)
		*TargetRotation = params.TargetRotation;
}


// Function Engine.PhysicsHandleComponent.GetGrabbedComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_PrimitiveComponent* ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_PrimitiveComponent* UEngine_PhysicsHandleComponent::GetGrabbedComponent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetGrabbedComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetGrabbedComponent");

	UEngine_PhysicsHandleComponent_GetGrabbedComponent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetSpringRestingPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PhysicsSpringComponent::GetSpringRestingPoint()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringRestingPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringRestingPoint");

	UEngine_PhysicsSpringComponent_GetSpringRestingPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetSpringDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PhysicsSpringComponent::GetSpringDirection()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringDirection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringDirection");

	UEngine_PhysicsSpringComponent_GetSpringDirection_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PhysicsSpringComponent::GetSpringCurrentEndPoint()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint");

	UEngine_PhysicsSpringComponent_GetSpringCurrentEndPoint_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_PhysicsSpringComponent::GetNormalizedCompressionScalar()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar");

	UEngine_PhysicsSpringComponent_GetNormalizedCompressionScalar_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlanarReflection.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlanarReflection::OnInterpToggle(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlanarReflection.OnInterpToggle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlanarReflection.OnInterpToggle");

	AEngine_PlanarReflection_OnInterpToggle_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.ShowOnlyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* InComponent                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_SceneCaptureComponent::ShowOnlyComponent(class UEngine_PrimitiveComponent* InComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ShowOnlyComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ShowOnlyComponent");

	UEngine_SceneCaptureComponent_ShowOnlyComponent_Params params;
	params.InComponent = InComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.ShowOnlyActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           InActor                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneCaptureComponent::ShowOnlyActorComponents(class AEngine_Actor* InActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ShowOnlyActorComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ShowOnlyActorComponents");

	UEngine_SceneCaptureComponent_ShowOnlyActorComponents_Params params;
	params.InActor = InActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.SetCaptureSortPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            NewCaptureSortPriority         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneCaptureComponent::SetCaptureSortPriority(int NewCaptureSortPriority)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.SetCaptureSortPriority");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.SetCaptureSortPriority");

	UEngine_SceneCaptureComponent_SetCaptureSortPriority_Params params;
	params.NewCaptureSortPriority = NewCaptureSortPriority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.RemoveShowOnlyComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* InComponent                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_SceneCaptureComponent::RemoveShowOnlyComponent(class UEngine_PrimitiveComponent* InComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.RemoveShowOnlyComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.RemoveShowOnlyComponent");

	UEngine_SceneCaptureComponent_RemoveShowOnlyComponent_Params params;
	params.InComponent = InComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.RemoveShowOnlyActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           InActor                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneCaptureComponent::RemoveShowOnlyActorComponents(class AEngine_Actor* InActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.RemoveShowOnlyActorComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.RemoveShowOnlyActorComponents");

	UEngine_SceneCaptureComponent_RemoveShowOnlyActorComponents_Params params;
	params.InActor = InActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.HideComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_PrimitiveComponent* InComponent                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_SceneCaptureComponent::HideComponent(class UEngine_PrimitiveComponent* InComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideComponent");

	UEngine_SceneCaptureComponent_HideComponent_Params params;
	params.InComponent = InComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.HideActorComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_Actor*           InActor                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneCaptureComponent::HideActorComponents(class AEngine_Actor* InActor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideActorComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideActorComponents");

	UEngine_SceneCaptureComponent_HideActorComponents_Params params;
	params.InActor = InActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.ClearShowOnlyComponents
// (Final, Native, Public, BlueprintCallable)

void UEngine_SceneCaptureComponent::ClearShowOnlyComponents()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ClearShowOnlyComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ClearShowOnlyComponents");

	UEngine_SceneCaptureComponent_ClearShowOnlyComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent.ClearHiddenComponents
// (Final, Native, Public, BlueprintCallable)

void UEngine_SceneCaptureComponent::ClearHiddenComponents()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ClearHiddenComponents");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.ClearHiddenComponents");

	UEngine_SceneCaptureComponent_ClearHiddenComponents_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PlatformEventsComponent::SupportsConvertibleLaptops()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops");

	UEngine_PlatformEventsComponent_SupportsConvertibleLaptops_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UEngine_PlatformEventsComponent::PlatformEventDelegate__DelegateSignature()
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.PlatformEventsComponent.PlatformEventDelegate__DelegateSignature");

	UEngine_PlatformEventsComponent_PlatformEventDelegate__DelegateSignature_Params params;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlatformEventsComponent.IsInTabletMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PlatformEventsComponent::IsInTabletMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInTabletMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInTabletMode");

	UEngine_PlatformEventsComponent_IsInTabletMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformEventsComponent.IsInLaptopMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_PlatformEventsComponent::IsInLaptopMode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInLaptopMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlatformEventsComponent.IsInLaptopMode");

	UEngine_PlatformEventsComponent_IsInLaptopMode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
// (Native, Public)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_PlatformInterfaceWebResponse::GetNumHeaders()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetNumHeaders");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetNumHeaders");

	UEngine_PlatformInterfaceWebResponse_GetNumHeaders_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
// (Native, Public)
// Parameters:
// struct FString                 HeaderName                     (Parm, ZeroConstructor)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_PlatformInterfaceWebResponse::GetHeaderValue(const struct FString& HeaderName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeaderValue");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeaderValue");

	UEngine_PlatformInterfaceWebResponse_GetHeaderValue_Params params;
	params.HeaderName = HeaderName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PlatformInterfaceWebResponse.GetHeader
// (Native, Public, HasOutParms)
// Parameters:
// int                            HeaderIndex                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Header                         (Parm, OutParm, ZeroConstructor)
// struct FString                 Value                          (Parm, OutParm, ZeroConstructor)

void UEngine_PlatformInterfaceWebResponse::GetHeader(int HeaderIndex, struct FString* Header, struct FString* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeader");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeader");

	UEngine_PlatformInterfaceWebResponse_GetHeader_Params params;
	params.HeaderIndex = HeaderIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (Header != nullptr)
		*Header = params.Header;
	if (Value != nullptr)
		*Value = params.Value;
}


// Function Engine.PlayerInput.SetMouseSensitivity
// (Final, Exec, Native, Public)
// Parameters:
// float                          Sensitivity                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PlayerInput::SetMouseSensitivity(float Sensitivity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetMouseSensitivity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetMouseSensitivity");

	UEngine_PlayerInput_SetMouseSensitivity_Params params;
	params.Sensitivity = Sensitivity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.SetBind
// (Final, Exec, Native, Public)
// Parameters:
// struct FName                   BindName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Command                        (Parm, ZeroConstructor)

void UEngine_PlayerInput::SetBind(const struct FName& BindName, const struct FString& Command)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetBind");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetBind");

	UEngine_PlayerInput_SetBind_Params params;
	params.BindName = BindName;
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.InvertAxisKey
// (Final, Exec, Native, Public)
// Parameters:
// struct FInputCore_Key          AxisKey                        (ConstParm, Parm)

void UEngine_PlayerInput::InvertAxisKey(const struct FInputCore_Key& AxisKey)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxisKey");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxisKey");

	UEngine_PlayerInput_InvertAxisKey_Params params;
	params.AxisKey = AxisKey;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.InvertAxis
// (Final, Exec, Native, Public)
// Parameters:
// struct FName                   AxisName                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PlayerInput::InvertAxis(const struct FName& AxisName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxis");

	UEngine_PlayerInput_InvertAxis_Params params;
	params.AxisName = AxisName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerInput.ClearSmoothing
// (Final, Exec, Native, Public)

void UEngine_PlayerInput::ClearSmoothing()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.ClearSmoothing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.ClearSmoothing");

	UEngine_PlayerInput_ClearSmoothing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLight.SetRadius
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewRadius                      (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PointLight::SetRadius(float NewRadius)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetRadius");

	AEngine_PointLight_SetRadius_Params params;
	params.NewRadius = NewRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLight.SetLightFalloffExponent
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLightFalloffExponent        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PointLight::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetLightFalloffExponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetLightFalloffExponent");

	AEngine_PointLight_SetLightFalloffExponent_Params params;
	params.NewLightFalloffExponent = NewLightFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightComponent.SetSourceRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PointLightComponent::SetSourceRadius(float bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceRadius");

	UEngine_PointLightComponent_SetSourceRadius_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightComponent.SetSourceLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PointLightComponent::SetSourceLength(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceLength");

	UEngine_PointLightComponent_SetSourceLength_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightComponent.SetSoftSourceRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PointLightComponent::SetSoftSourceRadius(float bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSoftSourceRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSoftSourceRadius");

	UEngine_PointLightComponent_SetSoftSourceRadius_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PointLightComponent.SetLightFalloffExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLightFalloffExponent        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PointLightComponent::SetLightFalloffExponent(float NewLightFalloffExponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetLightFalloffExponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetLightFalloffExponent");

	UEngine_PointLightComponent_SetLightFalloffExponent_Params params;
	params.NewLightFalloffExponent = NewLightFalloffExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PoseableMeshComponent.SetBoneTransformByName
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              InTransform                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PoseableMeshComponent::SetBoneTransformByName(const struct FName& BoneName, const struct FTransform& InTransform, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneTransformByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneTransformByName");

	UEngine_PoseableMeshComponent_SetBoneTransformByName_Params params;
	params.BoneName = BoneName;
	params.InTransform = InTransform;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PoseableMeshComponent.SetBoneScaleByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InScale3D                      (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PoseableMeshComponent::SetBoneScaleByName(const struct FName& BoneName, const struct FVector& InScale3D, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneScaleByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneScaleByName");

	UEngine_PoseableMeshComponent_SetBoneScaleByName_Params params;
	params.BoneName = BoneName;
	params.InScale3D = InScale3D;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PoseableMeshComponent.SetBoneRotationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                InRotation                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PoseableMeshComponent::SetBoneRotationByName(const struct FName& BoneName, const struct FRotator& InRotation, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneRotationByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneRotationByName");

	UEngine_PoseableMeshComponent_SetBoneRotationByName_Params params;
	params.BoneName = BoneName;
	params.InRotation = InRotation;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PoseableMeshComponent.SetBoneLocationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 InLocation                     (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PoseableMeshComponent::SetBoneLocationByName(const struct FName& BoneName, const struct FVector& InLocation, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneLocationByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneLocationByName");

	UEngine_PoseableMeshComponent_SetBoneLocationByName_Params params;
	params.BoneName = BoneName;
	params.InLocation = InLocation;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PoseableMeshComponent.ResetBoneTransformByName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PoseableMeshComponent::ResetBoneTransformByName(const struct FName& BoneName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.ResetBoneTransformByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.ResetBoneTransformByName");

	UEngine_PoseableMeshComponent_ResetBoneTransformByName_Params params;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PoseableMeshComponent.GetBoneTransformByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              ReturnValue                    (Parm, OutParm, ReturnParm, IsPlainOldData)

struct FTransform UEngine_PoseableMeshComponent::GetBoneTransformByName(const struct FName& BoneName, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneTransformByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneTransformByName");

	UEngine_PoseableMeshComponent_GetBoneTransformByName_Params params;
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PoseableMeshComponent.GetBoneScaleByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PoseableMeshComponent::GetBoneScaleByName(const struct FName& BoneName, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneScaleByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneScaleByName");

	UEngine_PoseableMeshComponent_GetBoneScaleByName_Params params;
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PoseableMeshComponent.GetBoneRotationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_PoseableMeshComponent::GetBoneRotationByName(const struct FName& BoneName, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneRotationByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneRotationByName");

	UEngine_PoseableMeshComponent_GetBoneRotationByName_Params params;
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PoseableMeshComponent.GetBoneLocationByName
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FName                   BoneName                       (Parm, ZeroConstructor, IsPlainOldData)
// TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace                      (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_PoseableMeshComponent::GetBoneLocationByName(const struct FName& BoneName, TEnumAsByte<FEngine_Engine_EBoneSpaces> BoneSpace)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneLocationByName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneLocationByName");

	UEngine_PoseableMeshComponent_GetBoneLocationByName_Params params;
	params.BoneName = BoneName;
	params.BoneSpace = BoneSpace;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SkeletalMeshComponent* InComponentToCopy              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_PoseableMeshComponent::CopyPoseFromSkeletalComponent(class UEngine_SkeletalMeshComponent* InComponentToCopy)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent");

	UEngine_PoseableMeshComponent_CopyPoseFromSkeletalComponent_Params params;
	params.InComponentToCopy = InComponentToCopy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PostProcessComponent.AddOrUpdateBlendable
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class UEngine_BlendableInterface> InBlendableObject              (Parm, ZeroConstructor, IsPlainOldData)
// float                          InWeight                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_PostProcessComponent::AddOrUpdateBlendable(const TScriptInterface<class UEngine_BlendableInterface>& InBlendableObject, float InWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PostProcessComponent.AddOrUpdateBlendable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PostProcessComponent.AddOrUpdateBlendable");

	UEngine_PostProcessComponent_AddOrUpdateBlendable_Params params;
	params.InBlendableObject = InBlendableObject;
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PostProcessVolume.AddOrUpdateBlendable
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class UEngine_BlendableInterface> InBlendableObject              (Parm, ZeroConstructor, IsPlainOldData)
// float                          InWeight                       (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PostProcessVolume::AddOrUpdateBlendable(const TScriptInterface<class UEngine_BlendableInterface>& InBlendableObject, float InWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PostProcessVolume.AddOrUpdateBlendable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PostProcessVolume.AddOrUpdateBlendable");

	AEngine_PostProcessVolume_AddOrUpdateBlendable_Params params;
	params.InBlendableObject = InBlendableObject;
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProjectileMovementComponent.StopSimulating
// (Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FEngine_HitResult       HitResult                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_ProjectileMovementComponent::StopSimulating(const struct FEngine_HitResult& HitResult)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.StopSimulating");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.StopSimulating");

	UEngine_ProjectileMovementComponent_StopSimulating_Params params;
	params.HitResult = HitResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewVelocity                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_ProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace");

	UEngine_ProjectileMovementComponent_SetVelocityInLocalSpace_Params params;
	params.NewVelocity = NewVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProjectileMovementComponent.SetInterpolatedComponent
// (Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SceneComponent*  Component                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_ProjectileMovementComponent::SetInterpolatedComponent(class UEngine_SceneComponent* Component)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetInterpolatedComponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetInterpolatedComponent");

	UEngine_ProjectileMovementComponent_SetInterpolatedComponent_Params params;
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProjectileMovementComponent.ResetInterpolation
// (Native, Public, BlueprintCallable)

void UEngine_ProjectileMovementComponent::ResetInterpolation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.ResetInterpolation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.ResetInterpolation");

	UEngine_ProjectileMovementComponent_ResetInterpolation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParms)
// Parameters:
// struct FEngine_HitResult       ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)

void UEngine_ProjectileMovementComponent::OnProjectileStopDelegate__DelegateSignature(const struct FEngine_HitResult& ImpactResult)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature");

	UEngine_ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature_Params params;
	params.ImpactResult = ImpactResult;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
// Parameters:
// struct FEngine_HitResult       ImpactResult                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData)
// struct FVector                 ImpactVelocity                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_ProjectileMovementComponent::OnProjectileBounceDelegate__DelegateSignature(const struct FEngine_HitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature");

	if (!fn)
		fn = UObject::FindObject<UFunction>("DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature");

	UEngine_ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature_Params params;
	params.ImpactResult = ImpactResult;
	params.ImpactVelocity = ImpactVelocity;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProjectileMovementComponent.MoveInterpolationTarget
// (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 NewLocation                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// struct FRotator                NewRotation                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_ProjectileMovementComponent::MoveInterpolationTarget(const struct FVector& NewLocation, const struct FRotator& NewRotation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.MoveInterpolationTarget");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.MoveInterpolationTarget");

	UEngine_ProjectileMovementComponent_MoveInterpolationTarget_Params params;
	params.NewLocation = NewLocation;
	params.NewRotation = NewRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.ProjectileMovementComponent.LimitVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 NewVelocity                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_ProjectileMovementComponent::LimitVelocity(const struct FVector& NewVelocity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.LimitVelocity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.LimitVelocity");

	UEngine_ProjectileMovementComponent_LimitVelocity_Params params;
	params.NewVelocity = NewVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ProjectileMovementComponent.IsVelocityUnderSimulationThreshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ProjectileMovementComponent::IsVelocityUnderSimulationThreshold()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.IsVelocityUnderSimulationThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.IsVelocityUnderSimulationThreshold");

	UEngine_ProjectileMovementComponent_IsVelocityUnderSimulationThreshold_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.ProjectileMovementComponent.IsInterpolationComplete
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_ProjectileMovementComponent::IsInterpolationComplete()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.IsInterpolationComplete");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.IsInterpolationComplete");

	UEngine_ProjectileMovementComponent_IsInterpolationComplete_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.RadialForceActor.ToggleForce
// (Native, Public, BlueprintCallable)

void AEngine_RadialForceActor::ToggleForce()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.ToggleForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.ToggleForce");

	AEngine_RadialForceActor_ToggleForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialForceActor.FireImpulse
// (Native, Public, BlueprintCallable)

void AEngine_RadialForceActor::FireImpulse()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.FireImpulse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.FireImpulse");

	AEngine_RadialForceActor_FireImpulse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialForceActor.EnableForce
// (Native, Public, BlueprintCallable)

void AEngine_RadialForceActor::EnableForce()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.EnableForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.EnableForce");

	AEngine_RadialForceActor_EnableForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialForceActor.DisableForce
// (Native, Public, BlueprintCallable)

void AEngine_RadialForceActor::DisableForce()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.DisableForce");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.DisableForce");

	AEngine_RadialForceActor_DisableForce_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialForceComponent.RemoveObjectTypeToAffect
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EObjectTypeQuery> ObjectType                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_RadialForceComponent::RemoveObjectTypeToAffect(TEnumAsByte<FEngine_Engine_EObjectTypeQuery> ObjectType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.RemoveObjectTypeToAffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.RemoveObjectTypeToAffect");

	UEngine_RadialForceComponent_RemoveObjectTypeToAffect_Params params;
	params.ObjectType = ObjectType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialForceComponent.FireImpulse
// (Native, Public, BlueprintCallable)

void UEngine_RadialForceComponent::FireImpulse()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.FireImpulse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.FireImpulse");

	UEngine_RadialForceComponent_FireImpulse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RadialForceComponent.AddObjectTypeToAffect
// (Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EObjectTypeQuery> ObjectType                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_RadialForceComponent::AddObjectTypeToAffect(TEnumAsByte<FEngine_Engine_EObjectTypeQuery> ObjectType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.AddObjectTypeToAffect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.AddObjectTypeToAffect");

	UEngine_RadialForceComponent_AddObjectTypeToAffect_Params params;
	params.ObjectType = ObjectType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RectLightComponent.SetSourceWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_RectLightComponent::SetSourceWidth(float bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceWidth");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceWidth");

	UEngine_RectLightComponent_SetSourceWidth_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RectLightComponent.SetSourceTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         bNewValue                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_RectLightComponent::SetSourceTexture(class UEngine_Texture* bNewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceTexture");

	UEngine_RectLightComponent_SetSourceTexture_Params params;
	params.bNewValue = bNewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RectLightComponent.SetSourceHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_RectLightComponent::SetSourceHeight(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceHeight");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetSourceHeight");

	UEngine_RectLightComponent_SetSourceHeight_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RectLightComponent.SetBarnDoorLength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_RectLightComponent::SetBarnDoorLength(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetBarnDoorLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetBarnDoorLength");

	UEngine_RectLightComponent_SetBarnDoorLength_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.RectLightComponent.SetBarnDoorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_RectLightComponent::SetBarnDoorAngle(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetBarnDoorAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.RectLightComponent.SetBarnDoorAngle");

	UEngine_RectLightComponent_SetBarnDoorAngle_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.ReceiveOverrideWith
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AEngine_PlayerState*     OldPlayerState                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerState::ReceiveOverrideWith(class AEngine_PlayerState* OldPlayerState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.ReceiveOverrideWith");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.ReceiveOverrideWith");

	AEngine_PlayerState_ReceiveOverrideWith_Params params;
	params.OldPlayerState = OldPlayerState;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.ReceiveCopyProperties
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AEngine_PlayerState*     NewPlayerState                 (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_PlayerState::ReceiveCopyProperties(class AEngine_PlayerState* NewPlayerState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.ReceiveCopyProperties");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.ReceiveCopyProperties");

	AEngine_PlayerState_ReceiveCopyProperties_Params params;
	params.NewPlayerState = NewPlayerState;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.OnRep_UniqueId
// (Native, Public)

void AEngine_PlayerState::OnRep_UniqueId()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_UniqueId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_UniqueId");

	AEngine_PlayerState_OnRep_UniqueId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.OnRep_Score
// (Native, Public)

void AEngine_PlayerState::OnRep_Score()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_Score");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_Score");

	AEngine_PlayerState_OnRep_Score_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.OnRep_PlayerName
// (Native, Public)

void AEngine_PlayerState::OnRep_PlayerName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerName");

	AEngine_PlayerState_OnRep_PlayerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.OnRep_PlayerId
// (Native, Public)

void AEngine_PlayerState::OnRep_PlayerId()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerId");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerId");

	AEngine_PlayerState_OnRep_PlayerId_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.OnRep_bIsInactive
// (Native, Public)

void AEngine_PlayerState::OnRep_bIsInactive()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_bIsInactive");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_bIsInactive");

	AEngine_PlayerState_OnRep_bIsInactive_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.PlayerState.GetPlayerName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString AEngine_PlayerState::GetPlayerName()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.GetPlayerName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.GetPlayerName");

	AEngine_PlayerState_GetPlayerName_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SceneCapture2D.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_SceneCapture2D::OnInterpToggle(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCapture2D.OnInterpToggle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCapture2D.OnInterpToggle");

	AEngine_SceneCapture2D_OnInterpToggle_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent2D.CaptureScene
// (Final, Native, Public, BlueprintCallable)

void UEngine_SceneCaptureComponent2D::CaptureScene()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.CaptureScene");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.CaptureScene");

	UEngine_SceneCaptureComponent2D_CaptureScene_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class UEngine_BlendableInterface> InBlendableObject              (Parm, ZeroConstructor, IsPlainOldData)
// float                          InWeight                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SceneCaptureComponent2D::AddOrUpdateBlendable(const TScriptInterface<class UEngine_BlendableInterface>& InBlendableObject, float InWeight)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable");

	UEngine_SceneCaptureComponent2D_AddOrUpdateBlendable_Params params;
	params.InBlendableObject = InBlendableObject;
	params.InWeight = InWeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureComponentCube.CaptureScene
// (Final, Native, Public, BlueprintCallable)

void UEngine_SceneCaptureComponentCube::CaptureScene()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponentCube.CaptureScene");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponentCube.CaptureScene");

	UEngine_SceneCaptureComponentCube_CaptureScene_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SceneCaptureCube.OnInterpToggle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bEnable                        (Parm, ZeroConstructor, IsPlainOldData)

void AEngine_SceneCaptureCube::OnInterpToggle(bool bEnable)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureCube.OnInterpToggle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureCube.OnInterpToggle");

	AEngine_SceneCaptureCube_OnInterpToggle_Params params;
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMesh.SetLODSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_SkeletalMeshLODSettings* InLODSettings                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMesh::SetLODSettings(class UEngine_SkeletalMeshLODSettings* InLODSettings)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetLODSettings");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.SetLODSettings");

	UEngine_SkeletalMesh_SetLODSettings_Params params;
	params.InLODSettings = InLODSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMesh.NumSockets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_SkeletalMesh::NumSockets()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.NumSockets");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.NumSockets");

	UEngine_SkeletalMesh_NumSockets_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.K2_GetAllMorphTargetNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FString>         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

TArray<struct FString> UEngine_SkeletalMesh::K2_GetAllMorphTargetNames()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.K2_GetAllMorphTargetNames");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.K2_GetAllMorphTargetNames");

	UEngine_SkeletalMesh_K2_GetAllMorphTargetNames_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.IsSectionUsingCloth
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            InSectionIndex                 (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bCheckCorrespondingSections    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SkeletalMesh::IsSectionUsingCloth(int InSectionIndex, bool bCheckCorrespondingSections)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.IsSectionUsingCloth");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.IsSectionUsingCloth");

	UEngine_SkeletalMesh_IsSectionUsingCloth_Params params;
	params.InSectionIndex = InSectionIndex;
	params.bCheckCorrespondingSections = bCheckCorrespondingSections;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.GetSocketByIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            Index                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SkeletalMeshSocket* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_SkeletalMeshSocket* UEngine_SkeletalMesh::GetSocketByIndex(int Index)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetSocketByIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetSocketByIndex");

	UEngine_SkeletalMesh_GetSocketByIndex_Params params;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.GetNodeMappingContainer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_Blueprint*       SourceAsset                    (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_NodeMappingContainer* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_NodeMappingContainer* UEngine_SkeletalMesh::GetNodeMappingContainer(class UEngine_Blueprint* SourceAsset)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetNodeMappingContainer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetNodeMappingContainer");

	UEngine_SkeletalMesh_GetNodeMappingContainer_Params params;
	params.SourceAsset = SourceAsset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.GetImportedBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FBoxSphereBounds UEngine_SkeletalMesh::GetImportedBounds()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetImportedBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetImportedBounds");

	UEngine_SkeletalMesh_GetImportedBounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.GetBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FBoxSphereBounds UEngine_SkeletalMesh::GetBounds()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.GetBounds");

	UEngine_SkeletalMesh_GetBounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.FindSocketInfo
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FTransform              OutTransform                   (Parm, OutParm, IsPlainOldData)
// int                            OutBoneIndex                   (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// int                            OutIndex                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_SkeletalMeshSocket* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_SkeletalMeshSocket* UEngine_SkeletalMesh::FindSocketInfo(const struct FName& InSocketName, struct FTransform* OutTransform, int* OutBoneIndex, int* OutIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocketInfo");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocketInfo");

	UEngine_SkeletalMesh_FindSocketInfo_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutTransform != nullptr)
		*OutTransform = params.OutTransform;
	if (OutBoneIndex != nullptr)
		*OutBoneIndex = params.OutBoneIndex;
	if (OutIndex != nullptr)
		*OutIndex = params.OutIndex;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.FindSocketAndIndex
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// int                            OutIndex                       (Parm, OutParm, ZeroConstructor, IsPlainOldData)
// class UEngine_SkeletalMeshSocket* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_SkeletalMeshSocket* UEngine_SkeletalMesh::FindSocketAndIndex(const struct FName& InSocketName, int* OutIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocketAndIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocketAndIndex");

	UEngine_SkeletalMesh_FindSocketAndIndex_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (OutIndex != nullptr)
		*OutIndex = params.OutIndex;

	return params.ReturnValue;
}


// Function Engine.SkeletalMesh.FindSocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_SkeletalMeshSocket* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_SkeletalMeshSocket* UEngine_SkeletalMesh::FindSocket(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocket");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMesh.FindSocket");

	UEngine_SkeletalMesh_FindSocket_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_SkeletalMeshComponent* SkelComp                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 WorldLocation                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 WorldNormal                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkeletalMeshSocket::InitializeSocketFromLocation(class UEngine_SkeletalMeshComponent* SkelComp, const struct FVector& WorldLocation, const struct FVector& WorldNormal)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation");

	UEngine_SkeletalMeshSocket_InitializeSocketFromLocation_Params params;
	params.SkelComp = SkelComp;
	params.WorldLocation = WorldLocation;
	params.WorldNormal = WorldNormal;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkeletalMeshSocket.GetSocketLocation
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_SkeletalMeshComponent* SkelComp                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData)
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SkeletalMeshSocket::GetSocketLocation(class UEngine_SkeletalMeshComponent* SkelComp)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.GetSocketLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.GetSocketLocation");

	UEngine_SkeletalMeshSocket_GetSocketLocation_Params params;
	params.SkelComp = SkelComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SkyAtmosphereComponent.SetSkyLuminanceFactor
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetSkyLuminanceFactor(const struct FLinearColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetSkyLuminanceFactor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetSkyLuminanceFactor");

	UEngine_SkyAtmosphereComponent_SetSkyLuminanceFactor_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetRayleighScatteringScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetRayleighScatteringScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighScatteringScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighScatteringScale");

	UEngine_SkyAtmosphereComponent_SetRayleighScatteringScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetRayleighScattering
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetRayleighScattering(const struct FLinearColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighScattering");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighScattering");

	UEngine_SkyAtmosphereComponent_SetRayleighScattering_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetRayleighExponentialDistribution
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetRayleighExponentialDistribution(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighExponentialDistribution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetRayleighExponentialDistribution");

	UEngine_SkyAtmosphereComponent_SetRayleighExponentialDistribution_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetOtherAbsorptionScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetOtherAbsorptionScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetOtherAbsorptionScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetOtherAbsorptionScale");

	UEngine_SkyAtmosphereComponent_SetOtherAbsorptionScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetOtherAbsorption
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetOtherAbsorption(const struct FLinearColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetOtherAbsorption");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetOtherAbsorption");

	UEngine_SkyAtmosphereComponent_SetOtherAbsorption_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetMieScatteringScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetMieScatteringScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieScatteringScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieScatteringScale");

	UEngine_SkyAtmosphereComponent_SetMieScatteringScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetMieScattering
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetMieScattering(const struct FLinearColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieScattering");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieScattering");

	UEngine_SkyAtmosphereComponent_SetMieScattering_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetMieExponentialDistribution
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetMieExponentialDistribution(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieExponentialDistribution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieExponentialDistribution");

	UEngine_SkyAtmosphereComponent_SetMieExponentialDistribution_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetMieAnisotropy
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetMieAnisotropy(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAnisotropy");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAnisotropy");

	UEngine_SkyAtmosphereComponent_SetMieAnisotropy_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetMieAbsorptionScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetMieAbsorptionScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAbsorptionScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAbsorptionScale");

	UEngine_SkyAtmosphereComponent_SetMieAbsorptionScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetMieAbsorption
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetMieAbsorption(const struct FLinearColor& NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAbsorption");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetMieAbsorption");

	UEngine_SkyAtmosphereComponent_SetMieAbsorption_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetHeightFogContribution
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetHeightFogContribution(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetHeightFogContribution");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetHeightFogContribution");

	UEngine_SkyAtmosphereComponent_SetHeightFogContribution_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.SetAerialPespectiveViewDistanceScale
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewValue                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::SetAerialPespectiveViewDistanceScale(float NewValue)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetAerialPespectiveViewDistanceScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.SetAerialPespectiveViewDistanceScale");

	UEngine_SkyAtmosphereComponent_SetAerialPespectiveViewDistanceScale_Params params;
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyAtmosphereComponent.OverrideAtmosphereLightDirection
// (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// int                            AtmosphereLightIndex           (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 LightDirection                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SkyAtmosphereComponent::OverrideAtmosphereLightDirection(int AtmosphereLightIndex, const struct FVector& LightDirection)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.OverrideAtmosphereLightDirection");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyAtmosphereComponent.OverrideAtmosphereLightDirection");

	UEngine_SkyAtmosphereComponent_OverrideAtmosphereLightDirection_Params params;
	params.AtmosphereLightIndex = AtmosphereLightIndex;
	params.LightDirection = LightDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetVolumetricScatteringIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensity                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetVolumetricScatteringIntensity(float NewIntensity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetVolumetricScatteringIntensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetVolumetricScatteringIntensity");

	UEngine_SkyLightComponent_SetVolumetricScatteringIntensity_Params params;
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetOcclusionTint
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                  InTint                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SkyLightComponent::SetOcclusionTint(const struct FColor& InTint)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionTint");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionTint");

	UEngine_SkyLightComponent_SetOcclusionTint_Params params;
	params.InTint = InTint;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetOcclusionExponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InOcclusionExponent            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetOcclusionExponent(float InOcclusionExponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionExponent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionExponent");

	UEngine_SkyLightComponent_SetOcclusionExponent_Params params;
	params.InOcclusionExponent = InOcclusionExponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetOcclusionContrast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InOcclusionContrast            (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetOcclusionContrast(float InOcclusionContrast)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionContrast");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionContrast");

	UEngine_SkyLightComponent_SetOcclusionContrast_Params params;
	params.InOcclusionContrast = InOcclusionContrast;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetMinOcclusion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InMinOcclusion                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetMinOcclusion(float InMinOcclusion)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetMinOcclusion");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetMinOcclusion");

	UEngine_SkyLightComponent_SetMinOcclusion_Params params;
	params.InMinOcclusion = InMinOcclusion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetLowerHemisphereColor
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            InLowerHemisphereColor         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SkyLightComponent::SetLowerHemisphereColor(const struct FLinearColor& InLowerHemisphereColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLowerHemisphereColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLowerHemisphereColor");

	UEngine_SkyLightComponent_SetLowerHemisphereColor_Params params;
	params.InLowerHemisphereColor = InLowerHemisphereColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetLightColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor            NewLightColor                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetLightColor(const struct FLinearColor& NewLightColor)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLightColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLightColor");

	UEngine_SkyLightComponent_SetLightColor_Params params;
	params.NewLightColor = NewLightColor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensity                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetIntensity(float NewIntensity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIntensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIntensity");

	UEngine_SkyLightComponent_SetIntensity_Params params;
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetIndirectLightingIntensity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensity                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetIndirectLightingIntensity(float NewIntensity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIndirectLightingIntensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIndirectLightingIntensity");

	UEngine_SkyLightComponent_SetIndirectLightingIntensity_Params params;
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetCubemapBlend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_TextureCube*     SourceCubemap                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_TextureCube*     DestinationCubemap             (Parm, ZeroConstructor, IsPlainOldData)
// float                          InBlendFraction                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetCubemapBlend(class UEngine_TextureCube* SourceCubemap, class UEngine_TextureCube* DestinationCubemap, float InBlendFraction)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemapBlend");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemapBlend");

	UEngine_SkyLightComponent_SetCubemapBlend_Params params;
	params.SourceCubemap = SourceCubemap;
	params.DestinationCubemap = DestinationCubemap;
	params.InBlendFraction = InBlendFraction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.SetCubemap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_TextureCube*     NewCubemap                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SkyLightComponent::SetCubemap(class UEngine_TextureCube* NewCubemap)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemap");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemap");

	UEngine_SkyLightComponent_SetCubemap_Params params;
	params.NewCubemap = NewCubemap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SkyLightComponent.RecaptureSky
// (Final, Native, Public, BlueprintCallable)

void UEngine_SkyLightComponent::RecaptureSky()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.RecaptureSky");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.RecaptureSky");

	UEngine_SkyLightComponent_RecaptureSky_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundSubmix.StopRecordingOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// FEngine_Engine_EAudioRecordingExportType ExportType                     (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Name                           (Parm, ZeroConstructor)
// struct FString                 Path                           (Parm, ZeroConstructor)
// class UEngine_SoundWave*       ExistingSoundWaveToOverwrite   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SoundSubmix::StopRecordingOutput(class UObject* WorldContextObject, FEngine_Engine_EAudioRecordingExportType ExportType, const struct FString& Name, const struct FString& Path, class UEngine_SoundWave* ExistingSoundWaveToOverwrite)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StopRecordingOutput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StopRecordingOutput");

	UEngine_SoundSubmix_StopRecordingOutput_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ExportType = ExportType;
	params.Name = Name;
	params.Path = Path;
	params.ExistingSoundWaveToOverwrite = ExistingSoundWaveToOverwrite;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundSubmix.StopEnvelopeFollowing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SoundSubmix::StopEnvelopeFollowing(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StopEnvelopeFollowing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StopEnvelopeFollowing");

	UEngine_SoundSubmix_StopEnvelopeFollowing_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundSubmix.StartRecordingOutput
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          ExpectedDuration               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SoundSubmix::StartRecordingOutput(class UObject* WorldContextObject, float ExpectedDuration)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StartRecordingOutput");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StartRecordingOutput");

	UEngine_SoundSubmix_StartRecordingOutput_Params params;
	params.WorldContextObject = WorldContextObject;
	params.ExpectedDuration = ExpectedDuration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundSubmix.StartEnvelopeFollowing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SoundSubmix::StartEnvelopeFollowing(class UObject* WorldContextObject)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StartEnvelopeFollowing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.StartEnvelopeFollowing");

	UEngine_SoundSubmix_StartEnvelopeFollowing_Params params;
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundSubmix.SetSubmixOutputVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// float                          InOutputVolume                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SoundSubmix::SetSubmixOutputVolume(class UObject* WorldContextObject, float InOutputVolume)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.SetSubmixOutputVolume");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.SetSubmixOutputVolume");

	UEngine_SoundSubmix_SetSubmixOutputVolume_Params params;
	params.WorldContextObject = WorldContextObject;
	params.InOutputVolume = InOutputVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SoundSubmix.AddEnvelopeFollowerDelegate
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FScriptDelegate         OnSubmixEnvelopeBP             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_SoundSubmix::AddEnvelopeFollowerDelegate(class UObject* WorldContextObject, const struct FScriptDelegate& OnSubmixEnvelopeBP)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.AddEnvelopeFollowerDelegate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SoundSubmix.AddEnvelopeFollowerDelegate");

	UEngine_SoundSubmix_AddEnvelopeFollowerDelegate_Params params;
	params.WorldContextObject = WorldContextObject;
	params.OnSubmixEnvelopeBP = OnSubmixEnvelopeBP;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.UpdateMesh
// (Final, Native, Public, BlueprintCallable)

void UEngine_SplineMeshComponent::UpdateMesh()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.UpdateMesh");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.UpdateMesh");

	UEngine_SplineMeshComponent_UpdateMesh_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetStartTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 StartTangent                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetStartTangent(const struct FVector& StartTangent, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartTangent");

	UEngine_SplineMeshComponent_SetStartTangent_Params params;
	params.StartTangent = StartTangent;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetStartScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               StartScale                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetStartScale(const struct FVector2D& StartScale, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartScale");

	UEngine_SplineMeshComponent_SetStartScale_Params params;
	params.StartScale = StartScale;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetStartRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          StartRoll                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetStartRoll(float StartRoll, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartRoll");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartRoll");

	UEngine_SplineMeshComponent_SetStartRoll_Params params;
	params.StartRoll = StartRoll;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetStartPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 StartPos                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetStartPosition(const struct FVector& StartPos, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartPosition");

	UEngine_SplineMeshComponent_SetStartPosition_Params params;
	params.StartPos = StartPos;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetStartOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               StartOffset                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetStartOffset(const struct FVector2D& StartOffset, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartOffset");

	UEngine_SplineMeshComponent_SetStartOffset_Params params;
	params.StartOffset = StartOffset;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetStartAndEnd
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 StartPos                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 StartTangent                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 EndPos                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 EndTangent                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetStartAndEnd(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartAndEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartAndEnd");

	UEngine_SplineMeshComponent_SetStartAndEnd_Params params;
	params.StartPos = StartPos;
	params.StartTangent = StartTangent;
	params.EndPos = EndPos;
	params.EndTangent = EndTangent;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetSplineUpDir
// (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 InSplineUpDir                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetSplineUpDir(const struct FVector& InSplineUpDir, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetSplineUpDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetSplineUpDir");

	UEngine_SplineMeshComponent_SetSplineUpDir_Params params;
	params.InSplineUpDir = InSplineUpDir;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetForwardAxis
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ESplineMeshAxis> InForwardAxis                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetForwardAxis(TEnumAsByte<FEngine_Engine_ESplineMeshAxis> InForwardAxis, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetForwardAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetForwardAxis");

	UEngine_SplineMeshComponent_SetForwardAxis_Params params;
	params.InForwardAxis = InForwardAxis;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetEndTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 EndTangent                     (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetEndTangent(const struct FVector& EndTangent, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndTangent");

	UEngine_SplineMeshComponent_SetEndTangent_Params params;
	params.EndTangent = EndTangent;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetEndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               EndScale                       (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetEndScale(const struct FVector2D& EndScale, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndScale");

	UEngine_SplineMeshComponent_SetEndScale_Params params;
	params.EndScale = EndScale;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetEndRoll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          EndRoll                        (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetEndRoll(float EndRoll, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndRoll");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndRoll");

	UEngine_SplineMeshComponent_SetEndRoll_Params params;
	params.EndRoll = EndRoll;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetEndPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                 EndPos                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetEndPosition(const struct FVector& EndPos, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndPosition");

	UEngine_SplineMeshComponent_SetEndPosition_Params params;
	params.EndPos = EndPos;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetEndOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               EndOffset                      (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetEndOffset(const struct FVector2D& EndOffset, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndOffset");

	UEngine_SplineMeshComponent_SetEndOffset_Params params;
	params.EndOffset = EndOffset;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetBoundaryMin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InBoundaryMin                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMin");

	UEngine_SplineMeshComponent_SetBoundaryMin_Params params;
	params.InBoundaryMin = InBoundaryMin;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.SetBoundaryMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InBoundaryMax                  (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bUpdateMesh                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SplineMeshComponent::SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetBoundaryMax");

	UEngine_SplineMeshComponent_SetBoundaryMax_Params params;
	params.InBoundaryMax = InBoundaryMax;
	params.bUpdateMesh = bUpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SplineMeshComponent.GetStartTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineMeshComponent::GetStartTangent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartTangent");

	UEngine_SplineMeshComponent_GetStartTangent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_SplineMeshComponent::GetStartScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartScale");

	UEngine_SplineMeshComponent_GetStartScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineMeshComponent::GetStartRoll()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartRoll");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartRoll");

	UEngine_SplineMeshComponent_GetStartRoll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineMeshComponent::GetStartPosition()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartPosition");

	UEngine_SplineMeshComponent_GetStartPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetStartOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_SplineMeshComponent::GetStartOffset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartOffset");

	UEngine_SplineMeshComponent_GetStartOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetSplineUpDir
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineMeshComponent::GetSplineUpDir()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetSplineUpDir");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetSplineUpDir");

	UEngine_SplineMeshComponent_GetSplineUpDir_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetForwardAxis
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TEnumAsByte<FEngine_Engine_ESplineMeshAxis> ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

TEnumAsByte<FEngine_Engine_ESplineMeshAxis> UEngine_SplineMeshComponent::GetForwardAxis()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetForwardAxis");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetForwardAxis");

	UEngine_SplineMeshComponent_GetForwardAxis_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndTangent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineMeshComponent::GetEndTangent()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndTangent");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndTangent");

	UEngine_SplineMeshComponent_GetEndTangent_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_SplineMeshComponent::GetEndScale()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndScale");

	UEngine_SplineMeshComponent_GetEndScale_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndRoll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineMeshComponent::GetEndRoll()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndRoll");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndRoll");

	UEngine_SplineMeshComponent_GetEndRoll_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SplineMeshComponent::GetEndPosition()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndPosition");

	UEngine_SplineMeshComponent_GetEndPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetEndOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_SplineMeshComponent::GetEndOffset()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndOffset");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndOffset");

	UEngine_SplineMeshComponent_GetEndOffset_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetBoundaryMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineMeshComponent::GetBoundaryMin()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMin");

	UEngine_SplineMeshComponent_GetBoundaryMin_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SplineMeshComponent.GetBoundaryMax
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_SplineMeshComponent::GetBoundaryMax()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMax");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetBoundaryMax");

	UEngine_SplineMeshComponent_GetBoundaryMax_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SpotLightComponent.SetOuterConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewOuterConeAngle              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SpotLightComponent::SetOuterConeAngle(float NewOuterConeAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetOuterConeAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetOuterConeAngle");

	UEngine_SpotLightComponent_SetOuterConeAngle_Params params;
	params.NewOuterConeAngle = NewOuterConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpotLightComponent.SetInnerConeAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewInnerConeAngle              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_SpotLightComponent::SetInnerConeAngle(float NewInnerConeAngle)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetInnerConeAngle");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetInnerConeAngle");

	UEngine_SpotLightComponent_SetInnerConeAngle_Params params;
	params.NewInnerConeAngle = NewInnerConeAngle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SpringArmComponent.IsCollisionFixApplied
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_SpringArmComponent::IsCollisionFixApplied()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.IsCollisionFixApplied");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.IsCollisionFixApplied");

	UEngine_SpringArmComponent_IsCollisionFixApplied_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SpringArmComponent.GetUnfixedCameraPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_SpringArmComponent::GetUnfixedCameraPosition()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.GetUnfixedCameraPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.GetUnfixedCameraPosition");

	UEngine_SpringArmComponent_GetUnfixedCameraPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SpringArmComponent.GetTargetRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FRotator UEngine_SpringArmComponent::GetTargetRotation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.GetTargetRotation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SpringArmComponent.GetTargetRotation");

	UEngine_SpringArmComponent_GetTargetRotation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.RemoveSocket
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_StaticMeshSocket* Socket                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StaticMesh::RemoveSocket(class UEngine_StaticMeshSocket* Socket)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.RemoveSocket");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.RemoveSocket");

	UEngine_StaticMesh_RemoveSocket_Params params;
	params.Socket = Socket;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMesh.GetNumSections
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            InLOD                          (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_StaticMesh::GetNumSections(int InLOD)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumSections");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumSections");

	UEngine_StaticMesh_GetNumSections_Params params;
	params.InLOD = InLOD;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.GetNumLODs
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_StaticMesh::GetNumLODs()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumLODs");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetNumLODs");

	UEngine_StaticMesh_GetNumLODs_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.GetMinimumLODForPlatforms
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<struct FName, int>        PlatformMinimumLODs            (Parm, OutParm, ZeroConstructor)

void UEngine_StaticMesh::GetMinimumLODForPlatforms(TMap<struct FName, int>* PlatformMinimumLODs)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForPlatforms");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForPlatforms");

	UEngine_StaticMesh_GetMinimumLODForPlatforms_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	if (PlatformMinimumLODs != nullptr)
		*PlatformMinimumLODs = params.PlatformMinimumLODs;
}


// Function Engine.StaticMesh.GetMinimumLODForPlatform
// (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   PlatformName                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_StaticMesh::GetMinimumLODForPlatform(const struct FName& PlatformName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForPlatform");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMinimumLODForPlatform");

	UEngine_StaticMesh_GetMinimumLODForPlatform_Params params;
	params.PlatformName = PlatformName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.GetMaterialIndex
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   MaterialSlotName               (Parm, ZeroConstructor, IsPlainOldData)
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_StaticMesh::GetMaterialIndex(const struct FName& MaterialSlotName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMaterialIndex");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMaterialIndex");

	UEngine_StaticMesh_GetMaterialIndex_Params params;
	params.MaterialSlotName = MaterialSlotName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.GetMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            MaterialIndex                  (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_MaterialInterface* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_MaterialInterface* UEngine_StaticMesh::GetMaterial(int MaterialIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetMaterial");

	UEngine_StaticMesh_GetMaterial_Params params;
	params.MaterialIndex = MaterialIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.GetBounds
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds        ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FBoxSphereBounds UEngine_StaticMesh::GetBounds()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetBounds");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetBounds");

	UEngine_StaticMesh_GetBounds_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.GetBoundingBox
// (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                    ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FBox UEngine_StaticMesh::GetBoundingBox()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetBoundingBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.GetBoundingBox");

	UEngine_StaticMesh_GetBoundingBox_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.FindSocket
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FName                   InSocketName                   (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_StaticMeshSocket* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_StaticMeshSocket* UEngine_StaticMesh::FindSocket(const struct FName& InSocketName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.FindSocket");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.FindSocket");

	UEngine_StaticMesh_FindSocket_Params params;
	params.InSocketName = InSocketName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.CreateStaticMeshDescription
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 Outer                          (Parm, ZeroConstructor, IsPlainOldData)
// class UStaticMeshDescription_StaticMeshDescription* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UStaticMeshDescription_StaticMeshDescription* UEngine_StaticMesh::STATIC_CreateStaticMeshDescription(class UObject* Outer)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.CreateStaticMeshDescription");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.CreateStaticMeshDescription");

	UEngine_StaticMesh_CreateStaticMeshDescription_Params params;
	params.Outer = Outer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StaticMesh.BuildFromStaticMeshDescriptions
// (Final, RequiredAPI, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// TArray<class UStaticMeshDescription_StaticMeshDescription*> StaticMeshDescriptions         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)

void UEngine_StaticMesh::BuildFromStaticMeshDescriptions(TArray<class UStaticMeshDescription_StaticMeshDescription*> StaticMeshDescriptions)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.BuildFromStaticMeshDescriptions");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.BuildFromStaticMeshDescriptions");

	UEngine_StaticMesh_BuildFromStaticMeshDescriptions_Params params;
	params.StaticMeshDescriptions = StaticMeshDescriptions;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMesh.AddSocket
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_StaticMeshSocket* Socket                         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StaticMesh::AddSocket(class UEngine_StaticMeshSocket* Socket)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.AddSocket");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.AddSocket");

	UEngine_StaticMesh_AddSocket_Params params;
	params.Socket = Socket;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StaticMesh.AddMaterial
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FName UEngine_StaticMesh::AddMaterial(class UEngine_MaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.AddMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StaticMesh.AddMaterial");

	UEngine_StaticMesh_AddMaterial_Params params;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StereoLayerComponent.SetUVRect
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FBox2D                  InUVRect                       (Parm, ZeroConstructor)

void UEngine_StereoLayerComponent::SetUVRect(const struct FBox2D& InUVRect)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetUVRect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetUVRect");

	UEngine_StereoLayerComponent_SetUVRect_Params params;
	params.InUVRect = InUVRect;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerComponent.SetTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         InTexture                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StereoLayerComponent::SetTexture(class UEngine_Texture* InTexture)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetTexture");

	UEngine_StereoLayerComponent_SetTexture_Params params;
	params.InTexture = InTexture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerComponent.SetQuadSize
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D               InQuadSize                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StereoLayerComponent::SetQuadSize(const struct FVector2D& InQuadSize)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetQuadSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetQuadSize");

	UEngine_StereoLayerComponent_SetQuadSize_Params params;
	params.InQuadSize = InQuadSize;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerComponent.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int                            InPriority                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StereoLayerComponent::SetPriority(int InPriority)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetPriority");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetPriority");

	UEngine_StereoLayerComponent_SetPriority_Params params;
	params.InPriority = InPriority;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerComponent.SetLeftTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         InTexture                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StereoLayerComponent::SetLeftTexture(class UEngine_Texture* InTexture)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetLeftTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetLeftTexture");

	UEngine_StereoLayerComponent_SetLeftTexture_Params params;
	params.InTexture = InTexture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerComponent.SetEquirectProps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FEngine_EquirectProps   InScaleBiases                  (Parm)

void UEngine_StereoLayerComponent::SetEquirectProps(const struct FEngine_EquirectProps& InScaleBiases)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetEquirectProps");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.SetEquirectProps");

	UEngine_StereoLayerComponent_SetEquirectProps_Params params;
	params.InScaleBiases = InScaleBiases;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerComponent.MarkTextureForUpdate
// (Final, Native, Public, BlueprintCallable)

void UEngine_StereoLayerComponent::MarkTextureForUpdate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.MarkTextureForUpdate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.MarkTextureForUpdate");

	UEngine_StereoLayerComponent_MarkTextureForUpdate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerComponent.GetUVRect
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox2D                  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FBox2D UEngine_StereoLayerComponent::GetUVRect()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetUVRect");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetUVRect");

	UEngine_StereoLayerComponent_GetUVRect_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_Texture*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Texture* UEngine_StereoLayerComponent::GetTexture()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetTexture");

	UEngine_StereoLayerComponent_GetTexture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetQuadSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector2D UEngine_StereoLayerComponent::GetQuadSize()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetQuadSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetQuadSize");

	UEngine_StereoLayerComponent_GetQuadSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_StereoLayerComponent::GetPriority()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetPriority");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetPriority");

	UEngine_StereoLayerComponent_GetPriority_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StereoLayerComponent.GetLeftTexture
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEngine_Texture*         ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_Texture* UEngine_StereoLayerComponent::GetLeftTexture()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetLeftTexture");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerComponent.GetLeftTexture");

	UEngine_StereoLayerComponent_GetLeftTexture_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.StereoLayerFunctionLibrary.ShowSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_StereoLayerFunctionLibrary::STATIC_ShowSplashScreen()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.ShowSplashScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.ShowSplashScreen");

	UEngine_StereoLayerFunctionLibrary_ShowSplashScreen_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerFunctionLibrary.SetSplashScreen
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UEngine_Texture*         Texture                        (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector2D               Scale                          (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Offset                         (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShowLoadingMovie              (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bShowOnSet                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StereoLayerFunctionLibrary::STATIC_SetSplashScreen(class UEngine_Texture* Texture, const struct FVector2D& Scale, const struct FVector& Offset, bool bShowLoadingMovie, bool bShowOnSet)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.SetSplashScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.SetSplashScreen");

	UEngine_StereoLayerFunctionLibrary_SetSplashScreen_Params params;
	params.Texture = Texture;
	params.Scale = Scale;
	params.Offset = Offset;
	params.bShowLoadingMovie = bShowLoadingMovie;
	params.bShowOnSet = bShowOnSet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerFunctionLibrary.HideSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)

void UEngine_StereoLayerFunctionLibrary::STATIC_HideSplashScreen()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.HideSplashScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.HideSplashScreen");

	UEngine_StereoLayerFunctionLibrary_HideSplashScreen_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           InAutoShowEnabled              (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_StereoLayerFunctionLibrary::STATIC_EnableAutoLoadingSplashScreen(bool InAutoShowEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen");

	UEngine_StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen_Params params;
	params.InAutoShowEnabled = InAutoShowEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.SubsystemBlueprintLibrary.GetWorldSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 ContextObject                  (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_WorldSubsystem*  ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_WorldSubsystem* UEngine_SubsystemBlueprintLibrary::STATIC_GetWorldSubsystem(class UObject* ContextObject, class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetWorldSubsystem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetWorldSubsystem");

	UEngine_SubsystemBlueprintLibrary_GetWorldSubsystem_Params params;
	params.ContextObject = ContextObject;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubSystemFromPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AEngine_PlayerController* PlayerController               (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_LocalPlayerSubsystem* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_LocalPlayerSubsystem* UEngine_SubsystemBlueprintLibrary::STATIC_GetLocalPlayerSubSystemFromPlayerController(class AEngine_PlayerController* PlayerController, class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubSystemFromPlayerController");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubSystemFromPlayerController");

	UEngine_SubsystemBlueprintLibrary_GetLocalPlayerSubSystemFromPlayerController_Params params;
	params.PlayerController = PlayerController;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 ContextObject                  (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_LocalPlayerSubsystem* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_LocalPlayerSubsystem* UEngine_SubsystemBlueprintLibrary::STATIC_GetLocalPlayerSubsystem(class UObject* ContextObject, class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubsystem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetLocalPlayerSubsystem");

	UEngine_SubsystemBlueprintLibrary_GetLocalPlayerSubsystem_Params params;
	params.ContextObject = ContextObject;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetGameInstanceSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                 ContextObject                  (Parm, ZeroConstructor, IsPlainOldData)
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_GameInstanceSubsystem* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_GameInstanceSubsystem* UEngine_SubsystemBlueprintLibrary::STATIC_GetGameInstanceSubsystem(class UObject* ContextObject, class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetGameInstanceSubsystem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetGameInstanceSubsystem");

	UEngine_SubsystemBlueprintLibrary_GetGameInstanceSubsystem_Params params;
	params.ContextObject = ContextObject;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SubsystemBlueprintLibrary.GetEngineSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UClass*                  Class                          (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_EngineSubsystem* ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

class UEngine_EngineSubsystem* UEngine_SubsystemBlueprintLibrary::STATIC_GetEngineSubsystem(class UClass* Class)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetEngineSubsystem");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SubsystemBlueprintLibrary.GetEngineSubsystem");

	UEngine_SubsystemBlueprintLibrary_GetEngineSubsystem_Params params;
	params.Class = Class;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimecodeProvider.GetTimecode
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimecode               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FTimecode UEngine_TimecodeProvider::GetTimecode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetTimecode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetTimecode");

	UEngine_TimecodeProvider_GetTimecode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimecodeProvider.GetSynchronizationState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// FEngine_Engine_ETimecodeProviderSynchronizationState ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

FEngine_Engine_ETimecodeProviderSynchronizationState UEngine_TimecodeProvider::GetSynchronizationState()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetSynchronizationState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetSynchronizationState");

	UEngine_TimecodeProvider_GetSynchronizationState_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimecodeProvider.GetFrameRate
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFrameRate              ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FFrameRate UEngine_TimecodeProvider::GetFrameRate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetFrameRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetFrameRate");

	UEngine_TimecodeProvider_GetFrameRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimecodeProvider.GetDelayedTimecode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTimecode               ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FTimecode UEngine_TimecodeProvider::GetDelayedTimecode()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetDelayedTimecode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimecodeProvider.GetDelayedTimecode");

	UEngine_TimecodeProvider_GetDelayedTimecode_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.SystemTimeTimecodeProvider.SetFrameRate
// (Final, Native, Public, HasOutParms)
// Parameters:
// struct FFrameRate              InFrameRate                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData)

void UEngine_SystemTimeTimecodeProvider::SetFrameRate(const struct FFrameRate& InFrameRate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.SystemTimeTimecodeProvider.SetFrameRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.SystemTimeTimecodeProvider.SetFrameRate");

	UEngine_SystemTimeTimecodeProvider_SetFrameRate_Params params;
	params.InFrameRate = InFrameRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetYScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetYScale(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetYScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetYScale");

	UEngine_TextRenderComponent_SetYScale_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetXScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetXScale(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetXScale");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetXScale");

	UEngine_TextRenderComponent_SetXScale_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetWorldSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetWorldSize(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetWorldSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetWorldSize");

	UEngine_TextRenderComponent_SetWorldSize_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetVertSpacingAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetVertSpacingAdjust(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetVertSpacingAdjust");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetVertSpacingAdjust");

	UEngine_TextRenderComponent_SetVertSpacingAdjust_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetVerticalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EVerticalTextAligment> Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetVerticalAlignment(TEnumAsByte<FEngine_Engine_EVerticalTextAligment> Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetVerticalAlignment");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetVerticalAlignment");

	UEngine_TextRenderComponent_SetVerticalAlignment_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetTextRenderColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FColor                  Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetTextRenderColor(const struct FColor& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextRenderColor");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextRenderColor");

	UEngine_TextRenderComponent_SetTextRenderColor_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetTextMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_MaterialInterface* Material                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetTextMaterial(class UEngine_MaterialInterface* Material)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextMaterial");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextMaterial");

	UEngine_TextRenderComponent_SetTextMaterial_Params params;
	params.Material = Material;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FString                 Value                          (Parm, ZeroConstructor)

void UEngine_TextRenderComponent::SetText(const struct FString& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetText");

	UEngine_TextRenderComponent_SetText_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetHorizSpacingAdjust
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetHorizSpacingAdjust(float Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizSpacingAdjust");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizSpacingAdjust");

	UEngine_TextRenderComponent_SetHorizSpacingAdjust_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetHorizontalAlignment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_EHorizTextAligment> Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetHorizontalAlignment(TEnumAsByte<FEngine_Engine_EHorizTextAligment> Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizontalAlignment");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizontalAlignment");

	UEngine_TextRenderComponent_SetHorizontalAlignment_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.SetFont
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_Font*            Value                          (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TextRenderComponent::SetFont(class UEngine_Font* Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetFont");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetFont");

	UEngine_TextRenderComponent_SetFont_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.K2_SetText
// (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
// struct FText                   Value                          (ConstParm, Parm, OutParm, ReferenceParm)

void UEngine_TextRenderComponent::K2_SetText(const struct FText& Value)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.K2_SetText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.K2_SetText");

	UEngine_TextRenderComponent_K2_SetText_Params params;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TextRenderComponent.GetTextWorldSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_TextRenderComponent::GetTextWorldSize()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextWorldSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextWorldSize");

	UEngine_TextRenderComponent_GetTextWorldSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TextRenderComponent.GetTextLocalSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

struct FVector UEngine_TextRenderComponent::GetTextLocalSize()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextLocalSize");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextLocalSize");

	UEngine_TextRenderComponent_GetTextLocalSize_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimelineComponent.Stop
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UEngine_TimelineComponent::Stop()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Stop");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Stop");

	UEngine_TimelineComponent_Stop_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetVectorCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_CurveVector*     NewVectorCurve                 (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   VectorTrackName                (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetVectorCurve(class UEngine_CurveVector* NewVectorCurve, const struct FName& VectorTrackName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetVectorCurve");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetVectorCurve");

	UEngine_TimelineComponent_SetVectorCurve_Params params;
	params.NewVectorCurve = NewVectorCurve;
	params.VectorTrackName = VectorTrackName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetTimelineLengthMode
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// TEnumAsByte<FEngine_Engine_ETimelineLengthMode> NewLengthMode                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetTimelineLengthMode(TEnumAsByte<FEngine_Engine_ETimelineLengthMode> NewLengthMode)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLengthMode");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLengthMode");

	UEngine_TimelineComponent_SetTimelineLengthMode_Params params;
	params.NewLengthMode = NewLengthMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetTimelineLength
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewLength                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetTimelineLength(float NewLength)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLength");

	UEngine_TimelineComponent_SetTimelineLength_Params params;
	params.NewLength = NewLength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetPlayRate
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewRate                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetPlayRate(float NewRate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlayRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlayRate");

	UEngine_TimelineComponent_SetPlayRate_Params params;
	params.NewRate = NewRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetPlaybackPosition
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewPosition                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFireEvents                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bFireUpdate                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlaybackPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlaybackPosition");

	UEngine_TimelineComponent_SetPlaybackPosition_Params params;
	params.NewPosition = NewPosition;
	params.bFireEvents = bFireEvents;
	params.bFireUpdate = bFireUpdate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetNewTime
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// float                          NewTime                        (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetNewTime(float NewTime)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetNewTime");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetNewTime");

	UEngine_TimelineComponent_SetNewTime_Params params;
	params.NewTime = NewTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetLooping
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewLooping                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetLooping(bool bNewLooping)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLooping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLooping");

	UEngine_TimelineComponent_SetLooping_Params params;
	params.bNewLooping = bNewLooping;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetLinearColorCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_CurveLinearColor* NewLinearColorCurve            (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   LinearColorTrackName           (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetLinearColorCurve(class UEngine_CurveLinearColor* NewLinearColorCurve, const struct FName& LinearColorTrackName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLinearColorCurve");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLinearColorCurve");

	UEngine_TimelineComponent_SetLinearColorCurve_Params params;
	params.NewLinearColorCurve = NewLinearColorCurve;
	params.LinearColorTrackName = LinearColorTrackName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetIgnoreTimeDilation
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// bool                           bNewIgnoreTimeDilation         (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetIgnoreTimeDilation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetIgnoreTimeDilation");

	UEngine_TimelineComponent_SetIgnoreTimeDilation_Params params;
	params.bNewIgnoreTimeDilation = bNewIgnoreTimeDilation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.SetFloatCurve
// (Final, RequiredAPI, Native, Public, BlueprintCallable)
// Parameters:
// class UEngine_CurveFloat*      NewFloatCurve                  (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   FloatTrackName                 (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_TimelineComponent::SetFloatCurve(class UEngine_CurveFloat* NewFloatCurve, const struct FName& FloatTrackName)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetFloatCurve");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetFloatCurve");

	UEngine_TimelineComponent_SetFloatCurve_Params params;
	params.NewFloatCurve = NewFloatCurve;
	params.FloatTrackName = FloatTrackName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.ReverseFromEnd
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UEngine_TimelineComponent::ReverseFromEnd()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.ReverseFromEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.ReverseFromEnd");

	UEngine_TimelineComponent_ReverseFromEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.Reverse
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UEngine_TimelineComponent::Reverse()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Reverse");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Reverse");

	UEngine_TimelineComponent_Reverse_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.PlayFromStart
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UEngine_TimelineComponent::PlayFromStart()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.PlayFromStart");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.PlayFromStart");

	UEngine_TimelineComponent_PlayFromStart_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.Play
// (Final, RequiredAPI, Native, Public, BlueprintCallable)

void UEngine_TimelineComponent::Play()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Play");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Play");

	UEngine_TimelineComponent_Play_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.OnRep_Timeline
// (Final, Native, Public)

void UEngine_TimelineComponent::OnRep_Timeline()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnRep_Timeline");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnRep_Timeline");

	UEngine_TimelineComponent_OnRep_Timeline_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TimelineComponent.IsReversing
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TimelineComponent::IsReversing()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsReversing");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsReversing");

	UEngine_TimelineComponent_IsReversing_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimelineComponent.IsPlaying
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TimelineComponent::IsPlaying()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsPlaying");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsPlaying");

	UEngine_TimelineComponent_IsPlaying_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimelineComponent.IsLooping
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TimelineComponent::IsLooping()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsLooping");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsLooping");

	UEngine_TimelineComponent_IsLooping_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimelineComponent.GetTimelineLength
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_TimelineComponent::GetTimelineLength()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetTimelineLength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetTimelineLength");

	UEngine_TimelineComponent_GetTimelineLength_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimelineComponent.GetPlayRate
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_TimelineComponent::GetPlayRate()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlayRate");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlayRate");

	UEngine_TimelineComponent_GetPlayRate_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimelineComponent.GetPlaybackPosition
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_TimelineComponent::GetPlaybackPosition()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlaybackPosition");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlaybackPosition");

	UEngine_TimelineComponent_GetPlaybackPosition_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TimelineComponent.GetIgnoreTimeDilation
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TimelineComponent::GetIgnoreTimeDilation()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetIgnoreTimeDilation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetIgnoreTimeDilation");

	UEngine_TimelineComponent_GetIgnoreTimeDilation_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.TwitterRequest
// (Native, Public, HasOutParms)
// Parameters:
// struct FString                 URL                            (Parm, ZeroConstructor)
// TArray<struct FString>         ParamKeysAndValues             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
// TEnumAsByte<FEngine_Engine_ETwitterRequestMethod> RequestMethod                  (Parm, ZeroConstructor, IsPlainOldData)
// int                            AccountIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TwitterIntegrationBase::TwitterRequest(const struct FString& URL, TArray<struct FString> ParamKeysAndValues, TEnumAsByte<FEngine_Engine_ETwitterRequestMethod> RequestMethod, int AccountIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.TwitterRequest");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.TwitterRequest");

	UEngine_TwitterIntegrationBase_TwitterRequest_Params params;
	params.URL = URL;
	params.ParamKeysAndValues = ParamKeysAndValues;
	params.RequestMethod = RequestMethod;
	params.AccountIndex = AccountIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.ShowTweetUI
// (Native, Public)
// Parameters:
// struct FString                 InitialMessage                 (Parm, ZeroConstructor)
// struct FString                 URL                            (Parm, ZeroConstructor)
// struct FString                 Picture                        (Parm, ZeroConstructor)
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TwitterIntegrationBase::ShowTweetUI(const struct FString& InitialMessage, const struct FString& URL, const struct FString& Picture)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.ShowTweetUI");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.ShowTweetUI");

	UEngine_TwitterIntegrationBase_ShowTweetUI_Params params;
	params.InitialMessage = InitialMessage;
	params.URL = URL;
	params.Picture = Picture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.Init
// (Native, Public)

void UEngine_TwitterIntegrationBase::Init()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.Init");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.Init");

	UEngine_TwitterIntegrationBase_Init_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.TwitterIntegrationBase.GetNumAccounts
// (Native, Public)
// Parameters:
// int                            ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

int UEngine_TwitterIntegrationBase::GetNumAccounts()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetNumAccounts");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetNumAccounts");

	UEngine_TwitterIntegrationBase_GetNumAccounts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.GetAccountName
// (Native, Public)
// Parameters:
// int                            AccountIndex                   (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm)

struct FString UEngine_TwitterIntegrationBase::GetAccountName(int AccountIndex)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetAccountName");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetAccountName");

	UEngine_TwitterIntegrationBase_GetAccountName_Params params;
	params.AccountIndex = AccountIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.CanShowTweetUI
// (Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TwitterIntegrationBase::CanShowTweetUI()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.CanShowTweetUI");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.CanShowTweetUI");

	UEngine_TwitterIntegrationBase_CanShowTweetUI_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.TwitterIntegrationBase.AuthorizeAccounts
// (Native, Public)
// Parameters:
// bool                           ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

bool UEngine_TwitterIntegrationBase::AuthorizeAccounts()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.AuthorizeAccounts");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.AuthorizeAccounts");

	UEngine_TwitterIntegrationBase_AuthorizeAccounts_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.VectorFieldComponent.SetIntensity
// (Native, Public, BlueprintCallable)
// Parameters:
// float                          NewIntensity                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VectorFieldComponent::SetIntensity(float NewIntensity)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VectorFieldComponent.SetIntensity");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VectorFieldComponent.SetIntensity");

	UEngine_VectorFieldComponent_SetIntensity_Params params;
	params.NewIntensity = NewIntensity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VisualLoggerKismetLibrary.RedirectVislog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 SourceOwner                    (Parm, ZeroConstructor, IsPlainOldData)
// class UObject*                 DestinationOwner               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VisualLoggerKismetLibrary::STATIC_RedirectVislog(class UObject* SourceOwner, class UObject* DestinationOwner)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.RedirectVislog");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.RedirectVislog");

	UEngine_VisualLoggerKismetLibrary_RedirectVislog_Params params;
	params.SourceOwner = SourceOwner;
	params.DestinationOwner = DestinationOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VisualLoggerKismetLibrary.LogText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Text                           (Parm, ZeroConstructor)
// struct FName                   LogCategory                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToMessageLog               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VisualLoggerKismetLibrary::STATIC_LogText(class UObject* WorldContextObject, const struct FString& Text, const struct FName& LogCategory, bool bAddToMessageLog)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogText");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogText");

	UEngine_VisualLoggerKismetLibrary_LogText_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Text = Text;
	params.LogCategory = LogCategory;
	params.bAddToMessageLog = bAddToMessageLog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VisualLoggerKismetLibrary.LogSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SegmentStart                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 SegmentEnd                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Text                           (Parm, ZeroConstructor)
// struct FLinearColor            ObjectColor                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Thickness                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   CategoryName                   (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToMessageLog               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VisualLoggerKismetLibrary::STATIC_LogSegment(class UObject* WorldContextObject, const struct FVector& SegmentStart, const struct FVector& SegmentEnd, const struct FString& Text, const struct FLinearColor& ObjectColor, float Thickness, const struct FName& CategoryName, bool bAddToMessageLog)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogSegment");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogSegment");

	UEngine_VisualLoggerKismetLibrary_LogSegment_Params params;
	params.WorldContextObject = WorldContextObject;
	params.SegmentStart = SegmentStart;
	params.SegmentEnd = SegmentEnd;
	params.Text = Text;
	params.ObjectColor = ObjectColor;
	params.Thickness = Thickness;
	params.CategoryName = CategoryName;
	params.bAddToMessageLog = bAddToMessageLog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VisualLoggerKismetLibrary.LogLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FVector                 Location                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Text                           (Parm, ZeroConstructor)
// struct FLinearColor            ObjectColor                    (Parm, ZeroConstructor, IsPlainOldData)
// float                          Radius                         (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   LogCategory                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToMessageLog               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VisualLoggerKismetLibrary::STATIC_LogLocation(class UObject* WorldContextObject, const struct FVector& Location, const struct FString& Text, const struct FLinearColor& ObjectColor, float Radius, const struct FName& LogCategory, bool bAddToMessageLog)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogLocation");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogLocation");

	UEngine_VisualLoggerKismetLibrary_LogLocation_Params params;
	params.WorldContextObject = WorldContextObject;
	params.Location = Location;
	params.Text = Text;
	params.ObjectColor = ObjectColor;
	params.Radius = Radius;
	params.LogCategory = LogCategory;
	params.bAddToMessageLog = bAddToMessageLog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VisualLoggerKismetLibrary.LogBox
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                 WorldContextObject             (Parm, ZeroConstructor, IsPlainOldData)
// struct FBox                    BoxShape                       (Parm, ZeroConstructor, IsPlainOldData)
// struct FString                 Text                           (Parm, ZeroConstructor)
// struct FLinearColor            ObjectColor                    (Parm, ZeroConstructor, IsPlainOldData)
// struct FName                   LogCategory                    (Parm, ZeroConstructor, IsPlainOldData)
// bool                           bAddToMessageLog               (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VisualLoggerKismetLibrary::STATIC_LogBox(class UObject* WorldContextObject, const struct FBox& BoxShape, const struct FString& Text, const struct FLinearColor& ObjectColor, const struct FName& LogCategory, bool bAddToMessageLog)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogBox");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.LogBox");

	UEngine_VisualLoggerKismetLibrary_LogBox_Params params;
	params.WorldContextObject = WorldContextObject;
	params.BoxShape = BoxShape;
	params.Text = Text;
	params.ObjectColor = ObjectColor;
	params.LogCategory = LogCategory;
	params.bAddToMessageLog = bAddToMessageLog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VisualLoggerKismetLibrary.EnableRecording
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                           bEnabled                       (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VisualLoggerKismetLibrary::STATIC_EnableRecording(bool bEnabled)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.EnableRecording");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VisualLoggerKismetLibrary.EnableRecording");

	UEngine_VisualLoggerKismetLibrary_EnableRecording_Params params;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VOIPTalker.RegisterWithPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerState*     OwningState                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VOIPTalker::RegisterWithPlayerState(class AEngine_PlayerState* OwningState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.RegisterWithPlayerState");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.RegisterWithPlayerState");

	UEngine_VOIPTalker_RegisterWithPlayerState_Params params;
	params.OwningState = OwningState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VOIPTalker.GetVoiceLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          ReturnValue                    (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData)

float UEngine_VOIPTalker::GetVoiceLevel()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.GetVoiceLevel");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.GetVoiceLevel");

	UEngine_VOIPTalker_GetVoiceLevel_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.VOIPTalker.CreateTalkerForPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEngine_PlayerState*     OwningState                    (Parm, ZeroConstructor, IsPlainOldData)
// class UEngine_VOIPTalker*      ReturnValue                    (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData)

class UEngine_VOIPTalker* UEngine_VOIPTalker::STATIC_CreateTalkerForPlayer(class AEngine_PlayerState* OwningState)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.CreateTalkerForPlayer");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.CreateTalkerForPlayer");

	UEngine_VOIPTalker_CreateTalkerForPlayer_Params params;
	params.OwningState = OwningState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;

	return params.ReturnValue;
}


// Function Engine.VOIPTalker.BPOnTalkingEnd
// (Native, Event, Protected, BlueprintEvent)

void UEngine_VOIPTalker::BPOnTalkingEnd()
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.BPOnTalkingEnd");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.BPOnTalkingEnd");

	UEngine_VOIPTalker_BPOnTalkingEnd_Params params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VOIPTalker.BPOnTalkingBegin
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UEngine_AudioComponent*  AudioComponent                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData)

void UEngine_VOIPTalker::BPOnTalkingBegin(class UEngine_AudioComponent* AudioComponent)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.BPOnTalkingBegin");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VOIPTalker.BPOnTalkingBegin");

	UEngine_VOIPTalker_BPOnTalkingBegin_Params params;
	params.AudioComponent = AudioComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.VOIPStatics.SetMicThreshold
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                          InThreshold                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_VOIPStatics::STATIC_SetMicThreshold(float InThreshold)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.VOIPStatics.SetMicThreshold");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.VOIPStatics.SetMicThreshold");

	UEngine_VOIPStatics_SetMicThreshold_Params params;
	params.InThreshold = InThreshold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WindDirectionalSourceComponent.SetWindType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// FEngine_Engine_EWindSourceType InNewType                      (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_WindDirectionalSourceComponent::SetWindType(FEngine_Engine_EWindSourceType InNewType)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetWindType");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetWindType");

	UEngine_WindDirectionalSourceComponent_SetWindType_Params params;
	params.InNewType = InNewType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WindDirectionalSourceComponent.SetStrength
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InNewStrength                  (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_WindDirectionalSourceComponent::SetStrength(float InNewStrength)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetStrength");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetStrength");

	UEngine_WindDirectionalSourceComponent_SetStrength_Params params;
	params.InNewStrength = InNewStrength;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WindDirectionalSourceComponent.SetSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InNewSpeed                     (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_WindDirectionalSourceComponent::SetSpeed(float InNewSpeed)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetSpeed");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetSpeed");

	UEngine_WindDirectionalSourceComponent_SetSpeed_Params params;
	params.InNewSpeed = InNewSpeed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WindDirectionalSourceComponent.SetRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InNewRadius                    (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_WindDirectionalSourceComponent::SetRadius(float InNewRadius)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetRadius");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetRadius");

	UEngine_WindDirectionalSourceComponent_SetRadius_Params params;
	params.InNewRadius = InNewRadius;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WindDirectionalSourceComponent.SetMinimumGustAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InNewMinGust                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_WindDirectionalSourceComponent::SetMinimumGustAmount(float InNewMinGust)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetMinimumGustAmount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetMinimumGustAmount");

	UEngine_WindDirectionalSourceComponent_SetMinimumGustAmount_Params params;
	params.InNewMinGust = InNewMinGust;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


// Function Engine.WindDirectionalSourceComponent.SetMaximumGustAmount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                          InNewMaxGust                   (Parm, ZeroConstructor, IsPlainOldData)

void UEngine_WindDirectionalSourceComponent::SetMaximumGustAmount(float InNewMaxGust)
{
	static auto fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetMaximumGustAmount");

	if (!fn)
		fn = UObject::FindObject<UFunction>("Function Engine.WindDirectionalSourceComponent.SetMaximumGustAmount");

	UEngine_WindDirectionalSourceComponent_SetMaximumGustAmount_Params params;
	params.InNewMaxGust = InNewMaxGust;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x400;

	UObject::ProcessEvent(fn, &params);

	fn->FunctionFlags = flags;
}


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
